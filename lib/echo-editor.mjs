var Y6 = Object.defineProperty;
var X6 = (t, e, n) => e in t ? Y6(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Ws = (t, e, n) => (X6(t, typeof e != "symbol" ? e + "" : e, n), n);
import { defineComponent as T, ref as O, onMounted as _e, onBeforeUnmount as jo, h as jt, markRaw as Vc, getCurrentInstance as In, watchEffect as Pe, nextTick as qe, unref as p, shallowRef as Xd, customRef as tm, reactive as zn, render as p0, provide as Ma, computed as P, effectScope as nm, getCurrentScope as om, onScopeDispose as rm, toRef as _b, readonly as Cs, watch as ce, shallowReadonly as Li, camelize as Mb, Comment as Z6, mergeProps as j, cloneVNode as Q6, toRefs as mt, renderSlot as D, openBlock as k, createBlock as _, normalizeProps as Oe, guardReactiveProps as Le, withCtx as w, createVNode as E, createCommentVNode as ae, isRef as ri, withKeys as Sr, resolveDynamicComponent as _n, normalizeStyle as ct, createElementBlock as U, Fragment as ve, createElementVNode as B, createTextVNode as he, onUnmounted as en, toHandlers as e8, toHandlerKey as t8, Teleport as gl, withModifiers as yt, toDisplayString as q, useSlots as Tb, inject as im, onBeforeUpdate as n8, onUpdated as o8, mergeDefaults as Ob, renderList as Fe, onBeforeMount as r8, withDirectives as Sn, vModelSelect as i8, createSlots as Ib, vShow as Jn, normalizeClass as Ze, vModelText as s8, isVNode as a8, useAttrs as l8 } from "vue";
function Mt(t) {
  this.content = t;
}
Mt.prototype = {
  constructor: Mt,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t)
        return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var o = n && n != t ? this.remove(n) : this, r = o.find(t), i = o.content.slice();
    return r == -1 ? i.push(n || t, e) : (i[r + 1] = e, n && (i[r] = n)), new Mt(i);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1)
      return this;
    var n = this.content.slice();
    return n.splice(e, 2), new Mt(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new Mt([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new Mt(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var o = this.remove(e), r = o.content.slice(), i = o.find(t);
    return r.splice(i == -1 ? r.length : i, 0, e, n), new Mt(r);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = Mt.from(t), t.size ? new Mt(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = Mt.from(t), t.size ? new Mt(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = Mt.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Mt.from = function(t) {
  if (t instanceof Mt)
    return t;
  var e = [];
  if (t)
    for (var n in t)
      e.push(n, t[n]);
  return new Mt(e);
};
function Db(t, e, n) {
  for (let o = 0; ; o++) {
    if (o == t.childCount || o == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let r = t.child(o), i = e.child(o);
    if (r == i) {
      n += r.nodeSize;
      continue;
    }
    if (!r.sameMarkup(i))
      return n;
    if (r.isText && r.text != i.text) {
      for (let s = 0; r.text[s] == i.text[s]; s++)
        n++;
      return n;
    }
    if (r.content.size || i.content.size) {
      let s = Db(r.content, i.content, n + 1);
      if (s != null)
        return s;
    }
    n += r.nodeSize;
  }
}
function Rb(t, e, n, o) {
  for (let r = t.childCount, i = e.childCount; ; ) {
    if (r == 0 || i == 0)
      return r == i ? null : { a: n, b: o };
    let s = t.child(--r), a = e.child(--i), l = s.nodeSize;
    if (s == a) {
      n -= l, o -= l;
      continue;
    }
    if (!s.sameMarkup(a))
      return { a: n, b: o };
    if (s.isText && s.text != a.text) {
      let c = 0, d = Math.min(s.text.length, a.text.length);
      for (; c < d && s.text[s.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, o--;
      return { a: n, b: o };
    }
    if (s.content.size || a.content.size) {
      let c = Rb(s.content, a.content, n - 1, o - 1);
      if (c)
        return c;
    }
    n -= l, o -= l;
  }
}
class W {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let o = 0; o < e.length; o++)
        this.size += e[o].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, o, r = 0, i) {
    for (let s = 0, a = 0; a < n; s++) {
      let l = this.content[s], c = a + l.nodeSize;
      if (c > e && o(l, r + a, i || null, s) !== !1 && l.content.size) {
        let d = a + 1;
        l.nodesBetween(Math.max(0, e - d), Math.min(l.content.size, n - d), o, r + d);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, o, r) {
    let i = "", s = !0;
    return this.nodesBetween(e, n, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? r ? typeof r == "function" ? r(a) : r : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && o && (s ? s = !1 : i += o), i += c;
    }, 0), i;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, o = e.firstChild, r = this.content.slice(), i = 0;
    for (n.isText && n.sameMarkup(o) && (r[r.length - 1] = n.withText(n.text + o.text), i = 1); i < e.content.length; i++)
      r.push(e.content[i]);
    return new W(r, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let o = [], r = 0;
    if (n > e)
      for (let i = 0, s = 0; s < n; i++) {
        let a = this.content[i], l = s + a.nodeSize;
        l > e && ((s < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, e - s - 1), Math.min(a.content.size, n - s - 1))), o.push(a), r += a.nodeSize), s = l;
      }
    return new W(o, r);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? W.empty : e == 0 && n == this.content.length ? this : new W(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let o = this.content[e];
    if (o == n)
      return this;
    let r = this.content.slice(), i = this.size + n.nodeSize - o.nodeSize;
    return r[e] = n, new W(r, i);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new W([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new W(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, o = 0; n < this.content.length; n++) {
      let r = this.content[n];
      e(r, o, n), o += r.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return Db(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, o = e.size) {
    return Rb(this, e, n, o);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return Bl(0, e);
    if (e == this.size)
      return Bl(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let o = 0, r = 0; ; o++) {
      let i = this.child(o), s = r + i.nodeSize;
      if (s >= e)
        return s == e || n > 0 ? Bl(o + 1, s) : Bl(o, r);
      r = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return W.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new W(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return W.empty;
    let n, o = 0;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      o += i.nodeSize, r && i.isText && e[r - 1].sameMarkup(i) ? (n || (n = e.slice(0, r)), n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)) : n && n.push(i);
    }
    return new W(n || e, o);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return W.empty;
    if (e instanceof W)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new W([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
W.empty = new W([], 0);
const sf = { index: 0, offset: 0 };
function Bl(t, e) {
  return sf.index = t, sf.offset = e, sf;
}
function jc(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let o = 0; o < t.length; o++)
      if (!jc(t[o], e[o]))
        return !1;
  } else {
    for (let o in t)
      if (!(o in e) || !jc(t[o], e[o]))
        return !1;
    for (let o in e)
      if (!(o in t))
        return !1;
  }
  return !0;
}
let Xe = class xp {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, o = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.eq(i))
        return e;
      if (this.type.excludes(i.type))
        n || (n = e.slice(0, r));
      else {
        if (i.type.excludes(this.type))
          return e;
        !o && i.type.rank > this.type.rank && (n || (n = e.slice(0, r)), n.push(this), o = !0), n && n.push(i);
      }
    }
    return n || (n = e.slice()), o || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && jc(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let o = e.marks[n.type];
    if (!o)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let r = o.create(n.attrs);
    return o.checkAttrs(r.attrs), r;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let o = 0; o < e.length; o++)
      if (!e[o].eq(n[o]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return xp.none;
    if (e instanceof xp)
      return [e];
    let n = e.slice();
    return n.sort((o, r) => o.type.rank - r.type.rank), n;
  }
};
Xe.none = [];
class Uc extends Error {
}
class ee {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, o) {
    this.content = e, this.openStart = n, this.openEnd = o;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let o = Lb(this.content, e + this.openStart, n);
    return o && new ee(o, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new ee(Pb(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return ee.empty;
    let o = n.openStart || 0, r = n.openEnd || 0;
    if (typeof o != "number" || typeof r != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new ee(W.fromJSON(e, n.content), o, r);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let o = 0, r = 0;
    for (let i = e.firstChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.firstChild)
      o++;
    for (let i = e.lastChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.lastChild)
      r++;
    return new ee(e, o, r);
  }
}
ee.empty = new ee(W.empty, 0, 0);
function Pb(t, e, n) {
  let { index: o, offset: r } = t.findIndex(e), i = t.maybeChild(o), { index: s, offset: a } = t.findIndex(n);
  if (r == e || i.isText) {
    if (a != n && !t.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (o != s)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(o, i.copy(Pb(i.content, e - r - 1, n - r - 1)));
}
function Lb(t, e, n, o) {
  let { index: r, offset: i } = t.findIndex(e), s = t.maybeChild(r);
  if (i == e || s.isText)
    return t.cut(0, e).append(n).append(t.cut(e));
  let a = Lb(s.content, e - i - 1, n);
  return a && t.replaceChild(r, s.copy(a));
}
function c8(t, e, n) {
  if (n.openStart > t.depth)
    throw new Uc("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new Uc("Inconsistent open depths");
  return Nb(t, e, n, 0);
}
function Nb(t, e, n, o) {
  let r = t.index(o), i = t.node(o);
  if (r == e.index(o) && o < t.depth - n.openStart) {
    let s = Nb(t, e, n, o + 1);
    return i.copy(i.content.replaceChild(r, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == o && e.depth == o) {
      let s = t.parent, a = s.content;
      return si(s, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: s, end: a } = d8(n, t);
      return si(i, $b(t, s, a, e, o));
    }
  else
    return si(i, Wc(t, e, o));
}
function Bb(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new Uc("Cannot join " + e.type.name + " onto " + t.type.name);
}
function kp(t, e, n) {
  let o = t.node(n);
  return Bb(o, e.node(n)), o;
}
function ii(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function aa(t, e, n, o) {
  let r = (e || t).node(n), i = 0, s = e ? e.index(n) : r.childCount;
  t && (i = t.index(n), t.depth > n ? i++ : t.textOffset && (ii(t.nodeAfter, o), i++));
  for (let a = i; a < s; a++)
    ii(r.child(a), o);
  e && e.depth == n && e.textOffset && ii(e.nodeBefore, o);
}
function si(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function $b(t, e, n, o, r) {
  let i = t.depth > r && kp(t, e, r + 1), s = o.depth > r && kp(n, o, r + 1), a = [];
  return aa(null, t, r, a), i && s && e.index(r) == n.index(r) ? (Bb(i, s), ii(si(i, $b(t, e, n, o, r + 1)), a)) : (i && ii(si(i, Wc(t, e, r + 1)), a), aa(e, n, r, a), s && ii(si(s, Wc(n, o, r + 1)), a)), aa(o, null, r, a), new W(a);
}
function Wc(t, e, n) {
  let o = [];
  if (aa(null, t, n, o), t.depth > n) {
    let r = kp(t, e, n + 1);
    ii(si(r, Wc(t, e, n + 1)), o);
  }
  return aa(e, null, n, o), new W(o);
}
function d8(t, e) {
  let n = e.depth - t.openStart, r = e.node(n).copy(t.content);
  for (let i = n - 1; i >= 0; i--)
    r = e.node(i).copy(W.from(r));
  return {
    start: r.resolveNoCache(t.openStart + n),
    end: r.resolveNoCache(r.content.size - t.openEnd - n)
  };
}
class Ta {
  /**
  @internal
  */
  constructor(e, n, o) {
    this.pos = e, this.path = n, this.parentOffset = o, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let o = this.pos - this.path[this.path.length - 1], r = e.child(n);
    return o ? e.child(n).cut(o) : r;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let o = this.path[n * 3], r = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let i = 0; i < e; i++)
      r += o.child(i).nodeSize;
    return r;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return Xe.none;
    if (this.textOffset)
      return e.child(n).marks;
    let o = e.maybeChild(n - 1), r = e.maybeChild(n);
    if (!o) {
      let a = o;
      o = r, r = a;
    }
    let i = o.marks;
    for (var s = 0; s < i.length; s++)
      i[s].type.spec.inclusive === !1 && (!r || !i[s].isInSet(r.marks)) && (i = i[s--].removeFromSet(i));
    return i;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let o = n.marks, r = e.parent.maybeChild(e.index());
    for (var i = 0; i < o.length; i++)
      o[i].type.spec.inclusive === !1 && (!r || !o[i].isInSet(r.marks)) && (o = o[i--].removeFromSet(o));
    return o;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let o = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); o >= 0; o--)
      if (e.pos <= this.end(o) && (!n || n(this.node(o))))
        return new Oa(this, e, o);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let o = [], r = 0, i = n;
    for (let s = e; ; ) {
      let { index: a, offset: l } = s.content.findIndex(i), c = i - l;
      if (o.push(s, a, r + l), !c || (s = s.child(a), s.isText))
        break;
      i = c - 1, r += l + 1;
    }
    return new Ta(n, o, i);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let o = h0.get(e);
    if (o)
      for (let i = 0; i < o.elts.length; i++) {
        let s = o.elts[i];
        if (s.pos == n)
          return s;
      }
    else
      h0.set(e, o = new u8());
    let r = o.elts[o.i] = Ta.resolve(e, n);
    return o.i = (o.i + 1) % f8, r;
  }
}
class u8 {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const f8 = 12, h0 = /* @__PURE__ */ new WeakMap();
class Oa {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, o) {
    this.$from = e, this.$to = n, this.depth = o;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const p8 = /* @__PURE__ */ Object.create(null);
let wr = class Cp {
  /**
  @internal
  */
  constructor(e, n, o, r = Xe.none) {
    this.type = e, this.attrs = n, this.marks = r, this.content = o || W.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, o, r = 0) {
    this.content.nodesBetween(e, n, o, r, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, o, r) {
    return this.content.textBetween(e, n, o, r);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, o) {
    return this.type == e && jc(this.attrs, n || e.defaultAttrs || p8) && Xe.sameSet(this.marks, o || Xe.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Cp(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Cp(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, o = !1) {
    if (e == n)
      return ee.empty;
    let r = this.resolve(e), i = this.resolve(n), s = o ? 0 : r.sharedDepth(n), a = r.start(s), c = r.node(s).content.cut(r.pos - a, i.pos - a);
    return new ee(c, r.depth - s, i.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, o) {
    return c8(this.resolve(e), this.resolve(n), o);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: o, offset: r } = n.content.findIndex(e);
      if (n = n.maybeChild(o), !n)
        return null;
      if (r == e || n.isText)
        return n;
      e -= r + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: o } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: o };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: o } = this.content.findIndex(e);
    if (o < e)
      return { node: this.content.child(n), index: n, offset: o };
    let r = this.content.child(n - 1);
    return { node: r, index: n - 1, offset: o - r.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Ta.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Ta.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, o) {
    let r = !1;
    return n > e && this.nodesBetween(e, n, (i) => (o.isInSet(i.marks) && (r = !0), !r)), r;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), zb(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, o = W.empty, r = 0, i = o.childCount) {
    let s = this.contentMatchAt(e).matchFragment(o, r, i), a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = r; l < i; l++)
      if (!this.type.allowsMarks(o.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, o, r) {
    if (r && !this.type.allowsMarks(r))
      return !1;
    let i = this.contentMatchAt(e).matchType(o), s = i && i.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Xe.none;
    for (let n = 0; n < this.marks.length; n++) {
      let o = this.marks[n];
      o.type.checkAttrs(o.attrs), e = o.addToSet(e);
    }
    if (!Xe.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let o;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      o = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, o);
    }
    let r = W.fromJSON(e, n.content), i = e.nodeType(n.type).create(n.attrs, r, o);
    return i.type.checkAttrs(i.attrs), i;
  }
};
wr.prototype.text = void 0;
class Kc extends wr {
  /**
  @internal
  */
  constructor(e, n, o, r) {
    if (super(e, n, null, r), !o)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = o;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : zb(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Kc(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Kc(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function zb(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class fi {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let o = new h8(e, n);
    if (o.next == null)
      return fi.empty;
    let r = Fb(o);
    o.next && o.err("Unexpected trailing text");
    let i = x8(w8(r));
    return k8(i, o), i;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, o = e.childCount) {
    let r = this;
    for (let i = n; r && i < o; i++)
      r = r.matchType(e.child(i).type);
    return r;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let o = 0; o < e.next.length; o++)
        if (this.next[n].type == e.next[o].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, o = 0) {
    let r = [this];
    function i(s, a) {
      let l = s.matchFragment(e, o);
      if (l && (!n || l.validEnd))
        return W.from(a.map((c) => c.createAndFill()));
      for (let c = 0; c < s.next.length; c++) {
        let { type: d, next: u } = s.next[c];
        if (!(d.isText || d.hasRequiredAttrs()) && r.indexOf(u) == -1) {
          r.push(u);
          let f = i(u, a.concat(d));
          if (f)
            return f;
        }
      }
      return null;
    }
    return i(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let o = 0; o < this.wrapCache.length; o += 2)
      if (this.wrapCache[o] == e)
        return this.wrapCache[o + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), o = [{ match: this, type: null, via: null }];
    for (; o.length; ) {
      let r = o.shift(), i = r.match;
      if (i.matchType(e)) {
        let s = [];
        for (let a = r; a.type; a = a.via)
          s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < i.next.length; s++) {
        let { type: a, next: l } = i.next[s];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!r.type || l.validEnd) && (o.push({ match: a.contentMatch, type: a, via: r }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(o) {
      e.push(o);
      for (let r = 0; r < o.next.length; r++)
        e.indexOf(o.next[r].next) == -1 && n(o.next[r].next);
    }
    return n(this), e.map((o, r) => {
      let i = r + (o.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < o.next.length; s++)
        i += (s ? ", " : "") + o.next[s].type.name + "->" + e.indexOf(o.next[s].next);
      return i;
    }).join(`
`);
  }
}
fi.empty = new fi(!0);
class h8 {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function Fb(t) {
  let e = [];
  do
    e.push(m8(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function m8(t) {
  let e = [];
  do
    e.push(g8(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function g8(t) {
  let e = b8(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = v8(t, e);
    else
      break;
  return e;
}
function m0(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function v8(t, e) {
  let n = m0(t), o = n;
  return t.eat(",") && (t.next != "}" ? o = m0(t) : o = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: o, expr: e };
}
function y8(t, e) {
  let n = t.nodeTypes, o = n[e];
  if (o)
    return [o];
  let r = [];
  for (let i in n) {
    let s = n[i];
    s.isInGroup(e) && r.push(s);
  }
  return r.length == 0 && t.err("No node type or group '" + e + "' found"), r;
}
function b8(t) {
  if (t.eat("(")) {
    let e = Fb(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = y8(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function w8(t) {
  let e = [[]];
  return r(i(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function o(s, a, l) {
    let c = { term: l, to: a };
    return e[s].push(c), c;
  }
  function r(s, a) {
    s.forEach((l) => l.to = a);
  }
  function i(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((l, c) => l.concat(i(c, a)), []);
    if (s.type == "seq")
      for (let l = 0; ; l++) {
        let c = i(s.exprs[l], a);
        if (l == s.exprs.length - 1)
          return c;
        r(c, a = n());
      }
    else if (s.type == "star") {
      let l = n();
      return o(a, l), r(i(s.expr, l), l), [o(l)];
    } else if (s.type == "plus") {
      let l = n();
      return r(i(s.expr, a), l), r(i(s.expr, l), l), [o(l)];
    } else {
      if (s.type == "opt")
        return [o(a)].concat(i(s.expr, a));
      if (s.type == "range") {
        let l = a;
        for (let c = 0; c < s.min; c++) {
          let d = n();
          r(i(s.expr, l), d), l = d;
        }
        if (s.max == -1)
          r(i(s.expr, l), l);
        else
          for (let c = s.min; c < s.max; c++) {
            let d = n();
            o(l, d), r(i(s.expr, l), d), l = d;
          }
        return [o(l)];
      } else {
        if (s.type == "name")
          return [o(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function Hb(t, e) {
  return e - t;
}
function g0(t, e) {
  let n = [];
  return o(e), n.sort(Hb);
  function o(r) {
    let i = t[r];
    if (i.length == 1 && !i[0].term)
      return o(i[0].to);
    n.push(r);
    for (let s = 0; s < i.length; s++) {
      let { term: a, to: l } = i[s];
      !a && n.indexOf(l) == -1 && o(l);
    }
  }
}
function x8(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(g0(t, 0));
  function n(o) {
    let r = [];
    o.forEach((s) => {
      t[s].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let c;
        for (let d = 0; d < r.length; d++)
          r[d][0] == a && (c = r[d][1]);
        g0(t, l).forEach((d) => {
          c || r.push([a, c = []]), c.indexOf(d) == -1 && c.push(d);
        });
      });
    });
    let i = e[o.join(",")] = new fi(o.indexOf(t.length - 1) > -1);
    for (let s = 0; s < r.length; s++) {
      let a = r[s][1].sort(Hb);
      i.next.push({ type: r[s][0], next: e[a.join(",")] || n(a) });
    }
    return i;
  }
}
function k8(t, e) {
  for (let n = 0, o = [t]; n < o.length; n++) {
    let r = o[n], i = !r.validEnd, s = [];
    for (let a = 0; a < r.next.length; a++) {
      let { type: l, next: c } = r.next[a];
      s.push(l.name), i && !(l.isText || l.hasRequiredAttrs()) && (i = !1), o.indexOf(c) == -1 && o.push(c);
    }
    i && e.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function Vb(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let o = t[n];
    if (!o.hasDefault)
      return null;
    e[n] = o.default;
  }
  return e;
}
function jb(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let o in t) {
    let r = e && e[o];
    if (r === void 0) {
      let i = t[o];
      if (i.hasDefault)
        r = i.default;
      else
        throw new RangeError("No value supplied for attribute " + o);
    }
    n[o] = r;
  }
  return n;
}
function Ub(t, e, n, o) {
  for (let r in e)
    if (!(r in t))
      throw new RangeError(`Unsupported attribute ${r} for ${n} of type ${r}`);
  for (let r in t) {
    let i = t[r];
    i.validate && i.validate(e[r]);
  }
}
function Wb(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let o in e)
      n[o] = new S8(t, o, e[o]);
  return n;
}
let v0 = class Kb {
  /**
  @internal
  */
  constructor(e, n, o) {
    this.name = e, this.schema = n, this.spec = o, this.markSet = null, this.groups = o.group ? o.group.split(" ") : [], this.attrs = Wb(e, o.attrs), this.defaultAttrs = Vb(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(o.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == fi.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : jb(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, o) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new wr(this, this.computeAttrs(e), W.from(n), Xe.setFrom(o));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, o) {
    return n = W.from(n), this.checkContent(n), new wr(this, this.computeAttrs(e), n, Xe.setFrom(o));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, o) {
    if (e = this.computeAttrs(e), n = W.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let r = this.contentMatch.matchFragment(n), i = r && r.fillBefore(W.empty, !0);
    return i ? new wr(this, e, n.append(i), Xe.setFrom(o)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let o = 0; o < e.childCount; o++)
      if (!this.allowsMarks(e.child(o).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    Ub(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let o = 0; o < e.length; o++)
      this.allowsMarkType(e[o].type) ? n && n.push(e[o]) : n || (n = e.slice(0, o));
    return n ? n.length ? n : Xe.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let o = /* @__PURE__ */ Object.create(null);
    e.forEach((i, s) => o[i] = new Kb(i, n, s));
    let r = n.spec.topNode || "doc";
    if (!o[r])
      throw new RangeError("Schema is missing its top node type ('" + r + "')");
    if (!o.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let i in o.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return o;
  }
};
function C8(t, e, n) {
  let o = n.split("|");
  return (r) => {
    let i = r === null ? "null" : typeof r;
    if (o.indexOf(i) < 0)
      throw new RangeError(`Expected value of type ${o} for attribute ${e} on type ${t}, got ${i}`);
  };
}
class S8 {
  constructor(e, n, o) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(o, "default"), this.default = o.default, this.validate = typeof o.validate == "string" ? C8(e, n, o.validate) : o.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Zd {
  /**
  @internal
  */
  constructor(e, n, o, r) {
    this.name = e, this.rank = n, this.schema = o, this.spec = r, this.attrs = Wb(e, r.attrs), this.excluded = null;
    let i = Vb(this.attrs);
    this.instance = i ? new Xe(this, i) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Xe(this, jb(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let o = /* @__PURE__ */ Object.create(null), r = 0;
    return e.forEach((i, s) => o[i] = new Zd(i, r++, n, s)), o;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    Ub(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class qb {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let r in e)
      n[r] = e[r];
    n.nodes = Mt.from(e.nodes), n.marks = Mt.from(e.marks || {}), this.nodes = v0.compile(this.spec.nodes, this), this.marks = Zd.compile(this.spec.marks, this);
    let o = /* @__PURE__ */ Object.create(null);
    for (let r in this.nodes) {
      if (r in this.marks)
        throw new RangeError(r + " can not be both a node and a mark");
      let i = this.nodes[r], s = i.spec.content || "", a = i.spec.marks;
      if (i.contentMatch = o[s] || (o[s] = fi.parse(s, this.nodes)), i.inlineContent = i.contentMatch.inlineContent, i.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!i.isInline || !i.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = i;
      }
      i.markSet = a == "_" ? null : a ? y0(this, a.split(" ")) : a == "" || !i.inlineContent ? [] : null;
    }
    for (let r in this.marks) {
      let i = this.marks[r], s = i.spec.excludes;
      i.excluded = s == null ? [i] : s == "" ? [] : y0(this, s.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, o, r) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof v0) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else
      throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, o, r);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let o = this.nodes.text;
    return new Kc(o, o.defaultAttrs, e, Xe.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return wr.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return Xe.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function y0(t, e) {
  let n = [];
  for (let o = 0; o < e.length; o++) {
    let r = e[o], i = t.marks[r], s = i;
    if (i)
      n.push(i);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (r == "_" || l.spec.group && l.spec.group.split(" ").indexOf(r) > -1) && n.push(s = l);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + e[o] + "'");
  }
  return n;
}
function A8(t) {
  return t.tag != null;
}
function E8(t) {
  return t.style != null;
}
let la = class Sp {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let o = this.matchedStyles = [];
    n.forEach((r) => {
      if (A8(r))
        this.tags.push(r);
      else if (E8(r)) {
        let i = /[^=]*/.exec(r.style)[0];
        o.indexOf(i) < 0 && o.push(i), this.styles.push(r);
      }
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let i = e.nodes[r.node];
      return i.contentMatch.matchType(i);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let o = new w0(this, n, !1);
    return o.addAll(e, Xe.none, n.from, n.to), o.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let o = new w0(this, n, !0);
    return o.addAll(e, Xe.none, n.from, n.to), ee.maxOpen(o.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, o) {
    for (let r = o ? this.tags.indexOf(o) + 1 : 0; r < this.tags.length; r++) {
      let i = this.tags[r];
      if (T8(e, i.tag) && (i.namespace === void 0 || e.namespaceURI == i.namespace) && (!i.context || n.matchesContext(i.context))) {
        if (i.getAttrs) {
          let s = i.getAttrs(e);
          if (s === !1)
            continue;
          i.attrs = s || void 0;
        }
        return i;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, o, r) {
    for (let i = r ? this.styles.indexOf(r) + 1 : 0; i < this.styles.length; i++) {
      let s = this.styles[i], a = s.style;
      if (!(a.indexOf(e) != 0 || s.context && !o.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (s.getAttrs) {
          let l = s.getAttrs(n);
          if (l === !1)
            continue;
          s.attrs = l || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function o(r) {
      let i = r.priority == null ? 50 : r.priority, s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < i)
          break;
      }
      n.splice(s, 0, r);
    }
    for (let r in e.marks) {
      let i = e.marks[r].spec.parseDOM;
      i && i.forEach((s) => {
        o(s = x0(s)), s.mark || s.ignore || s.clearMark || (s.mark = r);
      });
    }
    for (let r in e.nodes) {
      let i = e.nodes[r].spec.parseDOM;
      i && i.forEach((s) => {
        o(s = x0(s)), s.node || s.ignore || s.mark || (s.node = r);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Sp(e, Sp.schemaRules(e)));
  }
};
const Gb = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, _8 = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, Jb = { ol: !0, ul: !0 }, Ia = 1, Ap = 2, ca = 4;
function b0(t, e, n) {
  return e != null ? (e ? Ia : 0) | (e === "full" ? Ap : 0) : t && t.whitespace == "pre" ? Ia | Ap : n & ~ca;
}
class $l {
  constructor(e, n, o, r, i, s) {
    this.type = e, this.attrs = n, this.marks = o, this.solid = r, this.options = s, this.content = [], this.activeMarks = Xe.none, this.match = i || (s & ca ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(W.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let o = this.type.contentMatch, r;
        return (r = o.findWrapping(e.type)) ? (this.match = o, r) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Ia)) {
      let o = this.content[this.content.length - 1], r;
      if (o && o.isText && (r = /[ \t\r\n\u000c]+$/.exec(o.text))) {
        let i = o;
        o.text.length == r[0].length ? this.content.pop() : this.content[this.content.length - 1] = i.withText(i.text.slice(0, i.text.length - r[0].length));
      }
    }
    let n = W.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(W.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Gb.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class w0 {
  constructor(e, n, o) {
    this.parser = e, this.options = n, this.isOpen = o, this.open = 0, this.localPreserveWS = !1;
    let r = n.topNode, i, s = b0(null, n.preserveWhitespace, 0) | (o ? ca : 0);
    r ? i = new $l(r.type, r.attrs, Xe.none, !0, n.topMatch || r.type.contentMatch, s) : o ? i = new $l(null, null, Xe.none, !0, null, s) : i = new $l(e.schema.topNodeType, null, Xe.none, !0, null, s), this.nodes = [i], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let o = e.nodeValue, r = this.top, i = r.options & Ap ? "full" : this.localPreserveWS || (r.options & Ia) > 0;
    if (i === "full" || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(o)) {
      if (i)
        i !== "full" ? o = o.replace(/\r?\n|\r/g, " ") : o = o.replace(/\r\n?/g, `
`);
      else if (o = o.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(o) && this.open == this.nodes.length - 1) {
        let s = r.content[r.content.length - 1], a = e.previousSibling;
        (!s || a && a.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (o = o.slice(1));
      }
      o && this.insertNode(this.parser.schema.text(o), n), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, o) {
    let r = this.localPreserveWS, i = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let s = e.nodeName.toLowerCase(), a;
    Jb.hasOwnProperty(s) && this.parser.normalizeLists && M8(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, o));
    e:
      if (l ? l.ignore : _8.hasOwnProperty(s))
        this.findInside(e), this.ignoreFallback(e, n);
      else if (!l || l.skip || l.closeParent) {
        l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
        let c, d = this.needsBlock;
        if (Gb.hasOwnProperty(s))
          i.content.length && i.content[0].isInline && this.open && (this.open--, i = this.top), c = !0, i.type || (this.needsBlock = !0);
        else if (!e.firstChild) {
          this.leafFallback(e, n);
          break e;
        }
        let u = l && l.skip ? n : this.readStyles(e, n);
        u && this.addAll(e, u), c && this.sync(i), this.needsBlock = d;
      } else {
        let c = this.readStyles(e, n);
        c && this.addElementByRule(e, l, c, l.consuming === !1 ? a : void 0);
      }
    this.localPreserveWS = r;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let o = e.style;
    if (o && o.length)
      for (let r = 0; r < this.parser.matchedStyles.length; r++) {
        let i = this.parser.matchedStyles[r], s = o.getPropertyValue(i);
        if (s)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(i, s, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((c) => !l.clearMark(c)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, o, r) {
    let i, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), o) || this.leafFallback(e, o);
      else {
        let l = this.enter(s, n.attrs || null, o, n.preserveWhitespace);
        l && (i = !0, o = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      o = o.concat(l.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (r)
      this.addElement(e, o, r);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, o));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l, o), this.findAround(e, l, !1);
    }
    i && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, o, r) {
    let i = o || 0;
    for (let s = o ? e.childNodes[o] : e.firstChild, a = r == null ? null : e.childNodes[r]; s != a; s = s.nextSibling, ++i)
      this.findAtPoint(e, i), this.addDOM(s, n);
    this.findAtPoint(e, i);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n) {
    let o, r;
    for (let i = this.open; i >= 0; i--) {
      let s = this.nodes[i], a = s.findWrapping(e);
      if (a && (!o || o.length > a.length) && (o = a, r = s, !a.length) || s.solid)
        break;
    }
    if (!o)
      return null;
    this.sync(r);
    for (let i = 0; i < o.length; i++)
      n = this.enterInner(o[i], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let r = this.textblockFromContext();
      r && (n = this.enterInner(r, null, n));
    }
    let o = this.findPlace(e, n);
    if (o) {
      this.closeExtra();
      let r = this.top;
      r.match && (r.match = r.match.matchType(e.type));
      let i = Xe.none;
      for (let s of o.concat(e.marks))
        (r.type ? r.type.allowsMarkType(s.type) : k0(s.type, e.type)) && (i = s.addToSet(i));
      return r.content.push(e.mark(i)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, o, r) {
    let i = this.findPlace(e.create(n), o);
    return i && (i = this.enterInner(e, n, o, !0, r)), i;
  }
  // Open a node of the given type
  enterInner(e, n, o, r = !1, i) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(e);
    let a = b0(e, i, s.options);
    s.options & ca && s.content.length == 0 && (a |= ca);
    let l = Xe.none;
    return o = o.filter((c) => (s.type ? s.type.allowsMarkType(c.type) : k0(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new $l(e, n, l, r, null, a)), this.open++, o;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= Ia);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let o = this.nodes[n].content;
      for (let r = o.length - 1; r >= 0; r--)
        e += o[r].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let o = 0; o < this.find.length; o++)
        this.find[o].node == e && this.find[o].offset == n && (this.find[o].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, o) {
    if (e != n && this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].pos == null && e.nodeType == 1 && e.contains(this.find[r].node) && n.compareDocumentPosition(this.find[r].node) & (o ? 2 : 4) && (this.find[r].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), o = this.options.context, r = !this.isOpen && (!o || o.parent.type == this.nodes[0].type), i = -(o ? o.depth + 1 : 0) + (r ? 0 : 1), s = (a, l) => {
      for (; a >= 0; a--) {
        let c = n[a];
        if (c == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= i; l--)
            if (s(a - 1, l))
              return !0;
          return !1;
        } else {
          let d = l > 0 || l == 0 && r ? this.nodes[l].type : o && l >= i ? o.node(l - i).type : null;
          if (!d || d.name != c && !d.isInGroup(c))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let o = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (o && o.isTextblock && o.defaultAttrs)
          return o;
      }
    for (let n in this.parser.schema.nodes) {
      let o = this.parser.schema.nodes[n];
      if (o.isTextblock && o.defaultAttrs)
        return o;
    }
  }
}
function M8(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let o = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    o && Jb.hasOwnProperty(o) && n ? (n.appendChild(e), e = n) : o == "li" ? n = e : o && (n = null);
  }
}
function T8(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function x0(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function k0(t, e) {
  let n = e.schema.nodes;
  for (let o in n) {
    let r = n[o];
    if (!r.allowsMarkType(t))
      continue;
    let i = [], s = (a) => {
      i.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: d } = a.edge(l);
        if (c == e || i.indexOf(d) < 0 && s(d))
          return !0;
      }
    };
    if (s(r.contentMatch))
      return !0;
  }
}
class Nr {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, o) {
    o || (o = af(n).createDocumentFragment());
    let r = o, i = [];
    return e.forEach((s) => {
      if (i.length || s.marks.length) {
        let a = 0, l = 0;
        for (; a < i.length && l < s.marks.length; ) {
          let c = s.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(i[a][0]) || c.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < i.length; )
          r = i.pop()[1];
        for (; l < s.marks.length; ) {
          let c = s.marks[l++], d = this.serializeMark(c, s.isInline, n);
          d && (i.push([c, r]), r.appendChild(d.dom), r = d.contentDOM || d.dom);
        }
      }
      r.appendChild(this.serializeNodeInner(s, n));
    }), o;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: o, contentDOM: r } = Ac(af(n), this.nodes[e.type.name](e), null, e.attrs);
    if (r) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, r);
    }
    return o;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let o = this.serializeNodeInner(e, n);
    for (let r = e.marks.length - 1; r >= 0; r--) {
      let i = this.serializeMark(e.marks[r], e.isInline, n);
      i && ((i.contentDOM || i.dom).appendChild(o), o = i.dom);
    }
    return o;
  }
  /**
  @internal
  */
  serializeMark(e, n, o = {}) {
    let r = this.marks[e.type.name];
    return r && Ac(af(o), r(e, n), null, e.attrs);
  }
  static renderSpec(e, n, o = null, r) {
    return Ac(e, n, o, r);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Nr(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = C0(e.nodes);
    return n.text || (n.text = (o) => o.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return C0(e.marks);
  }
}
function C0(t) {
  let e = {};
  for (let n in t) {
    let o = t[n].spec.toDOM;
    o && (e[n] = o);
  }
  return e;
}
function af(t) {
  return t.document || window.document;
}
const S0 = /* @__PURE__ */ new WeakMap();
function O8(t) {
  let e = S0.get(t);
  return e === void 0 && S0.set(t, e = I8(t)), e;
}
function I8(t) {
  let e = null;
  function n(o) {
    if (o && typeof o == "object")
      if (Array.isArray(o))
        if (typeof o[0] == "string")
          e || (e = []), e.push(o);
        else
          for (let r = 0; r < o.length; r++)
            n(o[r]);
      else
        for (let r in o)
          n(o[r]);
  }
  return n(t), e;
}
function Ac(t, e, n, o) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let r = e[0], i;
  if (typeof r != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (o && (i = O8(o)) && i.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = r.indexOf(" ");
  s > 0 && (n = r.slice(0, s), r = r.slice(s + 1));
  let a, l = n ? t.createElementNS(n, r) : t.createElement(r), c = e[1], d = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    d = 2;
    for (let u in c)
      if (c[u] != null) {
        let f = u.indexOf(" ");
        f > 0 ? l.setAttributeNS(u.slice(0, f), u.slice(f + 1), c[u]) : l.setAttribute(u, c[u]);
      }
  }
  for (let u = d; u < e.length; u++) {
    let f = e[u];
    if (f === 0) {
      if (u < e.length - 1 || u > d)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: h, contentDOM: m } = Ac(t, f, n, o);
      if (l.appendChild(h), m) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = m;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const Yb = 65535, Xb = Math.pow(2, 16);
function D8(t, e) {
  return t + e * Xb;
}
function A0(t) {
  return t & Yb;
}
function R8(t) {
  return (t - (t & Yb)) / Xb;
}
const Zb = 1, Qb = 2, Ec = 4, ew = 8;
class Ep {
  /**
  @internal
  */
  constructor(e, n, o) {
    this.pos = e, this.delInfo = n, this.recover = o;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & ew) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (Zb | Ec)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (Qb | Ec)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Ec) > 0;
  }
}
class sn {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && sn.empty)
      return sn.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, o = A0(e);
    if (!this.inverted)
      for (let r = 0; r < o; r++)
        n += this.ranges[r * 3 + 2] - this.ranges[r * 3 + 1];
    return this.ranges[o * 3] + n + R8(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, o) {
    let r = 0, i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + i], d = this.ranges[a + s], u = l + c;
      if (e <= u) {
        let f = c ? e == l ? -1 : e == u ? 1 : n : n, h = l + r + (f < 0 ? 0 : d);
        if (o)
          return h;
        let m = e == (n < 0 ? l : u) ? null : D8(a / 3, e - l), g = e == l ? Qb : e == u ? Zb : Ec;
        return (n < 0 ? e != l : e != u) && (g |= ew), new Ep(h, g, m);
      }
      r += d - c;
    }
    return o ? e + r : new Ep(e + r, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let o = 0, r = A0(n), i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? o : 0);
      if (l > e)
        break;
      let c = this.ranges[a + i], d = l + c;
      if (e <= d && a == r * 3)
        return !0;
      o += this.ranges[a + s] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let r = 0, i = 0; r < this.ranges.length; r += 3) {
      let s = this.ranges[r], a = s - (this.inverted ? i : 0), l = s + (this.inverted ? 0 : i), c = this.ranges[r + n], d = this.ranges[r + o];
      e(a, a + c, l, l + d), i += d - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new sn(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? sn.empty : new sn(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
sn.empty = new sn([]);
class Xi {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, o = 0, r = e.length) {
    this.maps = e, this.mirror = n, this.from = o, this.to = r;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new Xi(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new Xi(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.to = this.maps.push(e), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, o = this.maps.length; n < e.maps.length; n++) {
      let r = e.getMirror(n);
      this.appendMap(e.maps[n], r != null && r < n ? o + r : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, o = this.maps.length + e.maps.length; n >= 0; n--) {
      let r = e.getMirror(n);
      this.appendMap(e.maps[n].invert(), r != null && r > n ? o - r - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Xi();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let o = this.from; o < this.to; o++)
      e = this.maps[o].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, o) {
    let r = 0;
    for (let i = this.from; i < this.to; i++) {
      let s = this.maps[i], a = s.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(i);
        if (l != null && l > i && l < this.to) {
          i = l, e = this.maps[l].recover(a.recover);
          continue;
        }
      }
      r |= a.delInfo, e = a.pos;
    }
    return o ? e : new Ep(e, r, null);
  }
}
const lf = /* @__PURE__ */ Object.create(null);
class zt {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return sn.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let o = lf[n.stepType];
    if (!o)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return o.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in lf)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return lf[e] = n, n.prototype.jsonID = e, n;
  }
}
class vt {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new vt(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new vt(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, o, r) {
    try {
      return vt.ok(e.replace(n, o, r));
    } catch (i) {
      if (i instanceof Uc)
        return vt.fail(i.message);
      throw i;
    }
  }
}
function sm(t, e, n) {
  let o = [];
  for (let r = 0; r < t.childCount; r++) {
    let i = t.child(r);
    i.content.size && (i = i.copy(sm(i.content, e, i))), i.isInline && (i = e(i, n, r)), o.push(i);
  }
  return W.fromArray(o);
}
class mr extends zt {
  /**
  Create a mark step.
  */
  constructor(e, n, o) {
    super(), this.from = e, this.to = n, this.mark = o;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), o = e.resolve(this.from), r = o.node(o.sharedDepth(this.to)), i = new ee(sm(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), r), n.openStart, n.openEnd);
    return vt.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new Yn(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
    return n.deleted && o.deleted || n.pos >= o.pos ? null : new mr(n.pos, o.pos, this.mark);
  }
  merge(e) {
    return e instanceof mr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new mr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new mr(n.from, n.to, e.markFromJSON(n.mark));
  }
}
zt.jsonID("addMark", mr);
class Yn extends zt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, o) {
    super(), this.from = e, this.to = n, this.mark = o;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), o = new ee(sm(n.content, (r) => r.mark(this.mark.removeFromSet(r.marks)), e), n.openStart, n.openEnd);
    return vt.fromReplace(e, this.from, this.to, o);
  }
  invert() {
    return new mr(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
    return n.deleted && o.deleted || n.pos >= o.pos ? null : new Yn(n.pos, o.pos, this.mark);
  }
  merge(e) {
    return e instanceof Yn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Yn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Yn(n.from, n.to, e.markFromJSON(n.mark));
  }
}
zt.jsonID("removeMark", Yn);
class gr extends zt {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return vt.fail("No node at mark step's position");
    let o = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return vt.fromReplace(e, this.pos, this.pos + 1, new ee(W.from(o), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let o = this.mark.addToSet(n.marks);
      if (o.length == n.marks.length) {
        for (let r = 0; r < n.marks.length; r++)
          if (!n.marks[r].isInSet(o))
            return new gr(this.pos, n.marks[r]);
        return new gr(this.pos, this.mark);
      }
    }
    return new is(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new gr(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new gr(n.pos, e.markFromJSON(n.mark));
  }
}
zt.jsonID("addNodeMark", gr);
class is extends zt {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return vt.fail("No node at mark step's position");
    let o = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return vt.fromReplace(e, this.pos, this.pos + 1, new ee(W.from(o), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new gr(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new is(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new is(n.pos, e.markFromJSON(n.mark));
  }
}
zt.jsonID("removeNodeMark", is);
class xt extends zt {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, o, r = !1) {
    super(), this.from = e, this.to = n, this.slice = o, this.structure = r;
  }
  apply(e) {
    return this.structure && _p(e, this.from, this.to) ? vt.fail("Structure replace would overwrite content") : vt.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new sn([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new xt(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1);
    return n.deletedAcross && o.deletedAcross ? null : new xt(n.pos, Math.max(n.pos, o.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof xt) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? ee.empty : new ee(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new xt(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? ee.empty : new ee(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new xt(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new xt(n.from, n.to, ee.fromJSON(e, n.slice), !!n.structure);
  }
}
zt.jsonID("replace", xt);
class kt extends zt {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, o, r, i, s, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = o, this.gapTo = r, this.slice = i, this.insert = s, this.structure = a;
  }
  apply(e) {
    if (this.structure && (_p(e, this.from, this.gapFrom) || _p(e, this.gapTo, this.to)))
      return vt.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return vt.fail("Gap is not a flat range");
    let o = this.slice.insertAt(this.insert, n.content);
    return o ? vt.fromReplace(e, this.from, this.to, o) : vt.fail("Content does not fit in gap");
  }
  getMap() {
    return new sn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new kt(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), o = e.mapResult(this.to, -1), r = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), i = this.to == this.gapTo ? o.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && o.deletedAcross || r < n.pos || i > o.pos ? null : new kt(n.pos, o.pos, r, i, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new kt(n.from, n.to, n.gapFrom, n.gapTo, ee.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
zt.jsonID("replaceAround", kt);
function _p(t, e, n) {
  let o = t.resolve(e), r = n - e, i = o.depth;
  for (; r > 0 && i > 0 && o.indexAfter(i) == o.node(i).childCount; )
    i--, r--;
  if (r > 0) {
    let s = o.node(i).maybeChild(o.indexAfter(i));
    for (; r > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, r--;
    }
  }
  return !1;
}
function P8(t, e, n, o) {
  let r = [], i = [], s, a;
  t.doc.nodesBetween(e, n, (l, c, d) => {
    if (!l.isInline)
      return;
    let u = l.marks;
    if (!o.isInSet(u) && d.type.allowsMarkType(o.type)) {
      let f = Math.max(c, e), h = Math.min(c + l.nodeSize, n), m = o.addToSet(u);
      for (let g = 0; g < u.length; g++)
        u[g].isInSet(m) || (s && s.to == f && s.mark.eq(u[g]) ? s.to = h : r.push(s = new Yn(f, h, u[g])));
      a && a.to == f ? a.to = h : i.push(a = new mr(f, h, o));
    }
  }), r.forEach((l) => t.step(l)), i.forEach((l) => t.step(l));
}
function L8(t, e, n, o) {
  let r = [], i = 0;
  t.doc.nodesBetween(e, n, (s, a) => {
    if (!s.isInline)
      return;
    i++;
    let l = null;
    if (o instanceof Zd) {
      let c = s.marks, d;
      for (; d = o.isInSet(c); )
        (l || (l = [])).push(d), c = d.removeFromSet(c);
    } else
      o ? o.isInSet(s.marks) && (l = [o]) : l = s.marks;
    if (l && l.length) {
      let c = Math.min(a + s.nodeSize, n);
      for (let d = 0; d < l.length; d++) {
        let u = l[d], f;
        for (let h = 0; h < r.length; h++) {
          let m = r[h];
          m.step == i - 1 && u.eq(r[h].style) && (f = m);
        }
        f ? (f.to = c, f.step = i) : r.push({ style: u, from: Math.max(a, e), to: c, step: i });
      }
    }
  }), r.forEach((s) => t.step(new Yn(s.from, s.to, s.style)));
}
function am(t, e, n, o = n.contentMatch, r = !0) {
  let i = t.doc.nodeAt(e), s = [], a = e + 1;
  for (let l = 0; l < i.childCount; l++) {
    let c = i.child(l), d = a + c.nodeSize, u = o.matchType(c.type);
    if (!u)
      s.push(new xt(a, d, ee.empty));
    else {
      o = u;
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || t.step(new Yn(a, d, c.marks[f]));
      if (r && c.isText && n.whitespace != "pre") {
        let f, h = /\r?\n|\r/g, m;
        for (; f = h.exec(c.text); )
          m || (m = new ee(W.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), s.push(new xt(a + f.index, a + f.index + f[0].length, m));
      }
    }
    a = d;
  }
  if (!o.validEnd) {
    let l = o.fillBefore(W.empty, !0);
    t.replace(a, a, new ee(l, 0, 0));
  }
  for (let l = s.length - 1; l >= 0; l--)
    t.step(s[l]);
}
function N8(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function Ss(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let o = t.depth; ; --o) {
    let r = t.$from.node(o), i = t.$from.index(o), s = t.$to.indexAfter(o);
    if (o < t.depth && r.canReplace(i, s, n))
      return o;
    if (o == 0 || r.type.spec.isolating || !N8(r, i, s))
      break;
  }
  return null;
}
function B8(t, e, n) {
  let { $from: o, $to: r, depth: i } = e, s = o.before(i + 1), a = r.after(i + 1), l = s, c = a, d = W.empty, u = 0;
  for (let m = i, g = !1; m > n; m--)
    g || o.index(m) > 0 ? (g = !0, d = W.from(o.node(m).copy(d)), u++) : l--;
  let f = W.empty, h = 0;
  for (let m = i, g = !1; m > n; m--)
    g || r.after(m + 1) < r.end(m) ? (g = !0, f = W.from(r.node(m).copy(f)), h++) : c++;
  t.step(new kt(l, c, s, a, new ee(d.append(f), u, h), d.size - u, !0));
}
function lm(t, e, n = null, o = t) {
  let r = $8(t, e), i = r && z8(o, e);
  return i ? r.map(E0).concat({ type: e, attrs: n }).concat(i.map(E0)) : null;
}
function E0(t) {
  return { type: t, attrs: null };
}
function $8(t, e) {
  let { parent: n, startIndex: o, endIndex: r } = t, i = n.contentMatchAt(o).findWrapping(e);
  if (!i)
    return null;
  let s = i.length ? i[0] : e;
  return n.canReplaceWith(o, r, s) ? i : null;
}
function z8(t, e) {
  let { parent: n, startIndex: o, endIndex: r } = t, i = n.child(o), s = e.contentMatch.findWrapping(i.type);
  if (!s)
    return null;
  let l = (s.length ? s[s.length - 1] : e).contentMatch;
  for (let c = o; l && c < r; c++)
    l = l.matchType(n.child(c).type);
  return !l || !l.validEnd ? null : s;
}
function F8(t, e, n) {
  let o = W.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (o.size) {
      let a = n[s].type.contentMatch.matchFragment(o);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    o = W.from(n[s].type.create(n[s].attrs, o));
  }
  let r = e.start, i = e.end;
  t.step(new kt(r, i, r, i, new ee(o, 0, 0), n.length, !0));
}
function H8(t, e, n, o, r) {
  if (!o.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let i = t.steps.length;
  t.doc.nodesBetween(e, n, (s, a) => {
    let l = typeof r == "function" ? r(s) : r;
    if (s.isTextblock && !s.hasMarkup(o, l) && V8(t.doc, t.mapping.slice(i).map(a), o)) {
      let c = null;
      if (o.schema.linebreakReplacement) {
        let h = o.whitespace == "pre", m = !!o.contentMatch.matchType(o.schema.linebreakReplacement);
        h && !m ? c = !1 : !h && m && (c = !0);
      }
      c === !1 && nw(t, s, a, i), am(t, t.mapping.slice(i).map(a, 1), o, void 0, c === null);
      let d = t.mapping.slice(i), u = d.map(a, 1), f = d.map(a + s.nodeSize, 1);
      return t.step(new kt(u, f, u + 1, f - 1, new ee(W.from(o.create(l, null, s.marks)), 0, 0), 1, !0)), c === !0 && tw(t, s, a, i), !1;
    }
  });
}
function tw(t, e, n, o) {
  e.forEach((r, i) => {
    if (r.isText) {
      let s, a = /\r?\n|\r/g;
      for (; s = a.exec(r.text); ) {
        let l = t.mapping.slice(o).map(n + 1 + i + s.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function nw(t, e, n, o) {
  e.forEach((r, i) => {
    if (r.type == r.type.schema.linebreakReplacement) {
      let s = t.mapping.slice(o).map(n + 1 + i);
      t.replaceWith(s, s + 1, e.type.schema.text(`
`));
    }
  });
}
function V8(t, e, n) {
  let o = t.resolve(e), r = o.index();
  return o.parent.canReplaceWith(r, r + 1, n);
}
function j8(t, e, n, o, r) {
  let i = t.doc.nodeAt(e);
  if (!i)
    throw new RangeError("No node at given position");
  n || (n = i.type);
  let s = n.create(o, null, r || i.marks);
  if (i.isLeaf)
    return t.replaceWith(e, e + i.nodeSize, s);
  if (!n.validContent(i.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new kt(e, e + i.nodeSize, e + 1, e + i.nodeSize - 1, new ee(W.from(s), 0, 0), 1, !0));
}
function Zi(t, e, n = 1, o) {
  let r = t.resolve(e), i = r.depth - n, s = o && o[o.length - 1] || r.parent;
  if (i < 0 || r.parent.type.spec.isolating || !r.parent.canReplace(r.index(), r.parent.childCount) || !s.type.validContent(r.parent.content.cutByIndex(r.index(), r.parent.childCount)))
    return !1;
  for (let c = r.depth - 1, d = n - 2; c > i; c--, d--) {
    let u = r.node(c), f = r.index(c);
    if (u.type.spec.isolating)
      return !1;
    let h = u.content.cutByIndex(f, u.childCount), m = o && o[d + 1];
    m && (h = h.replaceChild(0, m.type.create(m.attrs)));
    let g = o && o[d] || u;
    if (!u.canReplace(f + 1, u.childCount) || !g.type.validContent(h))
      return !1;
  }
  let a = r.indexAfter(i), l = o && o[0];
  return r.node(i).canReplaceWith(a, a, l ? l.type : r.node(i + 1).type);
}
function U8(t, e, n = 1, o) {
  let r = t.doc.resolve(e), i = W.empty, s = W.empty;
  for (let a = r.depth, l = r.depth - n, c = n - 1; a > l; a--, c--) {
    i = W.from(r.node(a).copy(i));
    let d = o && o[c];
    s = W.from(d ? d.type.create(d.attrs, s) : r.node(a).copy(s));
  }
  t.step(new xt(e, e, new ee(i.append(s), n, n), !0));
}
function Br(t, e) {
  let n = t.resolve(e), o = n.index();
  return ow(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(o, o + 1);
}
function W8(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: o } = t.type.schema;
  for (let r = 0; r < e.childCount; r++) {
    let i = e.child(r), s = i.type == o ? t.type.schema.nodes.text : i.type;
    if (n = n.matchType(s), !n || !t.type.allowsMarks(i.marks))
      return !1;
  }
  return n.validEnd;
}
function ow(t, e) {
  return !!(t && e && !t.isLeaf && W8(t, e));
}
function Qd(t, e, n = -1) {
  let o = t.resolve(e);
  for (let r = o.depth; ; r--) {
    let i, s, a = o.index(r);
    if (r == o.depth ? (i = o.nodeBefore, s = o.nodeAfter) : n > 0 ? (i = o.node(r + 1), a++, s = o.node(r).maybeChild(a)) : (i = o.node(r).maybeChild(a - 1), s = o.node(r + 1)), i && !i.isTextblock && ow(i, s) && o.node(r).canReplace(a, a + 1))
      return e;
    if (r == 0)
      break;
    e = n < 0 ? o.before(r) : o.after(r);
  }
}
function K8(t, e, n) {
  let o = null, { linebreakReplacement: r } = t.doc.type.schema, i = t.doc.resolve(e - n), s = i.node().type;
  if (r && s.inlineContent) {
    let d = s.whitespace == "pre", u = !!s.contentMatch.matchType(r);
    d && !u ? o = !1 : !d && u && (o = !0);
  }
  let a = t.steps.length;
  if (o === !1) {
    let d = t.doc.resolve(e + n);
    nw(t, d.node(), d.before(), a);
  }
  s.inlineContent && am(t, e + n - 1, s, i.node().contentMatchAt(i.index()), o == null);
  let l = t.mapping.slice(a), c = l.map(e - n);
  if (t.step(new xt(c, l.map(e + n, -1), ee.empty, !0)), o === !0) {
    let d = t.doc.resolve(c);
    tw(t, d.node(), d.before(), t.steps.length);
  }
  return t;
}
function q8(t, e, n) {
  let o = t.resolve(e);
  if (o.parent.canReplaceWith(o.index(), o.index(), n))
    return e;
  if (o.parentOffset == 0)
    for (let r = o.depth - 1; r >= 0; r--) {
      let i = o.index(r);
      if (o.node(r).canReplaceWith(i, i, n))
        return o.before(r + 1);
      if (i > 0)
        return null;
    }
  if (o.parentOffset == o.parent.content.size)
    for (let r = o.depth - 1; r >= 0; r--) {
      let i = o.indexAfter(r);
      if (o.node(r).canReplaceWith(i, i, n))
        return o.after(r + 1);
      if (i < o.node(r).childCount)
        return null;
    }
  return null;
}
function rw(t, e, n) {
  let o = t.resolve(e);
  if (!n.content.size)
    return e;
  let r = n.content;
  for (let i = 0; i < n.openStart; i++)
    r = r.firstChild.content;
  for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
    for (let s = o.depth; s >= 0; s--) {
      let a = s == o.depth ? 0 : o.pos <= (o.start(s + 1) + o.end(s + 1)) / 2 ? -1 : 1, l = o.index(s) + (a > 0 ? 1 : 0), c = o.node(s), d = !1;
      if (i == 1)
        d = c.canReplace(l, l, r);
      else {
        let u = c.contentMatchAt(l).findWrapping(r.firstChild.type);
        d = u && c.canReplaceWith(l, l, u[0]);
      }
      if (d)
        return a == 0 ? o.pos : a < 0 ? o.before(s + 1) : o.after(s + 1);
    }
  return null;
}
function eu(t, e, n = e, o = ee.empty) {
  if (e == n && !o.size)
    return null;
  let r = t.resolve(e), i = t.resolve(n);
  return iw(r, i, o) ? new xt(e, n, o) : new G8(r, i, o).fit();
}
function iw(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class G8 {
  constructor(e, n, o) {
    this.$from = e, this.$to = n, this.unplaced = o, this.frontier = [], this.placed = W.empty;
    for (let r = 0; r <= e.depth; r++) {
      let i = e.node(r);
      this.frontier.push({
        type: i.type,
        match: i.contentMatchAt(e.indexAfter(r))
      });
    }
    for (let r = e.depth; r > 0; r--)
      this.placed = W.from(e.node(r).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, o = this.$from, r = this.close(e < 0 ? this.$to : o.doc.resolve(e));
    if (!r)
      return null;
    let i = this.placed, s = o.depth, a = r.depth;
    for (; s && a && i.childCount == 1; )
      i = i.firstChild.content, s--, a--;
    let l = new ee(i, s, a);
    return e > -1 ? new kt(o.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || o.pos != this.$to.pos ? new xt(o.pos, r.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, o = 0, r = this.unplaced.openEnd; o < e; o++) {
      let i = n.firstChild;
      if (n.childCount > 1 && (r = 0), i.type.spec.isolating && r <= o) {
        e = o;
        break;
      }
      n = i.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let o = n == 1 ? e : this.unplaced.openStart; o >= 0; o--) {
        let r, i = null;
        o ? (i = cf(this.unplaced.content, o - 1).firstChild, r = i.content) : r = this.unplaced.content;
        let s = r.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], d, u = null;
          if (n == 1 && (s ? c.matchType(s.type) || (u = c.fillBefore(W.from(s), !1)) : i && l.compatibleContent(i.type)))
            return { sliceDepth: o, frontierDepth: a, parent: i, inject: u };
          if (n == 2 && s && (d = c.findWrapping(s.type)))
            return { sliceDepth: o, frontierDepth: a, parent: i, wrap: d };
          if (i && c.matchType(i.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: o } = this.unplaced, r = cf(e, n);
    return !r.childCount || r.firstChild.isLeaf ? !1 : (this.unplaced = new ee(e, n + 1, Math.max(o, r.size + n >= e.size - o ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: o } = this.unplaced, r = cf(e, n);
    if (r.childCount <= 1 && n > 0) {
      let i = e.size - n <= n + r.size;
      this.unplaced = new ee(ta(e, n - 1, 1), n - 1, i ? n - 1 : o);
    } else
      this.unplaced = new ee(ta(e, n, 1), n, o);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: o, inject: r, wrap: i }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (i)
      for (let g = 0; g < i.length; g++)
        this.openFrontierNode(i[g]);
    let s = this.unplaced, a = o ? o.content : s.content, l = s.openStart - e, c = 0, d = [], { match: u, type: f } = this.frontier[n];
    if (r) {
      for (let g = 0; g < r.childCount; g++)
        d.push(r.child(g));
      u = u.matchFragment(r);
    }
    let h = a.size + e - (s.content.size - s.openEnd);
    for (; c < a.childCount; ) {
      let g = a.child(c), v = u.matchType(g.type);
      if (!v)
        break;
      c++, (c > 1 || l == 0 || g.content.size) && (u = v, d.push(sw(g.mark(f.allowedMarks(g.marks)), c == 1 ? l : 0, c == a.childCount ? h : -1)));
    }
    let m = c == a.childCount;
    m || (h = -1), this.placed = na(this.placed, n, W.from(d)), this.frontier[n].match = u, m && h < 0 && o && o.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let g = 0, v = a; g < h; g++) {
      let y = v.lastChild;
      this.frontier.push({ type: y.type, match: y.contentMatchAt(y.childCount) }), v = y.content;
    }
    this.unplaced = m ? e == 0 ? ee.empty : new ee(ta(s.content, e - 1, 1), e - 1, h < 0 ? s.openEnd : e - 1) : new ee(ta(s.content, e, c), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !df(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: o } = this.$to, r = this.$to.after(o);
    for (; o > 1 && r == this.$to.end(--o); )
      ++r;
    return r;
  }
  findCloseLevel(e) {
    e:
      for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
        let { match: o, type: r } = this.frontier[n], i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), s = df(e, n, r, o, i);
        if (s) {
          for (let a = n - 1; a >= 0; a--) {
            let { match: l, type: c } = this.frontier[a], d = df(e, a, c, l, !0);
            if (!d || d.childCount)
              continue e;
          }
          return { depth: n, fit: s, move: i ? e.doc.resolve(e.after(n + 1)) : e };
        }
      }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = na(this.placed, n.depth, n.fit)), e = n.move;
    for (let o = n.depth + 1; o <= e.depth; o++) {
      let r = e.node(o), i = r.type.contentMatch.fillBefore(r.content, !0, e.index(o));
      this.openFrontierNode(r.type, r.attrs, i);
    }
    return e;
  }
  openFrontierNode(e, n = null, o) {
    let r = this.frontier[this.depth];
    r.match = r.match.matchType(e), this.placed = na(this.placed, this.depth, W.from(e.create(n, o))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(W.empty, !0);
    n.childCount && (this.placed = na(this.placed, this.frontier.length, n));
  }
}
function ta(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(ta(t.firstChild.content, e - 1, n)));
}
function na(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(na(t.lastChild.content, e - 1, n)));
}
function cf(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function sw(t, e, n) {
  if (e <= 0)
    return t;
  let o = t.content;
  return e > 1 && (o = o.replaceChild(0, sw(o.firstChild, e - 1, o.childCount == 1 ? n - 1 : 0))), e > 0 && (o = t.type.contentMatch.fillBefore(o).append(o), n <= 0 && (o = o.append(t.type.contentMatch.matchFragment(o).fillBefore(W.empty, !0)))), t.copy(o);
}
function df(t, e, n, o, r) {
  let i = t.node(e), s = r ? t.indexAfter(e) : t.index(e);
  if (s == i.childCount && !n.compatibleContent(i.type))
    return null;
  let a = o.fillBefore(i.content, !0, s);
  return a && !J8(n, i.content, s) ? a : null;
}
function J8(t, e, n) {
  for (let o = n; o < e.childCount; o++)
    if (!t.allowsMarks(e.child(o).marks))
      return !0;
  return !1;
}
function Y8(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function X8(t, e, n, o) {
  if (!o.size)
    return t.deleteRange(e, n);
  let r = t.doc.resolve(e), i = t.doc.resolve(n);
  if (iw(r, i, o))
    return t.step(new xt(e, n, o));
  let s = lw(r, t.doc.resolve(n));
  s[s.length - 1] == 0 && s.pop();
  let a = -(r.depth + 1);
  s.unshift(a);
  for (let f = r.depth, h = r.pos - 1; f > 0; f--, h--) {
    let m = r.node(f).type.spec;
    if (m.defining || m.definingAsContext || m.isolating)
      break;
    s.indexOf(f) > -1 ? a = f : r.before(f) == h && s.splice(1, 0, -f);
  }
  let l = s.indexOf(a), c = [], d = o.openStart;
  for (let f = o.content, h = 0; ; h++) {
    let m = f.firstChild;
    if (c.push(m), h == o.openStart)
      break;
    f = m.content;
  }
  for (let f = d - 1; f >= 0; f--) {
    let h = c[f], m = Y8(h.type);
    if (m && !h.sameMarkup(r.node(Math.abs(a) - 1)))
      d = f;
    else if (m || !h.type.isTextblock)
      break;
  }
  for (let f = o.openStart; f >= 0; f--) {
    let h = (f + d + 1) % (o.openStart + 1), m = c[h];
    if (m)
      for (let g = 0; g < s.length; g++) {
        let v = s[(g + l) % s.length], y = !0;
        v < 0 && (y = !1, v = -v);
        let x = r.node(v - 1), C = r.index(v - 1);
        if (x.canReplaceWith(C, C, m.type, m.marks))
          return t.replace(r.before(v), y ? i.after(v) : n, new ee(aw(o.content, 0, o.openStart, h), h, o.openEnd));
      }
  }
  let u = t.steps.length;
  for (let f = s.length - 1; f >= 0 && (t.replace(e, n, o), !(t.steps.length > u)); f--) {
    let h = s[f];
    h < 0 || (e = r.before(h), n = i.after(h));
  }
}
function aw(t, e, n, o, r) {
  if (e < n) {
    let i = t.firstChild;
    t = t.replaceChild(0, i.copy(aw(i.content, e + 1, n, o, i)));
  }
  if (e > o) {
    let i = r.contentMatchAt(0), s = i.fillBefore(t).append(t);
    t = s.append(i.matchFragment(s).fillBefore(W.empty, !0));
  }
  return t;
}
function Z8(t, e, n, o) {
  if (!o.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let r = q8(t.doc, e, o.type);
    r != null && (e = n = r);
  }
  t.replaceRange(e, n, new ee(W.from(o), 0, 0));
}
function Q8(t, e, n) {
  let o = t.doc.resolve(e), r = t.doc.resolve(n), i = lw(o, r);
  for (let s = 0; s < i.length; s++) {
    let a = i[s], l = s == i.length - 1;
    if (l && a == 0 || o.node(a).type.contentMatch.validEnd)
      return t.delete(o.start(a), r.end(a));
    if (a > 0 && (l || o.node(a - 1).canReplace(o.index(a - 1), r.indexAfter(a - 1))))
      return t.delete(o.before(a), r.after(a));
  }
  for (let s = 1; s <= o.depth && s <= r.depth; s++)
    if (e - o.start(s) == o.depth - s && n > o.end(s) && r.end(s) - n != r.depth - s && o.start(s - 1) == r.start(s - 1) && o.node(s - 1).canReplace(o.index(s - 1), r.index(s - 1)))
      return t.delete(o.before(s), n);
  t.delete(e, n);
}
function lw(t, e) {
  let n = [], o = Math.min(t.depth, e.depth);
  for (let r = o; r >= 0; r--) {
    let i = t.start(r);
    if (i < t.pos - (t.depth - r) || e.end(r) > e.pos + (e.depth - r) || t.node(r).type.spec.isolating || e.node(r).type.spec.isolating)
      break;
    (i == e.start(r) || r == t.depth && r == e.depth && t.parent.inlineContent && e.parent.inlineContent && r && e.start(r - 1) == i - 1) && n.push(r);
  }
  return n;
}
class Qi extends zt {
  /**
  Construct an attribute step.
  */
  constructor(e, n, o) {
    super(), this.pos = e, this.attr = n, this.value = o;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return vt.fail("No node at attribute step's position");
    let o = /* @__PURE__ */ Object.create(null);
    for (let i in n.attrs)
      o[i] = n.attrs[i];
    o[this.attr] = this.value;
    let r = n.type.create(o, null, n.marks);
    return vt.fromReplace(e, this.pos, this.pos + 1, new ee(W.from(r), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return sn.empty;
  }
  invert(e) {
    return new Qi(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Qi(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Qi(n.pos, n.attr, n.value);
  }
}
zt.jsonID("attr", Qi);
class Da extends zt {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in e.attrs)
      n[r] = e.attrs[r];
    n[this.attr] = this.value;
    let o = e.type.create(n, e.content, e.marks);
    return vt.ok(o);
  }
  getMap() {
    return sn.empty;
  }
  invert(e) {
    return new Da(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Da(n.attr, n.value);
  }
}
zt.jsonID("docAttr", Da);
let ss = class extends Error {
};
ss = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
ss.prototype = Object.create(Error.prototype);
ss.prototype.constructor = ss;
ss.prototype.name = "TransformError";
class cm {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Xi();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new ss(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, o = ee.empty) {
    let r = eu(this.doc, e, n, o);
    return r && this.step(r), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, o) {
    return this.replace(e, n, new ee(W.from(o), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, ee.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, o) {
    return X8(this, e, n, o), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, o) {
    return Z8(this, e, n, o), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return Q8(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return B8(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return K8(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return F8(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, o, r = null) {
    return H8(this, e, n, o, r), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, o = null, r) {
    return j8(this, e, n, o, r), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, o) {
    return this.step(new Qi(e, n, o)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new Da(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new gr(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof Xe)) {
      let o = this.doc.nodeAt(e);
      if (!o)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(o.marks), !n)
        return this;
    }
    return this.step(new is(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, o) {
    return U8(this, e, n, o), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, o) {
    return P8(this, e, n, o), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, o) {
    return L8(this, e, n, o), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, o) {
    return am(this, e, n, o), this;
  }
}
const uf = /* @__PURE__ */ Object.create(null);
let pe = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, o) {
    this.$anchor = e, this.$head = n, this.ranges = o || [new dm(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = ee.empty) {
    let o = n.content.lastChild, r = null;
    for (let a = 0; a < n.openEnd; a++)
      r = o, o = o.lastChild;
    let i = e.steps.length, s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: l, $to: c } = s[a], d = e.mapping.slice(i);
      e.replaceRange(d.map(l.pos), d.map(c.pos), a ? ee.empty : n), a == 0 && T0(e, i, (o ? o.isInline : r && r.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let o = e.steps.length, r = this.ranges;
    for (let i = 0; i < r.length; i++) {
      let { $from: s, $to: a } = r[i], l = e.mapping.slice(o), c = l.map(s.pos), d = l.map(a.pos);
      i ? e.deleteRange(c, d) : (e.replaceRangeWith(c, d, n), T0(e, o, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, o = !1) {
    let r = e.parent.inlineContent ? new le(e) : Vi(e.node(0), e.parent, e.pos, e.index(), n, o);
    if (r)
      return r;
    for (let i = e.depth - 1; i >= 0; i--) {
      let s = n < 0 ? Vi(e.node(0), e.node(i), e.before(i + 1), e.index(i), n, o) : Vi(e.node(0), e.node(i), e.after(i + 1), e.index(i) + 1, n, o);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new Jt(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Vi(e, e, 0, 0, 1) || new Jt(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Vi(e, e, e.content.size, e.childCount, -1) || new Jt(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let o = uf[n.type];
    if (!o)
      throw new RangeError(`No selection type ${n.type} defined`);
    return o.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in uf)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return uf[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return le.between(this.$anchor, this.$head).getBookmark();
  }
};
pe.prototype.visible = !0;
class dm {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let _0 = !1;
function M0(t) {
  !_0 && !t.parent.inlineContent && (_0 = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class le extends pe {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    M0(e), M0(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let o = e.resolve(n.map(this.head));
    if (!o.parent.inlineContent)
      return pe.near(o);
    let r = e.resolve(n.map(this.anchor));
    return new le(r.parent.inlineContent ? r : o, o);
  }
  replace(e, n = ee.empty) {
    if (super.replace(e, n), n == ee.empty) {
      let o = this.$from.marksAcross(this.$to);
      o && e.ensureMarks(o);
    }
  }
  eq(e) {
    return e instanceof le && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new tu(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new le(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, o = n) {
    let r = e.resolve(n);
    return new this(r, o == n ? r : e.resolve(o));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, o) {
    let r = e.pos - n.pos;
    if ((!o || r) && (o = r >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let i = pe.findFrom(n, o, !0) || pe.findFrom(n, -o, !0);
      if (i)
        n = i.$head;
      else
        return pe.near(n, o);
    }
    return e.parent.inlineContent || (r == 0 ? e = n : (e = (pe.findFrom(e, -o, !0) || pe.findFrom(e, o, !0)).$anchor, e.pos < n.pos != r < 0 && (e = n))), new le(e, n);
  }
}
pe.jsonID("text", le);
class tu {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new tu(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return le.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class de extends pe {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, o = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, o), this.node = n;
  }
  map(e, n) {
    let { deleted: o, pos: r } = n.mapResult(this.anchor), i = e.resolve(r);
    return o ? pe.near(i) : new de(i);
  }
  content() {
    return new ee(W.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof de && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new um(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new de(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new de(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
de.prototype.visible = !1;
pe.jsonID("node", de);
class um {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: o } = e.mapResult(this.anchor);
    return n ? new tu(o, o) : new um(o);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), o = n.nodeAfter;
    return o && de.isSelectable(o) ? new de(n) : pe.near(n);
  }
}
class Jt extends pe {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = ee.empty) {
    if (n == ee.empty) {
      e.delete(0, e.doc.content.size);
      let o = pe.atStart(e.doc);
      o.eq(e.selection) || e.setSelection(o);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Jt(e);
  }
  map(e) {
    return new Jt(e);
  }
  eq(e) {
    return e instanceof Jt;
  }
  getBookmark() {
    return e5;
  }
}
pe.jsonID("all", Jt);
const e5 = {
  map() {
    return this;
  },
  resolve(t) {
    return new Jt(t);
  }
};
function Vi(t, e, n, o, r, i = !1) {
  if (e.inlineContent)
    return le.create(t, n);
  for (let s = o - (r > 0 ? 0 : 1); r > 0 ? s < e.childCount : s >= 0; s += r) {
    let a = e.child(s);
    if (a.isAtom) {
      if (!i && de.isSelectable(a))
        return de.create(t, n - (r < 0 ? a.nodeSize : 0));
    } else {
      let l = Vi(t, a, n + r, r < 0 ? a.childCount : 0, r, i);
      if (l)
        return l;
    }
    n += a.nodeSize * r;
  }
  return null;
}
function T0(t, e, n) {
  let o = t.steps.length - 1;
  if (o < e)
    return;
  let r = t.steps[o];
  if (!(r instanceof xt || r instanceof kt))
    return;
  let i = t.mapping.maps[o], s;
  i.forEach((a, l, c, d) => {
    s == null && (s = d);
  }), t.setSelection(pe.near(t.doc.resolve(s), n));
}
const O0 = 1, zl = 2, I0 = 4;
let t5 = class extends cm {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | O0) & ~zl, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & O0) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= zl, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Xe.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & zl) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~zl, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let o = this.selection;
    return n && (e = e.mark(this.storedMarks || (o.empty ? o.$from.marks() : o.$from.marksAcross(o.$to) || Xe.none))), o.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, o) {
    let r = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(r.text(e), !0) : this.deleteSelection();
    {
      if (o == null && (o = n), o = o ?? n, !e)
        return this.deleteRange(n, o);
      let i = this.storedMarks;
      if (!i) {
        let s = this.doc.resolve(n);
        i = o == n ? s.marks() : s.marksAcross(this.doc.resolve(o));
      }
      return this.replaceRangeWith(n, o, r.text(e, i)), this.selection.empty || this.setSelection(pe.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= I0, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & I0) > 0;
  }
};
function D0(t, e) {
  return !e || !t ? t : t.bind(e);
}
class oa {
  constructor(e, n, o) {
    this.name = e, this.init = D0(n.init, o), this.apply = D0(n.apply, o);
  }
}
const n5 = [
  new oa("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new oa("selection", {
    init(t, e) {
      return t.selection || pe.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new oa("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, o) {
      return o.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new oa("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class ff {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = n5.slice(), n && n.forEach((o) => {
      if (this.pluginsByKey[o.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + o.key + ")");
      this.plugins.push(o), this.pluginsByKey[o.key] = o, o.spec.state && this.fields.push(new oa(o.key, o.spec.state, o));
    });
  }
}
class Gi {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let o = 0; o < this.config.plugins.length; o++)
      if (o != n) {
        let r = this.config.plugins[o];
        if (r.spec.filterTransaction && !r.spec.filterTransaction.call(r, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], o = this.applyInner(e), r = null;
    for (; ; ) {
      let i = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let l = r ? r[s].n : 0, c = r ? r[s].state : this, d = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, o);
          if (d && o.filterTransaction(d, s)) {
            if (d.setMeta("appendedTransaction", e), !r) {
              r = [];
              for (let u = 0; u < this.config.plugins.length; u++)
                r.push(u < s ? { state: o, n: n.length } : { state: this, n: 0 });
            }
            n.push(d), o = o.applyInner(d), i = !0;
          }
          r && (r[s] = { state: o, n: n.length });
        }
      }
      if (!i)
        return { state: o, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Gi(this.config), o = this.config.fields;
    for (let r = 0; r < o.length; r++) {
      let i = o[r];
      n[i.name] = i.apply(e, this[i.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new t5(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new ff(e.doc ? e.doc.type.schema : e.schema, e.plugins), o = new Gi(n);
    for (let r = 0; r < n.fields.length; r++)
      o[n.fields[r].name] = n.fields[r].init(e, o);
    return o;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new ff(this.schema, e.plugins), o = n.fields, r = new Gi(n);
    for (let i = 0; i < o.length; i++) {
      let s = o[i].name;
      r[s] = this.hasOwnProperty(s) ? this[s] : o[i].init(e, r);
    }
    return r;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((o) => o.toJSON())), e && typeof e == "object")
      for (let o in e) {
        if (o == "doc" || o == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let r = e[o], i = r.spec.state;
        i && i.toJSON && (n[o] = i.toJSON.call(r, this[r.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, o) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let r = new ff(e.schema, e.plugins), i = new Gi(r);
    return r.fields.forEach((s) => {
      if (s.name == "doc")
        i.doc = wr.fromJSON(e.schema, n.doc);
      else if (s.name == "selection")
        i.selection = pe.fromJSON(i.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (i.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (o)
          for (let a in o) {
            let l = o[a], c = l.spec.state;
            if (l.key == s.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              i[s.name] = c.fromJSON.call(l, e, n[a], i);
              return;
            }
          }
        i[s.name] = s.init(e, i);
      }
    }), i;
  }
}
function cw(t, e, n) {
  for (let o in t) {
    let r = t[o];
    r instanceof Function ? r = r.bind(e) : o == "handleDOMEvents" && (r = cw(r, e, {})), n[o] = r;
  }
  return n;
}
class Ne {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && cw(e.props, this, this.props), this.key = e.key ? e.key.key : dw("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const pf = /* @__PURE__ */ Object.create(null);
function dw(t) {
  return t in pf ? t + "$" + ++pf[t] : (pf[t] = 0, t + "$");
}
class Be {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = dw(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Ot = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, Ra = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let Mp = null;
const So = function(t, e, n) {
  let o = Mp || (Mp = document.createRange());
  return o.setEnd(t, n ?? t.nodeValue.length), o.setStart(t, e || 0), o;
}, o5 = function() {
  Mp = null;
}, pi = function(t, e, n, o) {
  return n && (R0(t, e, n, o, -1) || R0(t, e, n, o, 1));
}, r5 = /^(img|br|input|textarea|hr)$/i;
function R0(t, e, n, o, r) {
  for (; ; ) {
    if (t == n && e == o)
      return !0;
    if (e == (r < 0 ? 0 : Cn(t))) {
      let i = t.parentNode;
      if (!i || i.nodeType != 1 || vl(t) || r5.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = Ot(t) + (r < 0 ? 0 : 1), t = i;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (r < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = r < 0 ? Cn(t) : 0;
    } else
      return !1;
  }
}
function Cn(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function i5(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = Cn(t);
    } else if (t.parentNode && !vl(t))
      e = Ot(t), t = t.parentNode;
    else
      return null;
  }
}
function s5(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !vl(t))
      e = Ot(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function a5(t, e, n) {
  for (let o = e == 0, r = e == Cn(t); o || r; ) {
    if (t == n)
      return !0;
    let i = Ot(t);
    if (t = t.parentNode, !t)
      return !1;
    o = o && i == 0, r = r && i == Cn(t);
  }
}
function vl(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const nu = function(t) {
  return t.focusNode && pi(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function Xr(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function l5(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function c5(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let o = t.caretPositionFromPoint(e, n);
      if (o)
        return { node: o.offsetNode, offset: Math.min(Cn(o.offsetNode), o.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let o = t.caretRangeFromPoint(e, n);
    if (o)
      return { node: o.startContainer, offset: Math.min(Cn(o.startContainer), o.startOffset) };
  }
}
const oo = typeof navigator < "u" ? navigator : null, P0 = typeof document < "u" ? document : null, $r = oo && oo.userAgent || "", Tp = /Edge\/(\d+)/.exec($r), uw = /MSIE \d/.exec($r), Op = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec($r), Yt = !!(uw || Op || Tp), xr = uw ? document.documentMode : Op ? +Op[1] : Tp ? +Tp[1] : 0, Fn = !Yt && /gecko\/(\d+)/i.test($r);
Fn && +(/Firefox\/(\d+)/.exec($r) || [0, 0])[1];
const Ip = !Yt && /Chrome\/(\d+)/.exec($r), Bt = !!Ip, fw = Ip ? +Ip[1] : 0, Ut = !Yt && !!oo && /Apple Computer/.test(oo.vendor), as = Ut && (/Mobile\/\w+/.test($r) || !!oo && oo.maxTouchPoints > 2), kn = as || (oo ? /Mac/.test(oo.platform) : !1), d5 = oo ? /Win/.test(oo.platform) : !1, Oo = /Android \d/.test($r), yl = !!P0 && "webkitFontSmoothing" in P0.documentElement.style, u5 = yl ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function f5(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function vo(t, e) {
  return typeof t == "number" ? t : t[e];
}
function p5(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, o = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * o
  };
}
function L0(t, e, n) {
  let o = t.someProp("scrollThreshold") || 0, r = t.someProp("scrollMargin") || 5, i = t.dom.ownerDocument;
  for (let s = n || t.dom; s; s = Ra(s)) {
    if (s.nodeType != 1)
      continue;
    let a = s, l = a == i.body, c = l ? f5(i) : p5(a), d = 0, u = 0;
    if (e.top < c.top + vo(o, "top") ? u = -(c.top - e.top + vo(r, "top")) : e.bottom > c.bottom - vo(o, "bottom") && (u = e.bottom - e.top > c.bottom - c.top ? e.top + vo(r, "top") - c.top : e.bottom - c.bottom + vo(r, "bottom")), e.left < c.left + vo(o, "left") ? d = -(c.left - e.left + vo(r, "left")) : e.right > c.right - vo(o, "right") && (d = e.right - c.right + vo(r, "right")), d || u)
      if (l)
        i.defaultView.scrollBy(d, u);
      else {
        let f = a.scrollLeft, h = a.scrollTop;
        u && (a.scrollTop += u), d && (a.scrollLeft += d);
        let m = a.scrollLeft - f, g = a.scrollTop - h;
        e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(s).position))
      break;
  }
}
function h5(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), o, r;
  for (let i = (e.left + e.right) / 2, s = n + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
    let a = t.root.elementFromPoint(i, s);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      o = a, r = l.top;
      break;
    }
  }
  return { refDOM: o, refTop: r, stack: pw(t.dom) };
}
function pw(t) {
  let e = [], n = t.ownerDocument;
  for (let o = t; o && (e.push({ dom: o, top: o.scrollTop, left: o.scrollLeft }), t != n); o = Ra(o))
    ;
  return e;
}
function m5({ refDOM: t, refTop: e, stack: n }) {
  let o = t ? t.getBoundingClientRect().top : 0;
  hw(n, o == 0 ? 0 : o - e);
}
function hw(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: o, top: r, left: i } = t[n];
    o.scrollTop != r + e && (o.scrollTop = r + e), o.scrollLeft != i && (o.scrollLeft = i);
  }
}
let Ni = null;
function g5(t) {
  if (t.setActive)
    return t.setActive();
  if (Ni)
    return t.focus(Ni);
  let e = pw(t);
  t.focus(Ni == null ? {
    get preventScroll() {
      return Ni = { preventScroll: !0 }, !0;
    }
  } : void 0), Ni || (Ni = !1, hw(e, 0));
}
function mw(t, e) {
  let n, o = 2e8, r, i = 0, s = e.top, a = e.top, l, c;
  for (let d = t.firstChild, u = 0; d; d = d.nextSibling, u++) {
    let f;
    if (d.nodeType == 1)
      f = d.getClientRects();
    else if (d.nodeType == 3)
      f = So(d).getClientRects();
    else
      continue;
    for (let h = 0; h < f.length; h++) {
      let m = f[h];
      if (m.top <= s && m.bottom >= a) {
        s = Math.max(m.bottom, s), a = Math.min(m.top, a);
        let g = m.left > e.left ? m.left - e.left : m.right < e.left ? e.left - m.right : 0;
        if (g < o) {
          n = d, o = g, r = g && n.nodeType == 3 ? {
            left: m.right < e.left ? m.right : m.left,
            top: e.top
          } : e, d.nodeType == 1 && g && (i = u + (e.left >= (m.left + m.right) / 2 ? 1 : 0));
          continue;
        }
      } else
        m.top > e.top && !l && m.left <= e.left && m.right >= e.left && (l = d, c = { left: Math.max(m.left, Math.min(m.right, e.left)), top: m.top });
      !n && (e.left >= m.right && e.top >= m.top || e.left >= m.left && e.top >= m.bottom) && (i = u + 1);
    }
  }
  return !n && l && (n = l, r = c, o = 0), n && n.nodeType == 3 ? v5(n, r) : !n || o && n.nodeType == 1 ? { node: t, offset: i } : mw(n, r);
}
function v5(t, e) {
  let n = t.nodeValue.length, o = document.createRange();
  for (let r = 0; r < n; r++) {
    o.setEnd(t, r + 1), o.setStart(t, r);
    let i = rr(o, 1);
    if (i.top != i.bottom && fm(e, i))
      return { node: t, offset: r + (e.left >= (i.left + i.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function fm(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function y5(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function b5(t, e, n) {
  let { node: o, offset: r } = mw(e, n), i = -1;
  if (o.nodeType == 1 && !o.firstChild) {
    let s = o.getBoundingClientRect();
    i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(o, r, i);
}
function w5(t, e, n, o) {
  let r = -1;
  for (let i = e, s = !1; i != t.dom; ) {
    let a = t.docView.nearestDesc(i, !0), l;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && (!s && l.left > o.left || l.top > o.top ? r = a.posBefore : (!s && l.right < o.left || l.bottom < o.top) && (r = a.posAfter), s = !0), !a.contentDOM && r < 0 && !a.node.isText))
      return (a.node.isBlock ? o.top < (l.top + l.bottom) / 2 : o.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    i = a.dom.parentNode;
  }
  return r > -1 ? r : t.docView.posFromDOM(e, n, -1);
}
function gw(t, e, n) {
  let o = t.childNodes.length;
  if (o && n.top < n.bottom)
    for (let r = Math.max(0, Math.min(o - 1, Math.floor(o * (e.top - n.top) / (n.bottom - n.top)) - 2)), i = r; ; ) {
      let s = t.childNodes[i];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (fm(e, c))
            return gw(s, e, c);
        }
      }
      if ((i = (i + 1) % o) == r)
        break;
    }
  return t;
}
function x5(t, e) {
  let n = t.dom.ownerDocument, o, r = 0, i = c5(n, e.left, e.top);
  i && ({ node: o, offset: r } = i);
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let c = t.dom.getBoundingClientRect();
    if (!fm(e, c) || (s = gw(t.dom, e, c), !s))
      return null;
  }
  if (Ut)
    for (let c = s; o && c; c = Ra(c))
      c.draggable && (o = void 0);
  if (s = y5(s, e), o) {
    if (Fn && o.nodeType == 1 && (r = Math.min(r, o.childNodes.length), r < o.childNodes.length)) {
      let d = o.childNodes[r], u;
      d.nodeName == "IMG" && (u = d.getBoundingClientRect()).right <= e.left && u.bottom > e.top && r++;
    }
    let c;
    yl && r && o.nodeType == 1 && (c = o.childNodes[r - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && r--, o == t.dom && r == o.childNodes.length - 1 && o.lastChild.nodeType == 1 && e.top > o.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (r == 0 || o.nodeType != 1 || o.childNodes[r - 1].nodeName != "BR") && (a = w5(t, o, r, e));
  }
  a == null && (a = b5(t, s, e));
  let l = t.docView.nearestDesc(s, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function N0(t) {
  return t.top < t.bottom || t.left < t.right;
}
function rr(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let o = n[e < 0 ? 0 : n.length - 1];
    if (N0(o))
      return o;
  }
  return Array.prototype.find.call(n, N0) || t.getBoundingClientRect();
}
const k5 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function vw(t, e, n) {
  let { node: o, offset: r, atom: i } = t.docView.domFromPos(e, n < 0 ? -1 : 1), s = yl || Fn;
  if (o.nodeType == 3)
    if (s && (k5.test(o.nodeValue) || (n < 0 ? !r : r == o.nodeValue.length))) {
      let l = rr(So(o, r, r), n);
      if (Fn && r && /\s/.test(o.nodeValue[r - 1]) && r < o.nodeValue.length) {
        let c = rr(So(o, r - 1, r - 1), -1);
        if (c.top == l.top) {
          let d = rr(So(o, r, r + 1), -1);
          if (d.top != l.top)
            return Ks(d, d.left < c.left);
        }
      }
      return l;
    } else {
      let l = r, c = r, d = n < 0 ? 1 : -1;
      return n < 0 && !r ? (c++, d = -1) : n >= 0 && r == o.nodeValue.length ? (l--, d = 1) : n < 0 ? l-- : c++, Ks(rr(So(o, l, c), d), d < 0);
    }
  if (!t.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
    if (i == null && r && (n < 0 || r == Cn(o))) {
      let l = o.childNodes[r - 1];
      if (l.nodeType == 1)
        return hf(l.getBoundingClientRect(), !1);
    }
    if (i == null && r < Cn(o)) {
      let l = o.childNodes[r];
      if (l.nodeType == 1)
        return hf(l.getBoundingClientRect(), !0);
    }
    return hf(o.getBoundingClientRect(), n >= 0);
  }
  if (i == null && r && (n < 0 || r == Cn(o))) {
    let l = o.childNodes[r - 1], c = l.nodeType == 3 ? So(l, Cn(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return Ks(rr(c, 1), !1);
  }
  if (i == null && r < Cn(o)) {
    let l = o.childNodes[r];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? So(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return Ks(rr(c, -1), !0);
  }
  return Ks(rr(o.nodeType == 3 ? So(o) : o, -n), n >= 0);
}
function Ks(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function hf(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function yw(t, e, n) {
  let o = t.state, r = t.root.activeElement;
  o != e && t.updateState(e), r != t.dom && t.focus();
  try {
    return n();
  } finally {
    o != e && t.updateState(o), r != t.dom && r && r.focus();
  }
}
function C5(t, e, n) {
  let o = e.selection, r = n == "up" ? o.$from : o.$to;
  return yw(t, e, () => {
    let { node: i } = t.docView.domFromPos(r.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(i, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        i = a.contentDOM || a.dom;
        break;
      }
      i = a.dom.parentNode;
    }
    let s = vw(t, r.pos, 1);
    for (let a = i.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = So(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let d = l[c];
        if (d.bottom > d.top + 1 && (n == "up" ? s.top - d.top > (d.bottom - s.top) * 2 : d.bottom - s.bottom > (s.bottom - d.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const S5 = /[\u0590-\u08ac]/;
function A5(t, e, n) {
  let { $head: o } = e.selection;
  if (!o.parent.isTextblock)
    return !1;
  let r = o.parentOffset, i = !r, s = r == o.parent.content.size, a = t.domSelection();
  return a ? !S5.test(o.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? i : s : yw(t, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: d, anchorOffset: u } = t.domSelectionRange(), f = a.caretBidiLevel;
    a.modify("move", n, "character");
    let h = o.depth ? t.docView.domAfterPos(o.before()) : t.dom, { focusNode: m, focusOffset: g } = t.domSelectionRange(), v = m && !h.contains(m.nodeType == 1 ? m : m.parentNode) || l == m && c == g;
    try {
      a.collapse(d, u), l && (l != d || c != u) && a.extend && a.extend(l, c);
    } catch {
    }
    return f != null && (a.caretBidiLevel = f), v;
  }) : o.pos == o.start() || o.pos == o.end();
}
let B0 = null, $0 = null, z0 = !1;
function E5(t, e, n) {
  return B0 == e && $0 == n ? z0 : (B0 = e, $0 = n, z0 = n == "up" || n == "down" ? C5(t, e, n) : A5(t, e, n));
}
const An = 0, F0 = 1, Qr = 2, ro = 3;
class bl {
  constructor(e, n, o, r) {
    this.parent = e, this.children = n, this.dom = o, this.contentDOM = r, this.dirty = An, o.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, o) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, o = this.posAtStart; ; n++) {
      let r = this.children[n];
      if (r == e)
        return o;
      o += r.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, o) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (o < 0) {
        let i, s;
        if (e == this.contentDOM)
          i = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          i = e.previousSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.previousSibling;
        return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let i, s;
        if (e == this.contentDOM)
          i = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          i = e.nextSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.nextSibling;
        return i ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let r;
    if (e == this.dom && this.contentDOM)
      r = n > Ot(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      r = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            r = !1;
            break;
          }
          if (i.previousSibling)
            break;
        }
      if (r == null && n == e.childNodes.length)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            r = !0;
            break;
          }
          if (i.nextSibling)
            break;
        }
    }
    return r ?? o > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let o = !0, r = e; r; r = r.parentNode) {
      let i = this.getDesc(r), s;
      if (i && (!n || i.node))
        if (o && (s = i.nodeDOM) && !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e))
          o = !1;
        else
          return i;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let o = n; o; o = o.parent)
      if (o == this)
        return n;
  }
  posFromDOM(e, n, o) {
    for (let r = e; r; r = r.parentNode) {
      let i = this.getDesc(r);
      if (i)
        return i.localPosFromDOM(e, n, o);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, o = 0; n < this.children.length; n++) {
      let r = this.children[n], i = o + r.size;
      if (o == e && i != o) {
        for (; !r.border && r.children.length; )
          for (let s = 0; s < r.children.length; s++) {
            let a = r.children[s];
            if (a.size) {
              r = a;
              break;
            }
          }
        return r;
      }
      if (e < i)
        return r.descAt(e - o - r.border);
      o = i;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let o = 0, r = 0;
    for (let i = 0; o < this.children.length; o++) {
      let s = this.children[o], a = i + s.size;
      if (a > e || s instanceof ww) {
        r = e - i;
        break;
      }
      i = a;
    }
    if (r)
      return this.children[o].domFromPos(r - this.children[o].border, n);
    for (let i; o && !(i = this.children[o - 1]).size && i instanceof bw && i.side >= 0; o--)
      ;
    if (n <= 0) {
      let i, s = !0;
      for (; i = o ? this.children[o - 1] : null, !(!i || i.dom.parentNode == this.contentDOM); o--, s = !1)
        ;
      return i && n && s && !i.border && !i.domAtom ? i.domFromPos(i.size, n) : { node: this.contentDOM, offset: i ? Ot(i.dom) + 1 : 0 };
    } else {
      let i, s = !0;
      for (; i = o < this.children.length ? this.children[o] : null, !(!i || i.dom.parentNode == this.contentDOM); o++, s = !1)
        ;
      return i && s && !i.border && !i.domAtom ? i.domFromPos(0, n) : { node: this.contentDOM, offset: i ? Ot(i.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, o = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let r = -1, i = -1;
    for (let s = o, a = 0; ; a++) {
      let l = this.children[a], c = s + l.size;
      if (r == -1 && e <= c) {
        let d = s + l.border;
        if (e >= d && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, d);
        e = s;
        for (let u = a; u > 0; u--) {
          let f = this.children[u - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            r = Ot(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        r == -1 && (r = 0);
      }
      if (r > -1 && (c > n || a == this.children.length - 1)) {
        n = c;
        for (let d = a + 1; d < this.children.length; d++) {
          let u = this.children[d];
          if (u.size && u.dom.parentNode == this.contentDOM && !u.emptyChildAt(-1)) {
            i = Ot(u.dom);
            break;
          }
          n += u.size;
        }
        i == -1 && (i = this.contentDOM.childNodes.length);
        break;
      }
      s = c;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: r, toOffset: i };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: o } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || o == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[o];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, o, r = !1) {
    let i = Math.min(e, n), s = Math.max(e, n);
    for (let h = 0, m = 0; h < this.children.length; h++) {
      let g = this.children[h], v = m + g.size;
      if (i > m && s < v)
        return g.setSelection(e - m - g.border, n - m - g.border, o, r);
      m = v;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c = o.root.getSelection(), d = o.domSelectionRange(), u = !1;
    if ((Fn || Ut) && e == n) {
      let { node: h, offset: m } = a;
      if (h.nodeType == 3) {
        if (u = !!(m && h.nodeValue[m - 1] == `
`), u && m == h.nodeValue.length)
          for (let g = h, v; g; g = g.parentNode) {
            if (v = g.nextSibling) {
              v.nodeName == "BR" && (a = l = { node: v.parentNode, offset: Ot(v) + 1 });
              break;
            }
            let y = g.pmViewDesc;
            if (y && y.node && y.node.isBlock)
              break;
          }
      } else {
        let g = h.childNodes[m - 1];
        u = g && (g.nodeName == "BR" || g.contentEditable == "false");
      }
    }
    if (Fn && d.focusNode && d.focusNode != l.node && d.focusNode.nodeType == 1) {
      let h = d.focusNode.childNodes[d.focusOffset];
      h && h.contentEditable == "false" && (r = !0);
    }
    if (!(r || u && Ut) && pi(a.node, a.offset, d.anchorNode, d.anchorOffset) && pi(l.node, l.offset, d.focusNode, d.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == n) && !u) {
      c.collapse(a.node, a.offset);
      try {
        e != n && c.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let m = a;
        a = l, l = m;
      }
      let h = document.createRange();
      h.setEnd(l.node, l.offset), h.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(h);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let o = 0, r = 0; r < this.children.length; r++) {
      let i = this.children[r], s = o + i.size;
      if (o == s ? e <= s && n >= o : e < s && n > o) {
        let a = o + i.border, l = s - i.border;
        if (e >= a && n <= l) {
          this.dirty = e == o || n == s ? Qr : F0, e == a && n == l && (i.contentLost || i.dom.parentNode != this.contentDOM) ? i.dirty = ro : i.markDirty(e - a, n - a);
          return;
        } else
          i.dirty = i.dom == i.contentDOM && i.dom.parentNode == this.contentDOM && !i.children.length ? Qr : ro;
      }
      o = s;
    }
    this.dirty = Qr;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let o = e == 1 ? Qr : F0;
      n.dirty < o && (n.dirty = o);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class bw extends bl {
  constructor(e, n, o, r) {
    let i, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(o, () => {
      if (!i)
        return r;
      if (i.parent)
        return i.parent.posBeforeChild(i);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), s = a;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(e, [], s, null), this.widget = n, this.widget = n, i = this;
  }
  matchesWidget(e) {
    return this.dirty == An && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class _5 extends bl {
  constructor(e, n, o, r) {
    super(e, [], n, null), this.textDOM = o, this.text = r;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class hi extends bl {
  constructor(e, n, o, r, i) {
    super(e, [], o, r), this.mark = n, this.spec = i;
  }
  static create(e, n, o, r) {
    let i = r.nodeViews[n.type.name], s = i && i(n, r, o);
    return (!s || !s.dom) && (s = Nr.renderSpec(document, n.type.spec.toDOM(n, o), null, n.attrs)), new hi(e, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & ro || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != ro && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != An) {
      let o = this.parent;
      for (; !o.node; )
        o = o.parent;
      o.dirty < this.dirty && (o.dirty = this.dirty), this.dirty = An;
    }
  }
  slice(e, n, o) {
    let r = hi.create(this.parent, this.mark, !0, o), i = this.children, s = this.size;
    n < s && (i = Rp(i, n, s, o)), e > 0 && (i = Rp(i, 0, e, o));
    for (let a = 0; a < i.length; a++)
      i[a].parent = r;
    return r.children = i, r;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class kr extends bl {
  constructor(e, n, o, r, i, s, a, l, c) {
    super(e, [], i, s), this.node = n, this.outerDeco = o, this.innerDeco = r, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, o, r, i, s) {
    let a = i.nodeViews[n.type.name], l, c = a && a(n, i, () => {
      if (!l)
        return s;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, o, r), d = c && c.dom, u = c && c.contentDOM;
    if (n.isText) {
      if (!d)
        d = document.createTextNode(n.text);
      else if (d.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      d || ({ dom: d, contentDOM: u } = Nr.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !u && !n.isText && d.nodeName != "BR" && (d.hasAttribute("contenteditable") || (d.contentEditable = "false"), n.type.spec.draggable && (d.draggable = !0));
    let f = d;
    return d = Cw(d, o, n), c ? l = new M5(e, n, o, r, d, u || null, f, c, i, s + 1) : n.isText ? new ou(e, n, o, r, d, f, i) : new kr(e, n, o, r, d, u || null, f, i, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let o = this.children[n];
        if (this.dom.contains(o.dom.parentNode)) {
          e.contentElement = o.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => W.empty);
    }
    return e;
  }
  matchesNode(e, n, o) {
    return this.dirty == An && e.eq(this.node) && qc(n, this.outerDeco) && o.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let o = this.node.inlineContent, r = n, i = e.composing ? this.localCompositionInfo(e, n) : null, s = i && i.pos > -1 ? i : null, a = i && i.pos < 0, l = new O5(this, s && s.node, e);
    R5(this.node, this.innerDeco, (c, d, u) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, o, e) : c.type.side >= 0 && !u && l.syncToMarks(d == this.node.childCount ? Xe.none : this.node.child(d).marks, o, e), l.placeWidget(c, e, r);
    }, (c, d, u, f) => {
      l.syncToMarks(c.marks, o, e);
      let h;
      l.findNodeMatch(c, d, u, f) || a && e.state.selection.from > r && e.state.selection.to < r + c.nodeSize && (h = l.findIndexWithChild(i.node)) > -1 && l.updateNodeAt(c, d, u, h, e) || l.updateNextNode(c, d, u, e, f, r) || l.addNode(c, d, u, e, r), r += c.nodeSize;
    }), l.syncToMarks([], o, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Qr) && (s && this.protectLocalComposition(e, s), xw(this.contentDOM, this.children, e), as && P5(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: o, to: r } = e.state.selection;
    if (!(e.state.selection instanceof le) || o < n || r > n + this.node.content.size)
      return null;
    let i = e.input.compositionNode;
    if (!i || !this.dom.contains(i.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = i.nodeValue, a = L5(this.node.content, s, o - n, r - n);
      return a < 0 ? null : { node: i, pos: a, text: s };
    } else
      return { node: i, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: o, text: r }) {
    if (this.getDesc(n))
      return;
    let i = n;
    for (; i.parentNode != this.contentDOM; i = i.parentNode) {
      for (; i.previousSibling; )
        i.parentNode.removeChild(i.previousSibling);
      for (; i.nextSibling; )
        i.parentNode.removeChild(i.nextSibling);
      i.pmViewDesc && (i.pmViewDesc = void 0);
    }
    let s = new _5(this, i, n, r);
    e.input.compositionNodes.push(s), this.children = Rp(this.children, o, o + r.length, e, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, o, r) {
    return this.dirty == ro || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, o, r), !0);
  }
  updateInner(e, n, o, r) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = o, this.contentDOM && this.updateChildren(r, this.posAtStart), this.dirty = An;
  }
  updateOuterDeco(e) {
    if (qc(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, o = this.dom;
    this.dom = kw(this.dom, this.nodeDOM, Dp(this.outerDeco, this.node, n), Dp(e, this.node, n)), this.dom != o && (o.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function H0(t, e, n, o, r) {
  Cw(o, e, t);
  let i = new kr(void 0, t, e, n, o, o, o, r, 0);
  return i.contentDOM && i.updateChildren(r, 0), i;
}
class ou extends kr {
  constructor(e, n, o, r, i, s, a) {
    super(e, n, o, r, i, null, s, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, o, r) {
    return this.dirty == ro || this.dirty != An && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != An || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, r.trackWrites == this.nodeDOM && (r.trackWrites = null)), this.node = e, this.dirty = An, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, o) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, o);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, o) {
    let r = this.node.cut(e, n), i = document.createTextNode(r.text);
    return new ou(this.parent, r, this.outerDeco, this.innerDeco, i, i, o);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = ro);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class ww extends bl {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == An && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class M5 extends kr {
  constructor(e, n, o, r, i, s, a, l, c, d) {
    super(e, n, o, r, i, s, a, c, d), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, o, r) {
    if (this.dirty == ro)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let i = this.spec.update(e, n, o);
      return i && this.updateInner(e, n, o, r), i;
    } else
      return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, o, r);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, o, r) {
    this.spec.setSelection ? this.spec.setSelection(e, n, o.root) : super.setSelection(e, n, o, r);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function xw(t, e, n) {
  let o = t.firstChild, r = !1;
  for (let i = 0; i < e.length; i++) {
    let s = e[i], a = s.dom;
    if (a.parentNode == t) {
      for (; a != o; )
        o = V0(o), r = !0;
      o = o.nextSibling;
    } else
      r = !0, t.insertBefore(a, o);
    if (s instanceof hi) {
      let l = o ? o.previousSibling : t.lastChild;
      xw(s.contentDOM, s.children, n), o = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; o; )
    o = V0(o), r = !0;
  r && n.trackWrites == t && (n.trackWrites = null);
}
const da = function(t) {
  t && (this.nodeName = t);
};
da.prototype = /* @__PURE__ */ Object.create(null);
const ei = [new da()];
function Dp(t, e, n) {
  if (t.length == 0)
    return ei;
  let o = n ? ei[0] : new da(), r = [o];
  for (let i = 0; i < t.length; i++) {
    let s = t[i].type.attrs;
    if (s) {
      s.nodeName && r.push(o = new da(s.nodeName));
      for (let a in s) {
        let l = s[a];
        l != null && (n && r.length == 1 && r.push(o = new da(e.isInline ? "span" : "div")), a == "class" ? o.class = (o.class ? o.class + " " : "") + l : a == "style" ? o.style = (o.style ? o.style + ";" : "") + l : a != "nodeName" && (o[a] = l));
      }
    }
  }
  return r;
}
function kw(t, e, n, o) {
  if (n == ei && o == ei)
    return e;
  let r = e;
  for (let i = 0; i < o.length; i++) {
    let s = o[i], a = n[i];
    if (i) {
      let l;
      a && a.nodeName == s.nodeName && r != t && (l = r.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = !0, l.appendChild(r), a = ei[0]), r = l;
    }
    T5(r, a || ei[0], s);
  }
  return r;
}
function T5(t, e, n) {
  for (let o in e)
    o != "class" && o != "style" && o != "nodeName" && !(o in n) && t.removeAttribute(o);
  for (let o in n)
    o != "class" && o != "style" && o != "nodeName" && n[o] != e[o] && t.setAttribute(o, n[o]);
  if (e.class != n.class) {
    let o = e.class ? e.class.split(" ").filter(Boolean) : [], r = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < o.length; i++)
      r.indexOf(o[i]) == -1 && t.classList.remove(o[i]);
    for (let i = 0; i < r.length; i++)
      o.indexOf(r[i]) == -1 && t.classList.add(r[i]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let o = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, r;
      for (; r = o.exec(e.style); )
        t.style.removeProperty(r[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function Cw(t, e, n) {
  return kw(t, t, ei, Dp(e, n, t.nodeType != 1));
}
function qc(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function V0(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class O5 {
  constructor(e, n, o) {
    this.lock = n, this.view = o, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = I5(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let o = e; o < n; o++)
        this.top.children[o].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, o) {
    let r = 0, i = this.stack.length >> 1, s = Math.min(i, e.length);
    for (; r < s && (r == i - 1 ? this.top : this.stack[r + 1 << 1]).matchesMark(e[r]) && e[r].type.spec.spanning !== !1; )
      r++;
    for (; r < i; )
      this.destroyRest(), this.top.dirty = An, this.index = this.stack.pop(), this.top = this.stack.pop(), i--;
    for (; i < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l];
        if (c.matchesMark(e[i]) && !this.isLocked(c.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = hi.create(this.top, e[i], n, o);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, i++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, o, r) {
    let i = -1, s;
    if (r >= this.preMatch.index && (s = this.preMatch.matches[r - this.preMatch.index]).parent == this.top && s.matchesNode(e, n, o))
      i = this.top.children.indexOf(s, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a];
        if (c.matchesNode(e, n, o) && !this.preMatch.matched.has(c)) {
          i = a;
          break;
        }
      }
    return i < 0 ? !1 : (this.destroyBetween(this.index, i), this.index++, !0);
  }
  updateNodeAt(e, n, o, r, i) {
    let s = this.top.children[r];
    return s.dirty == ro && s.dom == s.contentDOM && (s.dirty = Qr), s.update(e, n, o, i) ? (this.destroyBetween(this.index, r), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let o = e.pmViewDesc;
        if (o) {
          for (let r = this.index; r < this.top.children.length; r++)
            if (this.top.children[r] == o)
              return r;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, o, r, i, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof kr) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != i)
          return !1;
        let d = l.dom, u, f = this.isLocked(d) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != ro && qc(n, l.outerDeco));
        if (!f && l.update(e, n, o, r))
          return this.destroyBetween(this.index, a), l.dom != d && (this.changed = !0), this.index++, !0;
        if (!f && (u = this.recreateWrapper(l, e, n, o, r, s)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = u, u.contentDOM && (u.dirty = Qr, u.updateChildren(r, s + 1), u.dirty = An), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, o, r, i, s) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !qc(o, e.outerDeco) || !r.eq(e.innerDeco))
      return null;
    let a = kr.create(this.top, n, o, r, i, s);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, o, r, i) {
    let s = kr.create(this.top, e, n, o, r, i);
    s.contentDOM && s.updateChildren(r, i + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(e, n, o) {
    let r = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (r && r.matchesWidget(e) && (e == r.widget || !r.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let i = new bw(this.top, e, n, o);
      this.top.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof hi; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof ou) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Ut || Bt) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let o = document.createElement(e);
      e == "IMG" && (o.className = "ProseMirror-separator", o.alt = ""), e == "BR" && (o.className = "ProseMirror-trailingBreak");
      let r = new ww(this.top, [], o, null);
      n != this.top ? n.children.push(r) : n.children.splice(this.index++, 0, r), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function I5(t, e) {
  let n = e, o = n.children.length, r = t.childCount, i = /* @__PURE__ */ new Map(), s = [];
  e:
    for (; r > 0; ) {
      let a;
      for (; ; )
        if (o) {
          let c = n.children[o - 1];
          if (c instanceof hi)
            n = c, o = c.children.length;
          else {
            a = c, o--;
            break;
          }
        } else {
          if (n == e)
            break e;
          o = n.parent.children.indexOf(n), n = n.parent;
        }
      let l = a.node;
      if (l) {
        if (l != t.child(r - 1))
          break;
        --r, i.set(a, r), s.push(a);
      }
    }
  return { index: r, matched: i, matches: s.reverse() };
}
function D5(t, e) {
  return t.type.side - e.type.side;
}
function R5(t, e, n, o) {
  let r = e.locals(t), i = 0;
  if (r.length == 0) {
    for (let c = 0; c < t.childCount; c++) {
      let d = t.child(c);
      o(d, r, e.forChild(i, d), c), i += d.nodeSize;
    }
    return;
  }
  let s = 0, a = [], l = null;
  for (let c = 0; ; ) {
    let d, u;
    for (; s < r.length && r[s].to == i; ) {
      let v = r[s++];
      v.widget && (d ? (u || (u = [d])).push(v) : d = v);
    }
    if (d)
      if (u) {
        u.sort(D5);
        for (let v = 0; v < u.length; v++)
          n(u[v], c, !!l);
      } else
        n(d, c, !!l);
    let f, h;
    if (l)
      h = -1, f = l, l = null;
    else if (c < t.childCount)
      h = c, f = t.child(c++);
    else
      break;
    for (let v = 0; v < a.length; v++)
      a[v].to <= i && a.splice(v--, 1);
    for (; s < r.length && r[s].from <= i && r[s].to > i; )
      a.push(r[s++]);
    let m = i + f.nodeSize;
    if (f.isText) {
      let v = m;
      s < r.length && r[s].from < v && (v = r[s].from);
      for (let y = 0; y < a.length; y++)
        a[y].to < v && (v = a[y].to);
      v < m && (l = f.cut(v - i), f = f.cut(0, v - i), m = v, h = -1);
    } else
      for (; s < r.length && r[s].to < m; )
        s++;
    let g = f.isInline && !f.isLeaf ? a.filter((v) => !v.inline) : a.slice();
    o(f, g, e.forChild(i, f), h), i = m;
  }
}
function P5(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function L5(t, e, n, o) {
  for (let r = 0, i = 0; r < t.childCount && i <= o; ) {
    let s = t.child(r++), a = i;
    if (i += s.nodeSize, !s.isText)
      continue;
    let l = s.text;
    for (; r < t.childCount; ) {
      let c = t.child(r++);
      if (i += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (i >= n) {
      if (i >= o && l.slice(o - e.length - a, o - a) == e)
        return o - e.length;
      let c = a < o ? l.lastIndexOf(e, o - a - 1) : -1;
      if (c >= 0 && c + e.length + a >= n)
        return a + c;
      if (n == o && l.length >= o + e.length - a && l.slice(o - a, o - a + e.length) == e)
        return o;
    }
  }
  return -1;
}
function Rp(t, e, n, o, r) {
  let i = [];
  for (let s = 0, a = 0; s < t.length; s++) {
    let l = t[s], c = a, d = a += l.size;
    c >= n || d <= e ? i.push(l) : (c < e && i.push(l.slice(0, e - c, o)), r && (i.push(r), r = void 0), d > n && i.push(l.slice(n - c, l.size, o)));
  }
  return i;
}
function pm(t, e = null) {
  let n = t.domSelectionRange(), o = t.state.doc;
  if (!n.focusNode)
    return null;
  let r = t.docView.nearestDesc(n.focusNode), i = r && r.size == 0, s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let a = o.resolve(s), l, c;
  if (nu(n)) {
    for (l = s; r && !r.node; )
      r = r.parent;
    let u = r.node;
    if (r && u.isAtom && de.isSelectable(u) && r.parent && !(u.isInline && a5(n.focusNode, n.focusOffset, r.dom))) {
      let f = r.posBefore;
      c = new de(s == f ? a : o.resolve(f));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let u = s, f = s;
      for (let h = 0; h < n.rangeCount; h++) {
        let m = n.getRangeAt(h);
        u = Math.min(u, t.docView.posFromDOM(m.startContainer, m.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(m.endContainer, m.endOffset, -1));
      }
      if (u < 0)
        return null;
      [l, s] = f == t.state.selection.anchor ? [f, u] : [u, f], a = o.resolve(s);
    } else
      l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let d = o.resolve(l);
  if (!c) {
    let u = e == "pointer" || t.state.selection.head < a.pos && !i ? 1 : -1;
    c = hm(t, d, a, u);
  }
  return c;
}
function Sw(t) {
  return t.editable ? t.hasFocus() : Ew(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Po(t, e = !1) {
  let n = t.state.selection;
  if (Aw(t, n), !!Sw(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Bt) {
      let o = t.domSelectionRange(), r = t.domObserver.currentSelection;
      if (o.anchorNode && r.anchorNode && pi(o.anchorNode, o.anchorOffset, r.anchorNode, r.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      B5(t);
    else {
      let { anchor: o, head: r } = n, i, s;
      j0 && !(n instanceof le) && (n.$from.parent.inlineContent || (i = U0(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = U0(t, n.to))), t.docView.setSelection(o, r, t, e), j0 && (i && W0(i), s && W0(s)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && N5(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const j0 = Ut || Bt && fw < 63;
function U0(t, e) {
  let { node: n, offset: o } = t.docView.domFromPos(e, 0), r = o < n.childNodes.length ? n.childNodes[o] : null, i = o ? n.childNodes[o - 1] : null;
  if (Ut && r && r.contentEditable == "false")
    return mf(r);
  if ((!r || r.contentEditable == "false") && (!i || i.contentEditable == "false")) {
    if (r)
      return mf(r);
    if (i)
      return mf(i);
  }
}
function mf(t) {
  return t.contentEditable = "true", Ut && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function W0(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function N5(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), o = n.anchorNode, r = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != o || n.anchorOffset != r) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!Sw(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function B5(t) {
  let e = t.domSelection(), n = document.createRange();
  if (!e)
    return;
  let o = t.cursorWrapper.dom, r = o.nodeName == "IMG";
  r ? n.setStart(o.parentNode, Ot(o) + 1) : n.setStart(o, 0), n.collapse(!0), e.removeAllRanges(), e.addRange(n), !r && !t.state.selection.visible && Yt && xr <= 11 && (o.disabled = !0, o.disabled = !1);
}
function Aw(t, e) {
  if (e instanceof de) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (K0(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    K0(t);
}
function K0(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function hm(t, e, n, o) {
  return t.someProp("createSelectionBetween", (r) => r(t, e, n)) || le.between(e, n, o);
}
function q0(t) {
  return t.editable && !t.hasFocus() ? !1 : Ew(t);
}
function Ew(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function $5(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return pi(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function Pp(t, e) {
  let { $anchor: n, $head: o } = t.selection, r = e > 0 ? n.max(o) : n.min(o), i = r.parent.inlineContent ? r.depth ? t.doc.resolve(e > 0 ? r.after() : r.before()) : null : r;
  return i && pe.findFrom(i, e);
}
function sr(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function G0(t, e, n) {
  let o = t.state.selection;
  if (o instanceof le)
    if (n.indexOf("s") > -1) {
      let { $head: r } = o, i = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter;
      if (!i || i.isText || !i.isLeaf)
        return !1;
      let s = t.state.doc.resolve(r.pos + i.nodeSize * (e < 0 ? -1 : 1));
      return sr(t, new le(o.$anchor, s));
    } else if (o.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let r = Pp(t.state, e);
        return r && r instanceof de ? sr(t, r) : !1;
      } else if (!(kn && n.indexOf("m") > -1)) {
        let r = o.$head, i = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter, s;
        if (!i || i.isText)
          return !1;
        let a = e < 0 ? r.pos - i.nodeSize : r.pos;
        return i.isAtom || (s = t.docView.descAt(a)) && !s.contentDOM ? de.isSelectable(i) ? sr(t, new de(e < 0 ? t.state.doc.resolve(r.pos - i.nodeSize) : r)) : yl ? sr(t, new le(t.state.doc.resolve(e < 0 ? a : a + i.nodeSize))) : !1 : !1;
      }
    } else
      return !1;
  else {
    if (o instanceof de && o.node.isInline)
      return sr(t, new le(e > 0 ? o.$to : o.$from));
    {
      let r = Pp(t.state, e);
      return r ? sr(t, r) : !1;
    }
  }
}
function Gc(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function ua(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function Bi(t, e) {
  return e < 0 ? z5(t) : F5(t);
}
function z5(t) {
  let e = t.domSelectionRange(), n = e.focusNode, o = e.focusOffset;
  if (!n)
    return;
  let r, i, s = !1;
  for (Fn && n.nodeType == 1 && o < Gc(n) && ua(n.childNodes[o], -1) && (s = !0); ; )
    if (o > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[o - 1];
        if (ua(a, -1))
          r = n, i = --o;
        else if (a.nodeType == 3)
          n = a, o = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (_w(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && ua(a, -1); )
          r = n.parentNode, i = Ot(a), a = a.previousSibling;
        if (a)
          n = a, o = Gc(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          o = 0;
        }
      }
    }
  s ? Lp(t, n, o) : r && Lp(t, r, i);
}
function F5(t) {
  let e = t.domSelectionRange(), n = e.focusNode, o = e.focusOffset;
  if (!n)
    return;
  let r = Gc(n), i, s;
  for (; ; )
    if (o < r) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[o];
      if (ua(a, 1))
        i = n, s = ++o;
      else
        break;
    } else {
      if (_w(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && ua(a, 1); )
          i = a.parentNode, s = Ot(a) + 1, a = a.nextSibling;
        if (a)
          n = a, o = 0, r = Gc(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          o = r = 0;
        }
      }
    }
  i && Lp(t, i, s);
}
function _w(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function H5(t, e) {
  for (; t && e == t.childNodes.length && !vl(t); )
    e = Ot(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function V5(t, e) {
  for (; t && !e && !vl(t); )
    e = Ot(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function Lp(t, e, n) {
  if (e.nodeType != 3) {
    let i, s;
    (s = H5(e, n)) ? (e = s, n = 0) : (i = V5(e, n)) && (e = i, n = i.nodeValue.length);
  }
  let o = t.domSelection();
  if (!o)
    return;
  if (nu(o)) {
    let i = document.createRange();
    i.setEnd(e, n), i.setStart(e, n), o.removeAllRanges(), o.addRange(i);
  } else
    o.extend && o.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: r } = t;
  setTimeout(() => {
    t.state == r && Po(t);
  }, 50);
}
function J0(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(Bt || d5) && n.parent.inlineContent) {
    let r = t.coordsAtPos(e);
    if (e > n.start()) {
      let i = t.coordsAtPos(e - 1), s = (i.top + i.bottom) / 2;
      if (s > r.top && s < r.bottom && Math.abs(i.left - r.left) > 1)
        return i.left < r.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let i = t.coordsAtPos(e + 1), s = (i.top + i.bottom) / 2;
      if (s > r.top && s < r.bottom && Math.abs(i.left - r.left) > 1)
        return i.left > r.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Y0(t, e, n) {
  let o = t.state.selection;
  if (o instanceof le && !o.empty || n.indexOf("s") > -1 || kn && n.indexOf("m") > -1)
    return !1;
  let { $from: r, $to: i } = o;
  if (!r.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let s = Pp(t.state, e);
    if (s && s instanceof de)
      return sr(t, s);
  }
  if (!r.parent.inlineContent) {
    let s = e < 0 ? r : i, a = o instanceof Jt ? pe.near(s, e) : pe.findFrom(s, e);
    return a ? sr(t, a) : !1;
  }
  return !1;
}
function X0(t, e) {
  if (!(t.state.selection instanceof le))
    return !0;
  let { $head: n, $anchor: o, empty: r } = t.state.selection;
  if (!n.sameParent(o))
    return !0;
  if (!r)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (i && !i.isText) {
    let s = t.state.tr;
    return e < 0 ? s.delete(n.pos - i.nodeSize, n.pos) : s.delete(n.pos, n.pos + i.nodeSize), t.dispatch(s), !0;
  }
  return !1;
}
function Z0(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function j5(t) {
  if (!Ut || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let o = e.firstChild;
    Z0(t, o, "true"), setTimeout(() => Z0(t, o, "false"), 20);
  }
  return !1;
}
function U5(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function W5(t, e) {
  let n = e.keyCode, o = U5(e);
  if (n == 8 || kn && n == 72 && o == "c")
    return X0(t, -1) || Bi(t, -1);
  if (n == 46 && !e.shiftKey || kn && n == 68 && o == "c")
    return X0(t, 1) || Bi(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || kn && n == 66 && o == "c") {
    let r = n == 37 ? J0(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return G0(t, r, o) || Bi(t, r);
  } else if (n == 39 || kn && n == 70 && o == "c") {
    let r = n == 39 ? J0(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return G0(t, r, o) || Bi(t, r);
  } else {
    if (n == 38 || kn && n == 80 && o == "c")
      return Y0(t, -1, o) || Bi(t, -1);
    if (n == 40 || kn && n == 78 && o == "c")
      return j5(t) || Y0(t, 1, o) || Bi(t, 1);
    if (o == (kn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function mm(t, e) {
  t.someProp("transformCopied", (h) => {
    e = h(e, t);
  });
  let n = [], { content: o, openStart: r, openEnd: i } = e;
  for (; r > 1 && i > 1 && o.childCount == 1 && o.firstChild.childCount == 1; ) {
    r--, i--;
    let h = o.firstChild;
    n.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), o = h.content;
  }
  let s = t.someProp("clipboardSerializer") || Nr.fromSchema(t.state.schema), a = Rw(), l = a.createElement("div");
  l.appendChild(s.serializeFragment(o, { document: a }));
  let c = l.firstChild, d, u = 0;
  for (; c && c.nodeType == 1 && (d = Dw[c.nodeName.toLowerCase()]); ) {
    for (let h = d.length - 1; h >= 0; h--) {
      let m = a.createElement(d[h]);
      for (; l.firstChild; )
        m.appendChild(l.firstChild);
      l.appendChild(m), u++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${r} ${i}${u ? ` -${u}` : ""} ${JSON.stringify(n)}`);
  let f = t.someProp("clipboardTextSerializer", (h) => h(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function Mw(t, e, n, o, r) {
  let i = r.parent.type.spec.code, s, a;
  if (!n && !e)
    return null;
  let l = e && (o || i || !n);
  if (l) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, i || o, t);
    }), i)
      return e ? new ee(W.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : ee.empty;
    let u = t.someProp("clipboardTextParser", (f) => f(e, r, o, t));
    if (u)
      a = u;
    else {
      let f = r.marks(), { schema: h } = t.state, m = Nr.fromSchema(h);
      s = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((g) => {
        let v = s.appendChild(document.createElement("p"));
        g && v.appendChild(m.serializeNode(h.text(g, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (u) => {
      n = u(n, t);
    }), s = J5(n), yl && Y5(s);
  let c = s && s.querySelector("[data-pm-slice]"), d = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (d && d[3])
    for (let u = +d[3]; u > 0; u--) {
      let f = s.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      s = f;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || la.fromSchema(t.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(l || d),
    context: r,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !K5.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), d)
    a = X5(Q0(a, +d[1], +d[2]), d[4]);
  else if (a = ee.maxOpen(q5(a.content, r), !0), a.openStart || a.openEnd) {
    let u = 0, f = 0;
    for (let h = a.content.firstChild; u < a.openStart && !h.type.spec.isolating; u++, h = h.firstChild)
      ;
    for (let h = a.content.lastChild; f < a.openEnd && !h.type.spec.isolating; f++, h = h.lastChild)
      ;
    a = Q0(a, u, f);
  }
  return t.someProp("transformPasted", (u) => {
    a = u(a, t);
  }), a;
}
const K5 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function q5(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let r = e.node(n).contentMatchAt(e.index(n)), i, s = [];
    if (t.forEach((a) => {
      if (!s)
        return;
      let l = r.findWrapping(a.type), c;
      if (!l)
        return s = null;
      if (c = s.length && i.length && Ow(l, i, a, s[s.length - 1], 0))
        s[s.length - 1] = c;
      else {
        s.length && (s[s.length - 1] = Iw(s[s.length - 1], i.length));
        let d = Tw(a, l);
        s.push(d), r = r.matchType(d.type), i = l;
      }
    }), s)
      return W.from(s);
  }
  return t;
}
function Tw(t, e, n = 0) {
  for (let o = e.length - 1; o >= n; o--)
    t = e[o].create(null, W.from(t));
  return t;
}
function Ow(t, e, n, o, r) {
  if (r < t.length && r < e.length && t[r] == e[r]) {
    let i = Ow(t, e, n, o.lastChild, r + 1);
    if (i)
      return o.copy(o.content.replaceChild(o.childCount - 1, i));
    if (o.contentMatchAt(o.childCount).matchType(r == t.length - 1 ? n.type : t[r + 1]))
      return o.copy(o.content.append(W.from(Tw(n, t, r + 1))));
  }
}
function Iw(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, Iw(t.lastChild, e - 1)), o = t.contentMatchAt(t.childCount).fillBefore(W.empty, !0);
  return t.copy(n.append(o));
}
function Np(t, e, n, o, r, i) {
  let s = e < 0 ? t.firstChild : t.lastChild, a = s.content;
  return t.childCount > 1 && (i = 0), r < o - 1 && (a = Np(a, e, n, o, r + 1, i)), r >= n && (a = e < 0 ? s.contentMatchAt(0).fillBefore(a, i <= r).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(W.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(a));
}
function Q0(t, e, n) {
  return e < t.openStart && (t = new ee(Np(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new ee(Np(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const Dw = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let e1 = null;
function Rw() {
  return e1 || (e1 = document.implementation.createHTMLDocument("title"));
}
let gf = null;
function G5(t) {
  let e = window.trustedTypes;
  return e ? (gf || (gf = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), gf.createHTML(t)) : t;
}
function J5(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = Rw().createElement("div"), o = /<([a-z][^>\s]+)/i.exec(t), r;
  if ((r = o && Dw[o[1].toLowerCase()]) && (t = r.map((i) => "<" + i + ">").join("") + t + r.map((i) => "</" + i + ">").reverse().join("")), n.innerHTML = G5(t), r)
    for (let i = 0; i < r.length; i++)
      n = n.querySelector(r[i]) || n;
  return n;
}
function Y5(t) {
  let e = t.querySelectorAll(Bt ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let o = e[n];
    o.childNodes.length == 1 && o.textContent == " " && o.parentNode && o.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), o);
  }
}
function X5(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, o;
  try {
    o = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: r, openStart: i, openEnd: s } = t;
  for (let a = o.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[o[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    r = W.from(l.create(o[a + 1], r)), i++, s++;
  }
  return new ee(r, i, s);
}
const Wt = {}, Kt = {}, Z5 = { touchstart: !0, touchmove: !0 };
class Q5 {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function ek(t) {
  for (let e in Wt) {
    let n = Wt[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (o) => {
      nk(t, o) && !gm(t, o) && (t.editable || !(o.type in Kt)) && n(t, o);
    }, Z5[e] ? { passive: !0 } : void 0);
  }
  Ut && t.dom.addEventListener("input", () => null), Bp(t);
}
function vr(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function tk(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Bp(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (o) => gm(t, o));
  });
}
function gm(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let o = n[e.type];
    return o ? o(t, e) || e.defaultPrevented : !1;
  });
}
function nk(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function ok(t, e) {
  !gm(t, e) && Wt[e.type] && (t.editable || !(e.type in Kt)) && Wt[e.type](t, e);
}
Kt.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !Lw(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(Oo && Bt && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), as && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let o = Date.now();
      t.input.lastIOSEnter = o, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == o && (t.someProp("handleKeyDown", (r) => r(t, Xr(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else
      t.someProp("handleKeyDown", (o) => o(t, n)) || W5(t, n) ? n.preventDefault() : vr(t, "key");
};
Kt.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Kt.keypress = (t, e) => {
  let n = e;
  if (Lw(t, n) || !n.charCode || n.ctrlKey && !n.altKey || kn && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (r) => r(t, n))) {
    n.preventDefault();
    return;
  }
  let o = t.state.selection;
  if (!(o instanceof le) || !o.$from.sameParent(o.$to)) {
    let r = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(r) && !t.someProp("handleTextInput", (i) => i(t, o.$from.pos, o.$to.pos, r)) && t.dispatch(t.state.tr.insertText(r).scrollIntoView()), n.preventDefault();
  }
};
function ru(t) {
  return { left: t.clientX, top: t.clientY };
}
function rk(t, e) {
  let n = e.x - t.clientX, o = e.y - t.clientY;
  return n * n + o * o < 100;
}
function vm(t, e, n, o, r) {
  if (o == -1)
    return !1;
  let i = t.state.doc.resolve(o);
  for (let s = i.depth + 1; s > 0; s--)
    if (t.someProp(e, (a) => s > i.depth ? a(t, n, i.nodeAfter, i.before(s), r, !0) : a(t, n, i.node(s), i.before(s), r, !1)))
      return !0;
  return !1;
}
function es(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let o = t.state.tr.setSelection(e);
  o.setMeta("pointer", !0), t.dispatch(o);
}
function ik(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), o = n.nodeAfter;
  return o && o.isAtom && de.isSelectable(o) ? (es(t, new de(n)), !0) : !1;
}
function sk(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, o, r;
  n instanceof de && (o = n.node);
  let i = t.state.doc.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let a = s > i.depth ? i.nodeAfter : i.node(s);
    if (de.isSelectable(a)) {
      o && n.$from.depth > 0 && s >= n.$from.depth && i.before(n.$from.depth + 1) == n.$from.pos ? r = i.before(n.$from.depth) : r = i.before(s);
      break;
    }
  }
  return r != null ? (es(t, de.create(t.state.doc, r)), !0) : !1;
}
function ak(t, e, n, o, r) {
  return vm(t, "handleClickOn", e, n, o) || t.someProp("handleClick", (i) => i(t, e, o)) || (r ? sk(t, n) : ik(t, n));
}
function lk(t, e, n, o) {
  return vm(t, "handleDoubleClickOn", e, n, o) || t.someProp("handleDoubleClick", (r) => r(t, e, o));
}
function ck(t, e, n, o) {
  return vm(t, "handleTripleClickOn", e, n, o) || t.someProp("handleTripleClick", (r) => r(t, e, o)) || dk(t, n, o);
}
function dk(t, e, n) {
  if (n.button != 0)
    return !1;
  let o = t.state.doc;
  if (e == -1)
    return o.inlineContent ? (es(t, le.create(o, 0, o.content.size)), !0) : !1;
  let r = o.resolve(e);
  for (let i = r.depth + 1; i > 0; i--) {
    let s = i > r.depth ? r.nodeAfter : r.node(i), a = r.before(i);
    if (s.inlineContent)
      es(t, le.create(o, a + 1, a + 1 + s.content.size));
    else if (de.isSelectable(s))
      es(t, de.create(o, a));
    else
      continue;
    return !0;
  }
}
function ym(t) {
  return Jc(t);
}
const Pw = kn ? "metaKey" : "ctrlKey";
Wt.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let o = ym(t), r = Date.now(), i = "singleClick";
  r - t.input.lastClick.time < 500 && rk(n, t.input.lastClick) && !n[Pw] && (t.input.lastClick.type == "singleClick" ? i = "doubleClick" : t.input.lastClick.type == "doubleClick" && (i = "tripleClick")), t.input.lastClick = { time: r, x: n.clientX, y: n.clientY, type: i };
  let s = t.posAtCoords(ru(n));
  s && (i == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new uk(t, s, n, !!o)) : (i == "doubleClick" ? lk : ck)(t, s.pos, s.inside, n) ? n.preventDefault() : vr(t, "pointer"));
};
class uk {
  constructor(e, n, o, r) {
    this.view = e, this.pos = n, this.event = o, this.flushed = r, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!o[Pw], this.allowDefault = o.shiftKey;
    let i, s;
    if (n.inside > -1)
      i = e.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let d = e.state.doc.resolve(n.pos);
      i = d.parent, s = d.depth ? d.before() : 0;
    }
    const a = r ? null : o.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: c } = e.state;
    (o.button == 0 && i.type.spec.draggable && i.type.spec.selectable !== !1 || c instanceof de && c.from <= s && c.to > s) && (this.mightDrag = {
      node: i,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Fn && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), vr(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Po(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(ru(e))), this.updateAllowDefault(e), this.allowDefault || !n ? vr(this.view, "pointer") : ak(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Ut && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Bt && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (es(this.view, pe.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : vr(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), vr(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Wt.touchstart = (t) => {
  t.input.lastTouch = Date.now(), ym(t), vr(t, "pointer");
};
Wt.touchmove = (t) => {
  t.input.lastTouch = Date.now(), vr(t, "pointer");
};
Wt.contextmenu = (t) => ym(t);
function Lw(t, e) {
  return t.composing ? !0 : Ut && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const fk = Oo ? 5e3 : -1;
Kt.compositionstart = Kt.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof le && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((o) => o.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), Jc(t, !0), t.markCursor = null;
    else if (Jc(t, !e.selection.empty), Fn && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let o = t.domSelectionRange();
      for (let r = o.focusNode, i = o.focusOffset; r && r.nodeType == 1 && i != 0; ) {
        let s = i < 0 ? r.lastChild : r.childNodes[i - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let a = t.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else
          r = s, i = -1;
      }
    }
    t.input.composing = !0;
  }
  Nw(t, fk);
};
Kt.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, Nw(t, 20));
};
function Nw(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Jc(t), e));
}
function Bw(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = hk()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function pk(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = i5(e.focusNode, e.focusOffset), o = s5(e.focusNode, e.focusOffset);
  if (n && o && n != o) {
    let r = o.pmViewDesc, i = t.domObserver.lastChangedTextNode;
    if (n == i || o == i)
      return i;
    if (!r || !r.isText(o.nodeValue))
      return o;
    if (t.input.compositionNode == o) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return o;
    }
  }
  return n || o;
}
function hk() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Jc(t, e = !1) {
  if (!(Oo && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), Bw(t), e || t.docView && t.docView.dirty) {
      let n = pm(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !t.state.selection.empty ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function mk(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let o = getSelection(), r = document.createRange();
  r.selectNodeContents(e), t.dom.blur(), o.removeAllRanges(), o.addRange(r), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const Pa = Yt && xr < 15 || as && u5 < 604;
Wt.copy = Kt.cut = (t, e) => {
  let n = e, o = t.state.selection, r = n.type == "cut";
  if (o.empty)
    return;
  let i = Pa ? null : n.clipboardData, s = o.content(), { dom: a, text: l } = mm(t, s);
  i ? (n.preventDefault(), i.clearData(), i.setData("text/html", a.innerHTML), i.setData("text/plain", l)) : mk(t, a), r && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function gk(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function vk(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, o = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (o.contentEditable = "true"), o.style.cssText = "position: fixed; left: -10000px; top: 10px", o.focus();
  let r = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), o.parentNode && o.parentNode.removeChild(o), n ? La(t, o.value, null, r, e) : La(t, o.textContent, o.innerHTML, r, e);
  }, 50);
}
function La(t, e, n, o, r) {
  let i = Mw(t, e, n, o, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, r, i || ee.empty)))
    return !0;
  if (!i)
    return !1;
  let s = gk(i), a = s ? t.state.tr.replaceSelectionWith(s, o) : t.state.tr.replaceSelection(i);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function $w(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Kt.paste = (t, e) => {
  let n = e;
  if (t.composing && !Oo)
    return;
  let o = Pa ? null : n.clipboardData, r = t.input.shiftKey && t.input.lastKeyCode != 45;
  o && La(t, $w(o), o.getData("text/html"), r, n) ? n.preventDefault() : vk(t, n);
};
class zw {
  constructor(e, n, o) {
    this.slice = e, this.move = n, this.node = o;
  }
}
const Fw = kn ? "altKey" : "ctrlKey";
Wt.dragstart = (t, e) => {
  let n = e, o = t.input.mouseDown;
  if (o && o.done(), !n.dataTransfer)
    return;
  let r = t.state.selection, i = r.empty ? null : t.posAtCoords(ru(n)), s;
  if (!(i && i.pos >= r.from && i.pos <= (r instanceof de ? r.to - 1 : r.to))) {
    if (o && o.mightDrag)
      s = de.create(t.state.doc, o.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let u = t.docView.nearestDesc(n.target, !0);
      u && u.node.type.spec.draggable && u != t.docView && (s = de.create(t.state.doc, u.posBefore));
    }
  }
  let a = (s || t.state.selection).content(), { dom: l, text: c, slice: d } = mm(t, a);
  (!n.dataTransfer.files.length || !Bt || fw > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(Pa ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Pa || n.dataTransfer.setData("text/plain", c), t.dragging = new zw(d, !n[Fw], s);
};
Wt.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Kt.dragover = Kt.dragenter = (t, e) => e.preventDefault();
Kt.drop = (t, e) => {
  let n = e, o = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let r = t.posAtCoords(ru(n));
  if (!r)
    return;
  let i = t.state.doc.resolve(r.pos), s = o && o.slice;
  s ? t.someProp("transformPasted", (m) => {
    s = m(s, t);
  }) : s = Mw(t, $w(n.dataTransfer), Pa ? null : n.dataTransfer.getData("text/html"), !1, i);
  let a = !!(o && !n[Fw]);
  if (t.someProp("handleDrop", (m) => m(t, n, s || ee.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!s)
    return;
  n.preventDefault();
  let l = s ? rw(t.state.doc, i.pos, s) : i.pos;
  l == null && (l = i.pos);
  let c = t.state.tr;
  if (a) {
    let { node: m } = o;
    m ? m.replace(c) : c.deleteSelection();
  }
  let d = c.mapping.map(l), u = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, f = c.doc;
  if (u ? c.replaceRangeWith(d, d, s.content.firstChild) : c.replaceRange(d, d, s), c.doc.eq(f))
    return;
  let h = c.doc.resolve(d);
  if (u && de.isSelectable(s.content.firstChild) && h.nodeAfter && h.nodeAfter.sameMarkup(s.content.firstChild))
    c.setSelection(new de(h));
  else {
    let m = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((g, v, y, x) => m = x), c.setSelection(hm(t, h, c.doc.resolve(m)));
  }
  t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
};
Wt.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Po(t);
  }, 20));
};
Wt.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
Wt.beforeinput = (t, e) => {
  if (Bt && Oo && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: o } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != o || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (i) => i(t, Xr(8, "Backspace")))))
        return;
      let { $cursor: r } = t.state.selection;
      r && r.pos > 0 && t.dispatch(t.state.tr.delete(r.pos - 1, r.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Kt)
  Wt[t] = Kt[t];
function Na(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class Yc {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || ai, this.side = this.spec.side || 0;
  }
  map(e, n, o, r) {
    let { pos: i, deleted: s } = e.mapResult(n.from + r, this.side < 0 ? -1 : 1);
    return s ? null : new ht(i - o, i - o, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Yc && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Na(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Cr {
  constructor(e, n) {
    this.attrs = e, this.spec = n || ai;
  }
  map(e, n, o, r) {
    let i = e.map(n.from + r, this.spec.inclusiveStart ? -1 : 1) - o, s = e.map(n.to + r, this.spec.inclusiveEnd ? 1 : -1) - o;
    return i >= s ? null : new ht(i, s, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Cr && Na(this.attrs, e.attrs) && Na(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Cr;
  }
  destroy() {
  }
}
class bm {
  constructor(e, n) {
    this.attrs = e, this.spec = n || ai;
  }
  map(e, n, o, r) {
    let i = e.mapResult(n.from + r, 1);
    if (i.deleted)
      return null;
    let s = e.mapResult(n.to + r, -1);
    return s.deleted || s.pos <= i.pos ? null : new ht(i.pos - o, s.pos - o, this);
  }
  valid(e, n) {
    let { index: o, offset: r } = e.content.findIndex(n.from), i;
    return r == n.from && !(i = e.child(o)).isText && r + i.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof bm && Na(this.attrs, e.attrs) && Na(this.spec, e.spec);
  }
  destroy() {
  }
}
class ht {
  /**
  @internal
  */
  constructor(e, n, o) {
    this.from = e, this.to = n, this.type = o;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new ht(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, o) {
    return this.type.map(e, this, n, o);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, o) {
    return new ht(e, e, new Yc(n, o));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, o, r) {
    return new ht(e, n, new Cr(o, r));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, o, r) {
    return new ht(e, n, new bm(o, r));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Cr;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Yc;
  }
}
const ji = [], ai = {};
class ze {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : ji, this.children = n.length ? n : ji;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? Xc(n, e, 0, ai) : Nt;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, o) {
    let r = [];
    return this.findInner(e ?? 0, n ?? 1e9, r, 0, o), r;
  }
  findInner(e, n, o, r, i) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n && a.to >= e && (!i || i(a.spec)) && o.push(a.copy(a.from + r, a.to + r));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > e) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(e - a, n - a, o, r + a, i);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, o) {
    return this == Nt || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, o || ai);
  }
  /**
  @internal
  */
  mapInner(e, n, o, r, i) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, o, r);
      l && l.type.valid(n, l) ? (s || (s = [])).push(l) : i.onRemove && i.onRemove(this.local[a].spec);
    }
    return this.children.length ? yk(this.children, s || [], e, n, o, r, i) : s ? new ze(s.sort(li), ji) : Nt;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == Nt ? ze.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, o) {
    let r, i = 0;
    e.forEach((a, l) => {
      let c = l + o, d;
      if (d = Vw(n, a, c)) {
        for (r || (r = this.children.slice()); i < r.length && r[i] < l; )
          i += 3;
        r[i] == l ? r[i + 2] = r[i + 2].addInner(a, d, c + 1) : r.splice(i, 0, l, l + a.nodeSize, Xc(d, a, c + 1, ai)), i += 3;
      }
    });
    let s = Hw(i ? jw(n) : n, -o);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(e, s[a]) || s.splice(a--, 1);
    return new ze(s.length ? this.local.concat(s).sort(li) : this.local, r || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Nt ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let o = this.children, r = this.local;
    for (let i = 0; i < o.length; i += 3) {
      let s, a = o[i] + n, l = o[i + 1] + n;
      for (let d = 0, u; d < e.length; d++)
        (u = e[d]) && u.from > a && u.to < l && (e[d] = null, (s || (s = [])).push(u));
      if (!s)
        continue;
      o == this.children && (o = this.children.slice());
      let c = o[i + 2].removeInner(s, a + 1);
      c != Nt ? o[i + 2] = c : (o.splice(i, 3), i -= 3);
    }
    if (r.length) {
      for (let i = 0, s; i < e.length; i++)
        if (s = e[i])
          for (let a = 0; a < r.length; a++)
            r[a].eq(s, n) && (r == this.local && (r = this.local.slice()), r.splice(a--, 1));
    }
    return o == this.children && r == this.local ? this : r.length || o.length ? new ze(r, o) : Nt;
  }
  forChild(e, n) {
    if (this == Nt)
      return this;
    if (n.isLeaf)
      return ze.empty;
    let o, r;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (o = this.children[a + 2]);
        break;
      }
    let i = e + 1, s = i + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < s && l.to > i && l.type instanceof Cr) {
        let c = Math.max(i, l.from) - i, d = Math.min(s, l.to) - i;
        c < d && (r || (r = [])).push(l.copy(c, d));
      }
    }
    if (r) {
      let a = new ze(r.sort(li), ji);
      return o ? new dr([a, o]) : a;
    }
    return o || Nt;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof ze) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return wm(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Nt)
      return ji;
    if (e.inlineContent || !this.local.some(Cr.is))
      return this.local;
    let n = [];
    for (let o = 0; o < this.local.length; o++)
      this.local[o].type instanceof Cr || n.push(this.local[o]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
ze.empty = new ze([], []);
ze.removeOverlap = wm;
const Nt = ze.empty;
class dr {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const o = this.members.map((r) => r.map(e, n, ai));
    return dr.from(o);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return ze.empty;
    let o = [];
    for (let r = 0; r < this.members.length; r++) {
      let i = this.members[r].forChild(e, n);
      i != Nt && (i instanceof dr ? o = o.concat(i.members) : o.push(i));
    }
    return dr.from(o);
  }
  eq(e) {
    if (!(e instanceof dr) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, o = !0;
    for (let r = 0; r < this.members.length; r++) {
      let i = this.members[r].localsInner(e);
      if (i.length)
        if (!n)
          n = i;
        else {
          o && (n = n.slice(), o = !1);
          for (let s = 0; s < i.length; s++)
            n.push(i[s]);
        }
    }
    return n ? wm(o ? n : n.sort(li)) : ji;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Nt;
      case 1:
        return e[0];
      default:
        return new dr(e.every((n) => n instanceof ze) ? e : e.reduce((n, o) => n.concat(o instanceof ze ? o : o.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
}
function yk(t, e, n, o, r, i, s) {
  let a = t.slice();
  for (let c = 0, d = i; c < n.maps.length; c++) {
    let u = 0;
    n.maps[c].forEach((f, h, m, g) => {
      let v = g - m - (h - f);
      for (let y = 0; y < a.length; y += 3) {
        let x = a[y + 1];
        if (x < 0 || f > x + d - u)
          continue;
        let C = a[y] + d - u;
        h >= C ? a[y + 1] = f <= C ? -2 : -1 : f >= d && v && (a[y] += v, a[y + 1] += v);
      }
      u += v;
    }), d = n.maps[c].map(d, -1);
  }
  let l = !1;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = !0, a[c + 1] = -1;
        continue;
      }
      let d = n.map(t[c] + i), u = d - r;
      if (u < 0 || u >= o.content.size) {
        l = !0;
        continue;
      }
      let f = n.map(t[c + 1] + i, -1), h = f - r, { index: m, offset: g } = o.content.findIndex(u), v = o.maybeChild(m);
      if (v && g == u && g + v.nodeSize == h) {
        let y = a[c + 2].mapInner(n, v, d + 1, t[c] + i + 1, s);
        y != Nt ? (a[c] = u, a[c + 1] = h, a[c + 2] = y) : (a[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = bk(a, t, e, n, r, i, s), d = Xc(c, o, 0, s);
    e = d.local;
    for (let u = 0; u < a.length; u += 3)
      a[u + 1] < 0 && (a.splice(u, 3), u -= 3);
    for (let u = 0, f = 0; u < d.children.length; u += 3) {
      let h = d.children[u];
      for (; f < a.length && a[f] < h; )
        f += 3;
      a.splice(f, 0, d.children[u], d.children[u + 1], d.children[u + 2]);
    }
  }
  return new ze(e.sort(li), a);
}
function Hw(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let o = 0; o < t.length; o++) {
    let r = t[o];
    n.push(new ht(r.from + e, r.to + e, r.type));
  }
  return n;
}
function bk(t, e, n, o, r, i, s) {
  function a(l, c) {
    for (let d = 0; d < l.local.length; d++) {
      let u = l.local[d].map(o, r, c);
      u ? n.push(u) : s.onRemove && s.onRemove(l.local[d].spec);
    }
    for (let d = 0; d < l.children.length; d += 3)
      a(l.children[d + 2], l.children[d] + c + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + i + 1);
  return n;
}
function Vw(t, e, n) {
  if (e.isLeaf)
    return null;
  let o = n + e.nodeSize, r = null;
  for (let i = 0, s; i < t.length; i++)
    (s = t[i]) && s.from > n && s.to < o && ((r || (r = [])).push(s), t[i] = null);
  return r;
}
function jw(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function Xc(t, e, n, o) {
  let r = [], i = !1;
  e.forEach((a, l) => {
    let c = Vw(t, a, l + n);
    if (c) {
      i = !0;
      let d = Xc(c, a, n + l + 1, o);
      d != Nt && r.push(l, l + a.nodeSize, d);
    }
  });
  let s = Hw(i ? jw(t) : t, -n).sort(li);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(e, s[a]) || (o.onRemove && o.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || r.length ? new ze(s, r) : Nt;
}
function li(t, e) {
  return t.from - e.from || t.to - e.to;
}
function wm(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let o = e[n];
    if (o.from != o.to)
      for (let r = n + 1; r < e.length; r++) {
        let i = e[r];
        if (i.from == o.from) {
          i.to != o.to && (e == t && (e = t.slice()), e[r] = i.copy(i.from, o.to), t1(e, r + 1, i.copy(o.to, i.to)));
          continue;
        } else {
          i.from < o.to && (e == t && (e = t.slice()), e[n] = o.copy(o.from, i.from), t1(e, r, o.copy(i.from, o.to)));
          break;
        }
      }
  }
  return e;
}
function t1(t, e, n) {
  for (; e < t.length && li(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function vf(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let o = n(t.state);
    o && o != Nt && e.push(o);
  }), t.cursorWrapper && e.push(ze.create(t.state.doc, [t.cursorWrapper.deco])), dr.from(e);
}
const wk = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, xk = Yt && xr <= 11;
class kk {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class Ck {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new kk(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((o) => {
      for (let r = 0; r < o.length; r++)
        this.queue.push(o[r]);
      Yt && xr <= 11 && o.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), xk && (this.onCharData = (o) => {
      this.queue.push({ target: o.target, type: "characterData", oldValue: o.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, wk)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (q0(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Po(this.view);
      if (Yt && xr <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && pi(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), o;
    for (let i = e.focusNode; i; i = Ra(i))
      n.add(i);
    for (let i = e.anchorNode; i; i = Ra(i))
      if (n.has(i)) {
        o = i;
        break;
      }
    let r = o && this.view.docView.nearestDesc(o);
    if (r && r.ignoreMutation({
      type: "selection",
      target: o.nodeType == 3 ? o.parentNode : o
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let o = e.domSelectionRange(), r = !this.suppressingSelectionUpdates && !this.currentSelection.eq(o) && q0(e) && !this.ignoreSelectionChange(o), i = -1, s = -1, a = !1, l = [];
    if (e.editable)
      for (let d = 0; d < n.length; d++) {
        let u = this.registerMutation(n[d], l);
        u && (i = i < 0 ? u.from : Math.min(u.from, i), s = s < 0 ? u.to : Math.max(u.to, s), u.typeOver && (a = !0));
      }
    if (Fn && l.length) {
      let d = l.filter((u) => u.nodeName == "BR");
      if (d.length == 2) {
        let [u, f] = d;
        u.parentNode && u.parentNode.parentNode == f.parentNode ? f.remove() : u.remove();
      } else {
        let { focusNode: u } = this.currentSelection;
        for (let f of d) {
          let h = f.parentNode;
          h && h.nodeName == "LI" && (!u || Ek(e, u) != h) && f.remove();
        }
      }
    }
    let c = null;
    i < 0 && r && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && nu(o) && (c = pm(e)) && c.eq(pe.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Po(e), this.currentSelection.set(o)) : (i > -1 || r) && (i > -1 && (e.docView.markDirty(i, s), Sk(e)), this.handleDOMChange(i, s, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(o) || Po(e), this.currentSelection.set(o));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let o = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (o == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !o || o.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let d = 0; d < e.addedNodes.length; d++) {
        let u = e.addedNodes[d];
        n.push(u), u.nodeType == 3 && (this.lastChangedTextNode = u);
      }
      if (o.contentDOM && o.contentDOM != o.dom && !o.contentDOM.contains(e.target))
        return { from: o.posBefore, to: o.posAfter };
      let r = e.previousSibling, i = e.nextSibling;
      if (Yt && xr <= 11 && e.addedNodes.length)
        for (let d = 0; d < e.addedNodes.length; d++) {
          let { previousSibling: u, nextSibling: f } = e.addedNodes[d];
          (!u || Array.prototype.indexOf.call(e.addedNodes, u) < 0) && (r = u), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (i = f);
        }
      let s = r && r.parentNode == e.target ? Ot(r) + 1 : 0, a = o.localPosFromDOM(e.target, s, -1), l = i && i.parentNode == e.target ? Ot(i) : e.target.childNodes.length, c = o.localPosFromDOM(e.target, l, 1);
      return { from: a, to: c };
    } else
      return e.type == "attributes" ? { from: o.posAtStart - o.border, to: o.posAtEnd + o.border } : (this.lastChangedTextNode = e.target, {
        from: o.posAtStart,
        to: o.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: e.target.nodeValue == e.oldValue
      });
  }
}
let n1 = /* @__PURE__ */ new WeakMap(), o1 = !1;
function Sk(t) {
  if (!n1.has(t) && (n1.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = Fn, o1)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), o1 = !0;
  }
}
function r1(t, e) {
  let n = e.startContainer, o = e.startOffset, r = e.endContainer, i = e.endOffset, s = t.domAtPos(t.state.selection.anchor);
  return pi(s.node, s.offset, r, i) && ([n, o, r, i] = [r, i, n, o]), { anchorNode: n, anchorOffset: o, focusNode: r, focusOffset: i };
}
function Ak(t, e) {
  if (e.getComposedRanges) {
    let r = e.getComposedRanges(t.root)[0];
    if (r)
      return r1(t, r);
  }
  let n;
  function o(r) {
    r.preventDefault(), r.stopImmediatePropagation(), n = r.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", o, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", o, !0), n ? r1(t, n) : null;
}
function Ek(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let o = t.docView.nearestDesc(n, !0);
    if (o && o.node.isBlock)
      return n;
  }
  return null;
}
function _k(t, e, n) {
  let { node: o, fromOffset: r, toOffset: i, from: s, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), c, d = l.anchorNode;
  if (d && t.dom.contains(d.nodeType == 1 ? d : d.parentNode) && (c = [{ node: d, offset: l.anchorOffset }], nu(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), Bt && t.input.lastKeyCode === 8)
    for (let v = i; v > r; v--) {
      let y = o.childNodes[v - 1], x = y.pmViewDesc;
      if (y.nodeName == "BR" && !x) {
        i = v;
        break;
      }
      if (!x || x.size)
        break;
    }
  let u = t.state.doc, f = t.someProp("domParser") || la.fromSchema(t.state.schema), h = u.resolve(s), m = null, g = f.parse(o, {
    topNode: h.parent,
    topMatch: h.parent.contentMatchAt(h.index()),
    topOpen: !0,
    from: r,
    to: i,
    preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: Mk,
    context: h
  });
  if (c && c[0].pos != null) {
    let v = c[0].pos, y = c[1] && c[1].pos;
    y == null && (y = v), m = { anchor: v + s, head: y + s };
  }
  return { doc: g, sel: m, from: s, to: a };
}
function Mk(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (Ut && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || Ut && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const Tk = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function Ok(t, e, n, o, r) {
  let i = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let N = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, M = pm(t, N);
    if (M && !t.state.selection.eq(M)) {
      if (Bt && Oo && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (L) => L(t, Xr(13, "Enter"))))
        return;
      let $ = t.state.tr.setSelection(M);
      N == "pointer" ? $.setMeta("pointer", !0) : N == "key" && $.scrollIntoView(), i && $.setMeta("composition", i), t.dispatch($);
    }
    return;
  }
  let s = t.state.doc.resolve(e), a = s.sharedDepth(n);
  e = s.before(a + 1), n = t.state.doc.resolve(n).after(a + 1);
  let l = t.state.selection, c = _k(t, e, n), d = t.state.doc, u = d.slice(c.from, c.to), f, h;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, h = "end") : (f = t.state.selection.from, h = "start"), t.input.lastKeyCode = null;
  let m = Rk(u.content, c.doc.content, c.from, f, h);
  if (m && t.input.domChangeCount++, (as && t.input.lastIOSEnter > Date.now() - 225 || Oo) && r.some((N) => N.nodeType == 1 && !Tk.test(N.nodeName)) && (!m || m.endA >= m.endB) && t.someProp("handleKeyDown", (N) => N(t, Xr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!m)
    if (o && l instanceof le && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(c.sel && c.sel.anchor != c.sel.head))
      m = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let N = i1(t, t.state.doc, c.sel);
        if (N && !N.eq(t.state.selection)) {
          let M = t.state.tr.setSelection(N);
          i && M.setMeta("composition", i), t.dispatch(M);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && m.start == m.endB && t.state.selection instanceof le && (m.start > t.state.selection.from && m.start <= t.state.selection.from + 2 && t.state.selection.from >= c.from ? m.start = t.state.selection.from : m.endA < t.state.selection.to && m.endA >= t.state.selection.to - 2 && t.state.selection.to <= c.to && (m.endB += t.state.selection.to - m.endA, m.endA = t.state.selection.to)), Yt && xr <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > c.from && c.doc.textBetween(m.start - c.from - 1, m.start - c.from + 1) == "  " && (m.start--, m.endA--, m.endB--);
  let g = c.doc.resolveNoCache(m.start - c.from), v = c.doc.resolveNoCache(m.endB - c.from), y = d.resolve(m.start), x = g.sameParent(v) && g.parent.inlineContent && y.end() >= m.endA, C;
  if ((as && t.input.lastIOSEnter > Date.now() - 225 && (!x || r.some((N) => N.nodeName == "DIV" || N.nodeName == "P")) || !x && g.pos < c.doc.content.size && !g.sameParent(v) && (C = pe.findFrom(c.doc.resolve(g.pos + 1), 1, !0)) && C.head == v.pos) && t.someProp("handleKeyDown", (N) => N(t, Xr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > m.start && Dk(d, m.start, m.endA, g, v) && t.someProp("handleKeyDown", (N) => N(t, Xr(8, "Backspace")))) {
    Oo && Bt && t.domObserver.suppressSelectionUpdates();
    return;
  }
  Bt && m.endB == m.start && (t.input.lastChromeDelete = Date.now()), Oo && !x && g.start() != v.start() && v.parentOffset == 0 && g.depth == v.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == m.endA && (m.endB -= 2, v = c.doc.resolveNoCache(m.endB - c.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(N) {
      return N(t, Xr(13, "Enter"));
    });
  }, 20));
  let b = m.start, S = m.endA, A, I, z;
  if (x) {
    if (g.pos == v.pos)
      Yt && xr <= 11 && g.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Po(t), 20)), A = t.state.tr.delete(b, S), I = d.resolve(m.start).marksAcross(d.resolve(m.endA));
    else if (
      // Adding or removing a mark
      m.endA == m.endB && (z = Ik(g.parent.content.cut(g.parentOffset, v.parentOffset), y.parent.content.cut(y.parentOffset, m.endA - y.start())))
    )
      A = t.state.tr, z.type == "add" ? A.addMark(b, S, z.mark) : A.removeMark(b, S, z.mark);
    else if (g.parent.child(g.index()).isText && g.index() == v.index() - (v.textOffset ? 0 : 1)) {
      let N = g.parent.textBetween(g.parentOffset, v.parentOffset);
      if (t.someProp("handleTextInput", (M) => M(t, b, S, N)))
        return;
      A = t.state.tr.insertText(N, b, S);
    }
  }
  if (A || (A = t.state.tr.replace(b, S, c.doc.slice(m.start - c.from, m.endB - c.from))), c.sel) {
    let N = i1(t, A.doc, c.sel);
    N && !(Bt && t.composing && N.empty && (m.start != m.endB || t.input.lastChromeDelete < Date.now() - 100) && (N.head == b || N.head == A.mapping.map(S) - 1) || Yt && N.empty && N.head == b) && A.setSelection(N);
  }
  I && A.ensureMarks(I), i && A.setMeta("composition", i), t.dispatch(A.scrollIntoView());
}
function i1(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : hm(t, e.resolve(n.anchor), e.resolve(n.head));
}
function Ik(t, e) {
  let n = t.firstChild.marks, o = e.firstChild.marks, r = n, i = o, s, a, l;
  for (let d = 0; d < o.length; d++)
    r = o[d].removeFromSet(r);
  for (let d = 0; d < n.length; d++)
    i = n[d].removeFromSet(i);
  if (r.length == 1 && i.length == 0)
    a = r[0], s = "add", l = (d) => d.mark(a.addToSet(d.marks));
  else if (r.length == 0 && i.length == 1)
    a = i[0], s = "remove", l = (d) => d.mark(a.removeFromSet(d.marks));
  else
    return null;
  let c = [];
  for (let d = 0; d < e.childCount; d++)
    c.push(l(e.child(d)));
  if (W.from(c).eq(t))
    return { mark: a, type: s };
}
function Dk(t, e, n, o, r) {
  if (
    // The content must have shrunk
    n - e <= r.pos - o.pos || // newEnd must point directly at or after the end of the block that newStart points into
    yf(o, !0, !1) < r.pos
  )
    return !1;
  let i = t.resolve(e);
  if (!o.parent.isTextblock) {
    let a = i.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
    return !1;
  let s = t.resolve(yf(i, !0, !0));
  return !s.parent.isTextblock || s.pos > n || yf(s, !0, !1) < n ? !1 : o.parent.content.cut(o.parentOffset).eq(s.parent.content);
}
function yf(t, e, n) {
  let o = t.depth, r = e ? t.end() : t.pos;
  for (; o > 0 && (e || t.indexAfter(o) == t.node(o).childCount); )
    o--, r++, e = !1;
  if (n) {
    let i = t.node(o).maybeChild(t.indexAfter(o));
    for (; i && !i.isLeaf; )
      i = i.firstChild, r++;
  }
  return r;
}
function Rk(t, e, n, o, r) {
  let i = t.findDiffStart(e, n);
  if (i == null)
    return null;
  let { a: s, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (r == "end") {
    let l = Math.max(0, i - Math.min(s, a));
    o -= s + l - i;
  }
  if (s < i && t.size < e.size) {
    let l = o <= i && o >= s ? i - o : 0;
    i -= l, i && i < e.size && s1(e.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), a = i + (a - s), s = i;
  } else if (a < i) {
    let l = o <= i && o >= a ? i - o : 0;
    i -= l, i && i < t.size && s1(t.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), s = i + (s - a), a = i;
  }
  return { start: i, endA: s, endB: a };
}
function s1(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class Pk {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new Q5(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(u1), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = c1(this), l1(this), this.nodeViews = d1(this), this.docView = H0(this.state.doc, a1(this), vf(this), this.dom, this), this.domObserver = new Ck(this, (o, r, i, s) => Ok(this, o, r, i, s)), this.domObserver.start(), ek(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Bp(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(u1), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let o in this._props)
      n[o] = this._props[o];
    n.state = this.state;
    for (let o in e)
      n[o] = e[o];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var o;
    let r = this.state, i = !1, s = !1;
    e.storedMarks && this.composing && (Bw(this), s = !0), this.state = e;
    let a = r.plugins != e.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let h = d1(this);
      Nk(h, this.nodeViews) && (this.nodeViews = h, i = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && Bp(this), this.editable = c1(this), l1(this);
    let l = vf(this), c = a1(this), d = r.plugins != e.plugins && !r.doc.eq(e.doc) ? "reset" : e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve", u = i || !this.docView.matchesNode(e.doc, c, l);
    (u || !e.selection.eq(r.selection)) && (s = !0);
    let f = d == "preserve" && s && this.dom.style.overflowAnchor == null && h5(this);
    if (s) {
      this.domObserver.stop();
      let h = u && (Yt || Bt) && !this.composing && !r.selection.empty && !e.selection.empty && Lk(r.selection, e.selection);
      if (u) {
        let m = Bt ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = pk(this)), (i || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = H0(e.doc, c, l, this.dom, this)), m && !this.trackWrites && (h = !0);
      }
      h || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && $5(this)) ? Po(this, h) : (Aw(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(r), !((o = this.dragging) === null || o === void 0) && o.node && !r.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, r), d == "reset" ? this.dom.scrollTop = 0 : d == "to selection" ? this.scrollToSelection() : f && m5(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this)))
        if (this.state.selection instanceof de) {
          let n = this.docView.domAfterPos(this.state.selection.from);
          n.nodeType == 1 && L0(this, n.getBoundingClientRect(), e);
        } else
          L0(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let o = this.directPlugins[n];
        o.spec.view && this.pluginViews.push(o.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let o = this.state.plugins[n];
        o.spec.view && this.pluginViews.push(o.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let o = this.pluginViews[n];
        o.update && o.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let o = e.node, r = -1;
    if (this.state.doc.nodeAt(o.from) == o.node)
      r = o.from;
    else {
      let i = o.from + (this.state.doc.content.size - n.doc.content.size);
      (i > 0 && this.state.doc.nodeAt(i)) == o.node && (r = i);
    }
    this.dragging = new zw(e.slice, e.move, r < 0 ? void 0 : de.create(this.state.doc, r));
  }
  someProp(e, n) {
    let o = this._props && this._props[e], r;
    if (o != null && (r = n ? n(o) : o))
      return r;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[e];
      if (a != null && (r = n ? n(a) : a))
        return r;
    }
    let i = this.state.plugins;
    if (i)
      for (let s = 0; s < i.length; s++) {
        let a = i[s].props[e];
        if (a != null && (r = n ? n(a) : a))
          return r;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Yt) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && g5(this.dom), Po(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return x5(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return vw(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, o = -1) {
    let r = this.docView.posFromDOM(e, n, o);
    if (r == null)
      throw new RangeError("DOM position not inside the editor");
    return r;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return E5(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return La(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return La(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return mm(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (tk(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], vf(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, o5());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return ok(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Ut && this.root.nodeType === 11 && l5(this.dom.ownerDocument) == this.dom && Ak(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function a1(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let o in n)
        o == "class" ? e.class += " " + n[o] : o == "style" ? e.style = (e.style ? e.style + ";" : "") + n[o] : !e[o] && o != "contenteditable" && o != "nodeName" && (e[o] = String(n[o]));
  }), e.translate || (e.translate = "no"), [ht.node(0, t.state.doc.content.size, e)];
}
function l1(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: ht.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function c1(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function Lk(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function d1(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(o) {
    for (let r in o)
      Object.prototype.hasOwnProperty.call(e, r) || (e[r] = o[r]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function Nk(t, e) {
  let n = 0, o = 0;
  for (let r in t) {
    if (t[r] != e[r])
      return !0;
    n++;
  }
  for (let r in e)
    o++;
  return n != o;
}
function u1(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Ar = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Zc = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, Bk = typeof navigator < "u" && /Mac/.test(navigator.platform), $k = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var It = 0; It < 10; It++)
  Ar[48 + It] = Ar[96 + It] = String(It);
for (var It = 1; It <= 24; It++)
  Ar[It + 111] = "F" + It;
for (var It = 65; It <= 90; It++)
  Ar[It] = String.fromCharCode(It + 32), Zc[It] = String.fromCharCode(It);
for (var bf in Ar)
  Zc.hasOwnProperty(bf) || (Zc[bf] = Ar[bf]);
function zk(t) {
  var e = Bk && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || $k && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Zc : Ar)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const Fk = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function Hk(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let o, r, i, s;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      o = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      i = !0;
    else if (/^mod$/i.test(l))
      Fk ? s = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return o && (n = "Alt-" + n), r && (n = "Ctrl-" + n), s && (n = "Meta-" + n), i && (n = "Shift-" + n), n;
}
function Vk(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[Hk(n)] = t[n];
  return e;
}
function wf(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function jk(t) {
  return new Ne({ props: { handleKeyDown: xm(t) } });
}
function xm(t) {
  let e = Vk(t);
  return function(n, o) {
    let r = zk(o), i, s = e[wf(r, o)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (r.length == 1 && r != " ") {
      if (o.shiftKey) {
        let a = e[wf(r, o, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((o.shiftKey || o.altKey || o.metaKey || r.charCodeAt(0) > 127) && (i = Ar[o.keyCode]) && i != r) {
        let a = e[wf(i, o)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const km = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function Uw(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const Uk = (t, e, n) => {
  let o = Uw(t, n);
  if (!o)
    return !1;
  let r = Cm(o);
  if (!r) {
    let s = o.blockRange(), a = s && Ss(s);
    return a == null ? !1 : (e && e(t.tr.lift(s, a).scrollIntoView()), !0);
  }
  let i = r.nodeBefore;
  if (Gw(t, r, e, -1))
    return !0;
  if (o.parent.content.size == 0 && (ls(i, "end") || de.isSelectable(i)))
    for (let s = o.depth; ; s--) {
      let a = eu(t.doc, o.before(s), o.after(s), ee.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = t.tr.step(a);
          l.setSelection(ls(i, "end") ? pe.findFrom(l.doc.resolve(l.mapping.map(r.pos, -1)), -1) : de.create(l.doc, r.pos - i.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || o.node(s - 1).childCount > 1)
        break;
    }
  return i.isAtom && r.depth == o.depth - 1 ? (e && e(t.tr.delete(r.pos - i.nodeSize, r.pos).scrollIntoView()), !0) : !1;
}, Wk = (t, e, n) => {
  let o = Uw(t, n);
  if (!o)
    return !1;
  let r = Cm(o);
  return r ? Ww(t, r, e) : !1;
}, Kk = (t, e, n) => {
  let o = Kw(t, n);
  if (!o)
    return !1;
  let r = Sm(o);
  return r ? Ww(t, r, e) : !1;
};
function Ww(t, e, n) {
  let o = e.nodeBefore, r = o, i = e.pos - 1;
  for (; !r.isTextblock; i--) {
    if (r.type.spec.isolating)
      return !1;
    let d = r.lastChild;
    if (!d)
      return !1;
    r = d;
  }
  let s = e.nodeAfter, a = s, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let d = a.firstChild;
    if (!d)
      return !1;
    a = d;
  }
  let c = eu(t.doc, i, l, ee.empty);
  if (!c || c.from != i || c instanceof xt && c.slice.size >= l - i)
    return !1;
  if (n) {
    let d = t.tr.step(c);
    d.setSelection(le.create(d.doc, i)), n(d.scrollIntoView());
  }
  return !0;
}
function ls(t, e, n = !1) {
  for (let o = t; o; o = e == "start" ? o.firstChild : o.lastChild) {
    if (o.isTextblock)
      return !0;
    if (n && o.childCount != 1)
      return !1;
  }
  return !1;
}
const qk = (t, e, n) => {
  let { $head: o, empty: r } = t.selection, i = o;
  if (!r)
    return !1;
  if (o.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : o.parentOffset > 0)
      return !1;
    i = Cm(o);
  }
  let s = i && i.nodeBefore;
  return !s || !de.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(de.create(t.doc, i.pos - s.nodeSize)).scrollIntoView()), !0);
};
function Cm(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function Kw(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const Gk = (t, e, n) => {
  let o = Kw(t, n);
  if (!o)
    return !1;
  let r = Sm(o);
  if (!r)
    return !1;
  let i = r.nodeAfter;
  if (Gw(t, r, e, 1))
    return !0;
  if (o.parent.content.size == 0 && (ls(i, "start") || de.isSelectable(i))) {
    let s = eu(t.doc, o.before(), o.after(), ee.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (e) {
        let a = t.tr.step(s);
        a.setSelection(ls(i, "start") ? pe.findFrom(a.doc.resolve(a.mapping.map(r.pos)), 1) : de.create(a.doc, a.mapping.map(r.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return i.isAtom && r.depth == o.depth - 1 ? (e && e(t.tr.delete(r.pos, r.pos + i.nodeSize).scrollIntoView()), !0) : !1;
}, Jk = (t, e, n) => {
  let { $head: o, empty: r } = t.selection, i = o;
  if (!r)
    return !1;
  if (o.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : o.parentOffset < o.parent.content.size)
      return !1;
    i = Sm(o);
  }
  let s = i && i.nodeAfter;
  return !s || !de.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(de.create(t.doc, i.pos)).scrollIntoView()), !0);
};
function Sm(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const Yk = (t, e) => {
  let n = t.selection, o = n instanceof de, r;
  if (o) {
    if (n.node.isTextblock || !Br(t.doc, n.from))
      return !1;
    r = n.from;
  } else if (r = Qd(t.doc, n.from, -1), r == null)
    return !1;
  if (e) {
    let i = t.tr.join(r);
    o && i.setSelection(de.create(i.doc, r - t.doc.resolve(r).nodeBefore.nodeSize)), e(i.scrollIntoView());
  }
  return !0;
}, Xk = (t, e) => {
  let n = t.selection, o;
  if (n instanceof de) {
    if (n.node.isTextblock || !Br(t.doc, n.to))
      return !1;
    o = n.to;
  } else if (o = Qd(t.doc, n.to, 1), o == null)
    return !1;
  return e && e(t.tr.join(o).scrollIntoView()), !0;
}, Zk = (t, e) => {
  let { $from: n, $to: o } = t.selection, r = n.blockRange(o), i = r && Ss(r);
  return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
}, Qk = (t, e) => {
  let { $head: n, $anchor: o } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(o) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function qw(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const eC = (t, e) => {
  let { $head: n, $anchor: o } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(o))
    return !1;
  let r = n.node(-1), i = n.indexAfter(-1), s = qw(r.contentMatchAt(i));
  if (!s || !r.canReplaceWith(i, i, s))
    return !1;
  if (e) {
    let a = n.after(), l = t.tr.replaceWith(a, a, s.createAndFill());
    l.setSelection(pe.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, tC = (t, e) => {
  let n = t.selection, { $from: o, $to: r } = n;
  if (n instanceof Jt || o.parent.inlineContent || r.parent.inlineContent)
    return !1;
  let i = qw(r.parent.contentMatchAt(r.indexAfter()));
  if (!i || !i.isTextblock)
    return !1;
  if (e) {
    let s = (!o.parentOffset && r.index() < r.parent.childCount ? o : r).pos, a = t.tr.insert(s, i.createAndFill());
    a.setSelection(le.create(a.doc, s + 1)), e(a.scrollIntoView());
  }
  return !0;
}, nC = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let i = n.before();
    if (Zi(t.doc, i))
      return e && e(t.tr.split(i).scrollIntoView()), !0;
  }
  let o = n.blockRange(), r = o && Ss(o);
  return r == null ? !1 : (e && e(t.tr.lift(o, r).scrollIntoView()), !0);
}, oC = (t, e) => {
  let { $from: n, to: o } = t.selection, r, i = n.sharedDepth(o);
  return i == 0 ? !1 : (r = n.before(i), e && e(t.tr.setSelection(de.create(t.doc, r))), !0);
};
function rC(t, e, n) {
  let o = e.nodeBefore, r = e.nodeAfter, i = e.index();
  return !o || !r || !o.type.compatibleContent(r.type) ? !1 : !o.content.size && e.parent.canReplace(i - 1, i) ? (n && n(t.tr.delete(e.pos - o.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(i, i + 1) || !(r.isTextblock || Br(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function Gw(t, e, n, o) {
  let r = e.nodeBefore, i = e.nodeAfter, s, a, l = r.type.spec.isolating || i.type.spec.isolating;
  if (!l && rC(t, e, n))
    return !0;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (s = (a = r.contentMatchAt(r.childCount)).findWrapping(i.type)) && a.matchType(s[0] || i.type).validEnd) {
    if (n) {
      let h = e.pos + i.nodeSize, m = W.empty;
      for (let y = s.length - 1; y >= 0; y--)
        m = W.from(s[y].create(null, m));
      m = W.from(r.copy(m));
      let g = t.tr.step(new kt(e.pos - 1, h, e.pos, h, new ee(m, 1, 0), s.length, !0)), v = g.doc.resolve(h + 2 * s.length);
      v.nodeAfter && v.nodeAfter.type == r.type && Br(g.doc, v.pos) && g.join(v.pos), n(g.scrollIntoView());
    }
    return !0;
  }
  let d = i.type.spec.isolating || o > 0 && l ? null : pe.findFrom(e, 1), u = d && d.$from.blockRange(d.$to), f = u && Ss(u);
  if (f != null && f >= e.depth)
    return n && n(t.tr.lift(u, f).scrollIntoView()), !0;
  if (c && ls(i, "start", !0) && ls(r, "end")) {
    let h = r, m = [];
    for (; m.push(h), !h.isTextblock; )
      h = h.lastChild;
    let g = i, v = 1;
    for (; !g.isTextblock; g = g.firstChild)
      v++;
    if (h.canReplace(h.childCount, h.childCount, g.content)) {
      if (n) {
        let y = W.empty;
        for (let C = m.length - 1; C >= 0; C--)
          y = W.from(m[C].copy(y));
        let x = t.tr.step(new kt(e.pos - m.length, e.pos + i.nodeSize, e.pos + v, e.pos + i.nodeSize - v, new ee(y, m.length, 0), 0, !0));
        n(x.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function Jw(t) {
  return function(e, n) {
    let o = e.selection, r = t < 0 ? o.$from : o.$to, i = r.depth;
    for (; r.node(i).isInline; ) {
      if (!i)
        return !1;
      i--;
    }
    return r.node(i).isTextblock ? (n && n(e.tr.setSelection(le.create(e.doc, t < 0 ? r.start(i) : r.end(i)))), !0) : !1;
  };
}
const iC = Jw(-1), sC = Jw(1);
function aC(t, e = null) {
  return function(n, o) {
    let { $from: r, $to: i } = n.selection, s = r.blockRange(i), a = s && lm(s, t, e);
    return a ? (o && o(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function f1(t, e = null) {
  return function(n, o) {
    let r = !1;
    for (let i = 0; i < n.selection.ranges.length && !r; i++) {
      let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[i];
      n.doc.nodesBetween(s, a, (l, c) => {
        if (r)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            r = !0;
          else {
            let d = n.doc.resolve(c), u = d.index();
            r = d.parent.canReplaceWith(u, u + 1, t);
          }
      });
    }
    if (!r)
      return !1;
    if (o) {
      let i = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[s];
        i.setBlockType(a, l, t, e);
      }
      o(i.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function lC(t, e = null) {
  return function(n, o) {
    let { $from: r, $to: i } = n.selection, s = r.blockRange(i), a = !1, l = s;
    if (!s)
      return !1;
    if (s.depth >= 2 && r.node(s.depth - 1).type.compatibleContent(t) && s.startIndex == 0) {
      if (r.index(s.depth - 1) == 0)
        return !1;
      let d = n.doc.resolve(s.start - 2);
      l = new Oa(d, d, s.depth), s.endIndex < s.parent.childCount && (s = new Oa(r, n.doc.resolve(i.end(s.depth)), s.depth)), a = !0;
    }
    let c = lm(l, t, e, s);
    return c ? (o && o(cC(n.tr, s, c, a, t).scrollIntoView()), !0) : !1;
  };
}
function cC(t, e, n, o, r) {
  let i = W.empty;
  for (let d = n.length - 1; d >= 0; d--)
    i = W.from(n[d].type.create(n[d].attrs, i));
  t.step(new kt(e.start - (o ? 2 : 0), e.end, e.start, e.end, new ee(i, 0, 0), n.length, !0));
  let s = 0;
  for (let d = 0; d < n.length; d++)
    n[d].type == r && (s = d + 1);
  let a = n.length - s, l = e.start + n.length - (o ? 2 : 0), c = e.parent;
  for (let d = e.startIndex, u = e.endIndex, f = !0; d < u; d++, f = !1)
    !f && Zi(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += c.child(d).nodeSize;
  return t;
}
function dC(t) {
  return function(e, n) {
    let { $from: o, $to: r } = e.selection, i = o.blockRange(r, (s) => s.childCount > 0 && s.firstChild.type == t);
    return i ? n ? o.node(i.depth - 1).type == t ? uC(e, n, t, i) : fC(e, n, i) : !0 : !1;
  };
}
function uC(t, e, n, o) {
  let r = t.tr, i = o.end, s = o.$to.end(o.depth);
  i < s && (r.step(new kt(i - 1, s, i, s, new ee(W.from(n.create(null, o.parent.copy())), 1, 0), 1, !0)), o = new Oa(r.doc.resolve(o.$from.pos), r.doc.resolve(s), o.depth));
  const a = Ss(o);
  if (a == null)
    return !1;
  r.lift(o, a);
  let l = r.mapping.map(i, -1) - 1;
  return Br(r.doc, l) && r.join(l), e(r.scrollIntoView()), !0;
}
function fC(t, e, n) {
  let o = t.tr, r = n.parent;
  for (let h = n.end, m = n.endIndex - 1, g = n.startIndex; m > g; m--)
    h -= r.child(m).nodeSize, o.delete(h - 1, h + 1);
  let i = o.doc.resolve(n.start), s = i.nodeAfter;
  if (o.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == r.childCount, c = i.node(-1), d = i.index(-1);
  if (!c.canReplace(d + (a ? 0 : 1), d + 1, s.content.append(l ? W.empty : W.from(r))))
    return !1;
  let u = i.pos, f = u + s.nodeSize;
  return o.step(new kt(u - (a ? 1 : 0), f + (l ? 1 : 0), u + 1, f - 1, new ee((a ? W.empty : W.from(r.copy(W.empty))).append(l ? W.empty : W.from(r.copy(W.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(o.scrollIntoView()), !0;
}
function pC(t) {
  return function(e, n) {
    let { $from: o, $to: r } = e.selection, i = o.blockRange(r, (c) => c.childCount > 0 && c.firstChild.type == t);
    if (!i)
      return !1;
    let s = i.startIndex;
    if (s == 0)
      return !1;
    let a = i.parent, l = a.child(s - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let c = l.lastChild && l.lastChild.type == a.type, d = W.from(c ? t.create() : null), u = new ee(W.from(t.create(null, W.from(a.type.create(null, d)))), c ? 3 : 1, 0), f = i.start, h = i.end;
      n(e.tr.step(new kt(f - (c ? 3 : 1), h, f, h, u, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function iu(t) {
  const { state: e, transaction: n } = t;
  let { selection: o } = n, { doc: r } = n, { storedMarks: i } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return i;
    },
    get selection() {
      return o;
    },
    get doc() {
      return r;
    },
    get tr() {
      return o = n.selection, r = n.doc, i = n.storedMarks, n;
    }
  };
}
class su {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: o } = this, { view: r } = n, { tr: i } = o, s = this.buildProps(i);
    return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...d) => {
      const u = l(...d)(s);
      return !i.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(i), u;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: o, editor: r, state: i } = this, { view: s } = r, a = [], l = !!e, c = e || i.tr, d = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(c), a.every((f) => f === !0)), u = {
      ...Object.fromEntries(Object.entries(o).map(([f, h]) => [f, (...g) => {
        const v = this.buildProps(c, n), y = h(...g)(v);
        return a.push(y), u;
      }])),
      run: d
    };
    return u;
  }
  createCan(e) {
    const { rawCommands: n, state: o } = this, r = !1, i = e || o.tr, s = this.buildProps(i, r);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, c]) => [l, (...d) => c(...d)({ ...s, dispatch: void 0 })])),
      chain: () => this.createChain(i, r)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: o, editor: r, state: i } = this, { view: s } = r, a = {
      tr: e,
      editor: r,
      view: s,
      state: iu({
        state: i,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(o).map(([l, c]) => [l, (...d) => c(...d)(a)]));
      }
    };
    return a;
  }
}
class hC {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const o = this.callbacks[e];
    return o && o.forEach((r) => r.apply(this, n)), this;
  }
  off(e, n) {
    const o = this.callbacks[e];
    return o && (n ? this.callbacks[e] = o.filter((r) => r !== n) : delete this.callbacks[e]), this;
  }
  once(e, n) {
    const o = (...r) => {
      this.off(e, o), n.apply(this, r);
    };
    return this.on(e, o);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function oe(t, e, n) {
  return t.config[e] === void 0 && t.parent ? oe(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? oe(t.parent, e, n) : null
  }) : t.config[e];
}
function au(t) {
  const e = t.filter((r) => r.type === "extension"), n = t.filter((r) => r.type === "node"), o = t.filter((r) => r.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: o
  };
}
function Yw(t) {
  const e = [], { nodeExtensions: n, markExtensions: o } = au(t), r = [...n, ...o], i = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: r
    }, l = oe(s, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((d) => {
      d.types.forEach((u) => {
        Object.entries(d.attributes).forEach(([f, h]) => {
          e.push({
            type: u,
            name: f,
            attribute: {
              ...i,
              ...h
            }
          });
        });
      });
    });
  }), r.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, l = oe(s, "addAttributes", a);
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([d, u]) => {
      const f = {
        ...i,
        ...u
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({
        type: s.name,
        name: d,
        attribute: f
      });
    });
  }), e;
}
function St(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function He(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const o = { ...e };
    return Object.entries(n).forEach(([r, i]) => {
      if (!o[r]) {
        o[r] = i;
        return;
      }
      if (r === "class") {
        const a = i ? String(i).split(" ") : [], l = o[r] ? o[r].split(" ") : [], c = a.filter((d) => !l.includes(d));
        o[r] = [...l, ...c].join(" ");
      } else if (r === "style") {
        const a = i ? i.split(";").map((d) => d.trim()).filter(Boolean) : [], l = o[r] ? o[r].split(";").map((d) => d.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        l.forEach((d) => {
          const [u, f] = d.split(":").map((h) => h.trim());
          c.set(u, f);
        }), a.forEach((d) => {
          const [u, f] = d.split(":").map((h) => h.trim());
          c.set(u, f);
        }), o[r] = Array.from(c.entries()).map(([d, u]) => `${d}: ${u}`).join("; ");
      } else
        o[r] = i;
    }), o;
  }, {});
}
function $p(t, e) {
  return e.filter((n) => n.type === t.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, o) => He(n, o), {});
}
function Xw(t) {
  return typeof t == "function";
}
function Ee(t, e = void 0, ...n) {
  return Xw(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function mC(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function gC(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function p1(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const o = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (o === !1)
        return !1;
      const r = e.reduce((i, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : gC(n.getAttribute(s.name));
        return a == null ? i : {
          ...i,
          [s.name]: a
        };
      }, {});
      return { ...o, ...r };
    }
  };
}
function h1(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && mC(n) ? !1 : n != null)
  );
}
function vC(t, e) {
  var n;
  const o = Yw(t), { nodeExtensions: r, markExtensions: i } = au(t), s = (n = r.find((c) => oe(c, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(r.map((c) => {
    const d = o.filter((y) => y.type === c.name), u = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((y, x) => {
      const C = oe(x, "extendNodeSchema", u);
      return {
        ...y,
        ...C ? C(c) : {}
      };
    }, {}), h = h1({
      ...f,
      content: Ee(oe(c, "content", u)),
      marks: Ee(oe(c, "marks", u)),
      group: Ee(oe(c, "group", u)),
      inline: Ee(oe(c, "inline", u)),
      atom: Ee(oe(c, "atom", u)),
      selectable: Ee(oe(c, "selectable", u)),
      draggable: Ee(oe(c, "draggable", u)),
      code: Ee(oe(c, "code", u)),
      whitespace: Ee(oe(c, "whitespace", u)),
      linebreakReplacement: Ee(oe(c, "linebreakReplacement", u)),
      defining: Ee(oe(c, "defining", u)),
      isolating: Ee(oe(c, "isolating", u)),
      attrs: Object.fromEntries(d.map((y) => {
        var x;
        return [y.name, { default: (x = y == null ? void 0 : y.attribute) === null || x === void 0 ? void 0 : x.default }];
      }))
    }), m = Ee(oe(c, "parseHTML", u));
    m && (h.parseDOM = m.map((y) => p1(y, d)));
    const g = oe(c, "renderHTML", u);
    g && (h.toDOM = (y) => g({
      node: y,
      HTMLAttributes: $p(y, d)
    }));
    const v = oe(c, "renderText", u);
    return v && (h.toText = v), [c.name, h];
  })), l = Object.fromEntries(i.map((c) => {
    const d = o.filter((v) => v.type === c.name), u = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((v, y) => {
      const x = oe(y, "extendMarkSchema", u);
      return {
        ...v,
        ...x ? x(c) : {}
      };
    }, {}), h = h1({
      ...f,
      inclusive: Ee(oe(c, "inclusive", u)),
      excludes: Ee(oe(c, "excludes", u)),
      group: Ee(oe(c, "group", u)),
      spanning: Ee(oe(c, "spanning", u)),
      code: Ee(oe(c, "code", u)),
      attrs: Object.fromEntries(d.map((v) => {
        var y;
        return [v.name, { default: (y = v == null ? void 0 : v.attribute) === null || y === void 0 ? void 0 : y.default }];
      }))
    }), m = Ee(oe(c, "parseHTML", u));
    m && (h.parseDOM = m.map((v) => p1(v, d)));
    const g = oe(c, "renderHTML", u);
    return g && (h.toDOM = (v) => g({
      mark: v,
      HTMLAttributes: $p(v, d)
    })), [c.name, h];
  }));
  return new qb({
    topNode: s,
    nodes: a,
    marks: l
  });
}
function xf(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function m1(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
function Am(t, e) {
  const n = Nr.fromSchema(e).serializeFragment(t), r = document.implementation.createHTMLDocument().createElement("div");
  return r.appendChild(n), r.innerHTML;
}
const yC = (t, e = 500) => {
  let n = "";
  const o = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, o - e), o, (r, i, s, a) => {
    var l, c;
    const d = ((c = (l = r.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, {
      node: r,
      pos: i,
      parent: s,
      index: a
    })) || r.textContent || "%leaf%";
    n += r.isAtom && !r.isText ? d : d.slice(0, Math.max(0, o - i));
  }), n;
};
function Em(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class lu {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const bC = (t, e) => {
  if (Em(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const o = [n.text];
  return o.index = n.index, o.input = t, o.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), o.push(n.replaceWith)), o;
};
function Fl(t) {
  var e;
  const { editor: n, from: o, to: r, text: i, rules: s, plugin: a } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const c = l.state.doc.resolve(o);
  if (
    // check for code node
    c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let d = !1;
  const u = yC(c) + i;
  return s.forEach((f) => {
    if (d)
      return;
    const h = bC(u, f.find);
    if (!h)
      return;
    const m = l.state.tr, g = iu({
      state: l.state,
      transaction: m
    }), v = {
      from: o - (h[0].length - i.length),
      to: r
    }, { commands: y, chain: x, can: C } = new su({
      editor: n,
      state: g
    });
    f.handler({
      state: g,
      range: v,
      match: h,
      commands: y,
      chain: x,
      can: C
    }) === null || !m.steps.length || (m.setMeta(a, {
      transform: m,
      from: o,
      to: r,
      text: i
    }), l.dispatch(m), d = !0);
  }), d;
}
function wC(t) {
  const { editor: e, rules: n } = t, o = new Ne({
    state: {
      init() {
        return null;
      },
      apply(r, i, s) {
        const a = r.getMeta(o);
        if (a)
          return a;
        const l = r.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: d } = l;
          typeof d == "string" ? d = d : d = Am(W.from(d), s.schema);
          const { from: u } = l, f = u + d.length;
          Fl({
            editor: e,
            from: u,
            to: f,
            text: d,
            rules: n,
            plugin: o
          });
        }), r.selectionSet || r.docChanged ? null : i;
      }
    },
    props: {
      handleTextInput(r, i, s, a) {
        return Fl({
          editor: e,
          from: i,
          to: s,
          text: a,
          rules: n,
          plugin: o
        });
      },
      handleDOMEvents: {
        compositionend: (r) => (setTimeout(() => {
          const { $cursor: i } = r.state.selection;
          i && Fl({
            editor: e,
            from: i.pos,
            to: i.pos,
            text: "",
            rules: n,
            plugin: o
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(r, i) {
        if (i.key !== "Enter")
          return !1;
        const { $cursor: s } = r.state.selection;
        return s ? Fl({
          editor: e,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: o
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return o;
}
function xC(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function Hl(t) {
  return xC(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function cu(t, e) {
  const n = { ...t };
  return Hl(t) && Hl(e) && Object.keys(e).forEach((o) => {
    Hl(e[o]) && Hl(t[o]) ? n[o] = cu(t[o], e[o]) : n[o] = e[o];
  }), n;
}
class Qt {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ee(oe(this, "addOptions", {
      name: this.name
    }))), this.storage = Ee(oe(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Qt(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => cu(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Qt(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Ee(oe(n, "addOptions", {
      name: n.name
    })), n.storage = Ee(oe(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: o } = e.state, r = e.state.selection.$from;
    if (r.pos === r.end()) {
      const s = r.marks();
      if (!!!s.find((c) => (c == null ? void 0 : c.type.name) === n.name))
        return !1;
      const l = s.find((c) => (c == null ? void 0 : c.type.name) === n.name);
      return l && o.removeStoredMark(l), o.insertText(" ", r.pos), e.view.dispatch(o), !0;
    }
    return !1;
  }
}
function kC(t) {
  return typeof t == "number";
}
class CC {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const SC = (t, e, n) => {
  if (Em(e))
    return [...t.matchAll(e)];
  const o = e(t, n);
  return o ? o.map((r) => {
    const i = [r.text];
    return i.index = r.index, i.input = t, i.data = r.data, r.replaceWith && (r.text.includes(r.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(r.replaceWith)), i;
  }) : [];
};
function AC(t) {
  const { editor: e, state: n, from: o, to: r, rule: i, pasteEvent: s, dropEvent: a } = t, { commands: l, chain: c, can: d } = new su({
    editor: e,
    state: n
  }), u = [];
  return n.doc.nodesBetween(o, r, (h, m) => {
    if (!h.isTextblock || h.type.spec.code)
      return;
    const g = Math.max(o, m), v = Math.min(r, m + h.content.size), y = h.textBetween(g - m, v - m, void 0, "￼");
    SC(y, i.find, s).forEach((C) => {
      if (C.index === void 0)
        return;
      const b = g + C.index + 1, S = b + C[0].length, A = {
        from: n.tr.mapping.map(b),
        to: n.tr.mapping.map(S)
      }, I = i.handler({
        state: n,
        range: A,
        match: C,
        commands: l,
        chain: c,
        can: d,
        pasteEvent: s,
        dropEvent: a
      });
      u.push(I);
    });
  }), u.every((h) => h !== null);
}
let Vl = null;
const EC = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t), n;
};
function _C(t) {
  const { editor: e, rules: n } = t;
  let o = null, r = !1, i = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({ state: d, from: u, to: f, rule: h, pasteEvt: m }) => {
    const g = d.tr, v = iu({
      state: d,
      transaction: g
    });
    if (!(!AC({
      editor: e,
      state: v,
      from: Math.max(u - 1, 0),
      to: f.b - 1,
      rule: h,
      pasteEvent: m,
      dropEvent: a
    }) || !g.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, g;
    }
  };
  return n.map((d) => new Ne({
    // we register a global drag handler to track the current drag source element
    view(u) {
      const f = (m) => {
        var g;
        o = !((g = u.dom.parentElement) === null || g === void 0) && g.contains(m.target) ? u.dom.parentElement : null, o && (Vl = e);
      }, h = () => {
        Vl && (Vl = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", h), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", h);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (u, f) => {
          if (i = o === u.dom.parentElement, a = f, !i) {
            const h = Vl;
            h && setTimeout(() => {
              const m = h.state.selection;
              m && h.commands.deleteRange({ from: m.from, to: m.to });
            }, 10);
          }
          return !1;
        },
        paste: (u, f) => {
          var h;
          const m = (h = f.clipboardData) === null || h === void 0 ? void 0 : h.getData("text/html");
          return s = f, r = !!(m != null && m.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (u, f, h) => {
      const m = u[0], g = m.getMeta("uiEvent") === "paste" && !r, v = m.getMeta("uiEvent") === "drop" && !i, y = m.getMeta("applyPasteRules"), x = !!y;
      if (!g && !v && !x)
        return;
      if (x) {
        let { text: S } = y;
        typeof S == "string" ? S = S : S = Am(W.from(S), h.schema);
        const { from: A } = y, I = A + S.length, z = EC(S);
        return l({
          rule: d,
          state: h,
          from: A,
          to: { b: I },
          pasteEvt: z
        });
      }
      const C = f.doc.content.findDiffStart(h.doc.content), b = f.doc.content.findDiffEnd(h.doc.content);
      if (!(!kC(C) || !b || C === b.b))
        return l({
          rule: d,
          state: h,
          from: C,
          to: b,
          pasteEvt: s
        });
    }
  }));
}
function MC(t) {
  const e = t.filter((n, o) => t.indexOf(n) !== o);
  return Array.from(new Set(e));
}
class Ji {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = Ji.resolve(e), this.schema = vC(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = Ji.sort(Ji.flatten(e)), o = MC(n.map((r) => r.name));
    return o.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${o.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((n) => {
      const o = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, r = oe(n, "addExtensions", o);
      return r ? [n, ...this.flatten(r())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((o, r) => {
      const i = oe(o, "priority") || 100, s = oe(r, "priority") || 100;
      return i > s ? -1 : i < s ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const o = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: xf(n.name, this.schema)
      }, r = oe(n, "addCommands", o);
      return r ? {
        ...e,
        ...r()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, n = Ji.sort([...this.extensions].reverse()), o = [], r = [], i = n.map((s) => {
      const a = {
        name: s.name,
        options: s.options,
        storage: s.storage,
        editor: e,
        type: xf(s.name, this.schema)
      }, l = [], c = oe(s, "addKeyboardShortcuts", a);
      let d = {};
      if (s.type === "mark" && oe(s, "exitable", a) && (d.ArrowRight = () => Qt.handleExit({ editor: e, mark: s })), c) {
        const g = Object.fromEntries(Object.entries(c()).map(([v, y]) => [v, () => y({ editor: e })]));
        d = { ...d, ...g };
      }
      const u = jk(d);
      l.push(u);
      const f = oe(s, "addInputRules", a);
      m1(s, e.options.enableInputRules) && f && o.push(...f());
      const h = oe(s, "addPasteRules", a);
      m1(s, e.options.enablePasteRules) && h && r.push(...h());
      const m = oe(s, "addProseMirrorPlugins", a);
      if (m) {
        const g = m();
        l.push(...g);
      }
      return l;
    }).flat();
    return [
      wC({
        editor: e,
        rules: o
      }),
      ..._C({
        editor: e,
        rules: r
      }),
      ...i
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return Yw(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = au(this.extensions);
    return Object.fromEntries(n.filter((o) => !!oe(o, "addNodeView")).map((o) => {
      const r = this.attributes.filter((l) => l.type === o.name), i = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        editor: e,
        type: St(o.name, this.schema)
      }, s = oe(o, "addNodeView", i);
      if (!s)
        return [];
      const a = (l, c, d, u, f) => {
        const h = $p(l, r);
        return s()({
          // pass-through
          node: l,
          view: c,
          getPos: d,
          decorations: u,
          innerDecorations: f,
          // tiptap-specific
          editor: e,
          extension: o,
          HTMLAttributes: h
        });
      };
      return [o.name, a];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const o = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: xf(e.name, this.schema)
      };
      e.type === "mark" && (!((n = Ee(oe(e, "keepOnSplit", o))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
      const r = oe(e, "onBeforeCreate", o), i = oe(e, "onCreate", o), s = oe(e, "onUpdate", o), a = oe(e, "onSelectionUpdate", o), l = oe(e, "onTransaction", o), c = oe(e, "onFocus", o), d = oe(e, "onBlur", o), u = oe(e, "onDestroy", o);
      r && this.editor.on("beforeCreate", r), i && this.editor.on("create", i), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), d && this.editor.on("blur", d), u && this.editor.on("destroy", u);
    });
  }
}
class Te {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ee(oe(this, "addOptions", {
      name: this.name
    }))), this.storage = Ee(oe(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Te(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => cu(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Te({ ...this.config, ...e });
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Ee(oe(n, "addOptions", {
      name: n.name
    })), n.storage = Ee(oe(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function Zw(t, e, n) {
  const { from: o, to: r } = e, { blockSeparator: i = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return t.nodesBetween(o, r, (l, c, d, u) => {
    var f;
    l.isBlock && c > o && (a += i);
    const h = s == null ? void 0 : s[l.type.name];
    if (h)
      return d && (a += h({
        node: l,
        pos: c,
        parent: d,
        index: u,
        range: e
      })), !1;
    l.isText && (a += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(o, c) - c, r - c));
  }), a;
}
function _m(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const TC = Te.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ne({
        key: new Be("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: o, selection: r } = e, { ranges: i } = r, s = Math.min(...i.map((d) => d.$from.pos)), a = Math.max(...i.map((d) => d.$to.pos)), l = _m(n);
            return Zw(o, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), OC = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), IC = (t = !1) => ({ commands: e }) => e.setContent("", t), DC = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: o } = e, { ranges: r } = o;
  return n && r.forEach(({ $from: i, $to: s }) => {
    t.doc.nodesBetween(i.pos, s.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: d } = e, u = c.resolve(d.map(l)), f = c.resolve(d.map(l + a.nodeSize)), h = u.blockRange(f);
      if (!h)
        return;
      const m = Ss(h);
      if (a.type.isTextblock) {
        const { defaultType: g } = u.parent.contentMatchAt(u.index());
        e.setNodeMarkup(h.start, g);
      }
      (m || m === 0) && e.lift(h, m);
    });
  }), !0;
}, RC = (t) => (e) => t(e), PC = () => ({ state: t, dispatch: e }) => tC(t, e), LC = (t, e) => ({ editor: n, tr: o }) => {
  const { state: r } = n, i = r.doc.slice(t.from, t.to);
  o.deleteRange(t.from, t.to);
  const s = o.mapping.map(e);
  return o.insert(s, i.content), o.setSelection(new le(o.doc.resolve(s - 1))), !0;
}, NC = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, o = n.$anchor.node();
  if (o.content.size > 0)
    return !1;
  const r = t.selection.$anchor;
  for (let i = r.depth; i > 0; i -= 1)
    if (r.node(i).type === o.type) {
      if (e) {
        const a = r.before(i), l = r.after(i);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, BC = (t) => ({ tr: e, state: n, dispatch: o }) => {
  const r = St(t, n.schema), i = e.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === r) {
      if (o) {
        const l = i.before(s), c = i.after(s);
        e.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, $C = (t) => ({ tr: e, dispatch: n }) => {
  const { from: o, to: r } = t;
  return n && e.delete(o, r), !0;
}, zC = () => ({ state: t, dispatch: e }) => km(t, e), FC = () => ({ commands: t }) => t.keyboardShortcut("Enter"), HC = () => ({ state: t, dispatch: e }) => eC(t, e);
function Qc(t, e, n = { strict: !0 }) {
  const o = Object.keys(e);
  return o.length ? o.every((r) => n.strict ? e[r] === t[r] : Em(e[r]) ? e[r].test(t[r]) : e[r] === t[r]) : !0;
}
function Qw(t, e, n = {}) {
  return t.find((o) => o.type === e && Qc(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((r) => [r, o.attrs[r]])),
    n
  ));
}
function g1(t, e, n = {}) {
  return !!Qw(t, e, n);
}
function du(t, e, n) {
  var o;
  if (!t || !e)
    return;
  let r = t.parent.childAfter(t.parentOffset);
  if ((!r.node || !r.node.marks.some((d) => d.type === e)) && (r = t.parent.childBefore(t.parentOffset)), !r.node || !r.node.marks.some((d) => d.type === e) || (n = n || ((o = r.node.marks[0]) === null || o === void 0 ? void 0 : o.attrs), !Qw([...r.node.marks], e, n)))
    return;
  let s = r.index, a = t.start() + r.offset, l = s + 1, c = a + r.node.nodeSize;
  for (; s > 0 && g1([...t.parent.child(s - 1).marks], e, n); )
    s -= 1, a -= t.parent.child(s).nodeSize;
  for (; l < t.parent.childCount && g1([...t.parent.child(l).marks], e, n); )
    c += t.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: c
  };
}
function zr(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const VC = (t, e = {}) => ({ tr: n, state: o, dispatch: r }) => {
  const i = zr(t, o.schema), { doc: s, selection: a } = n, { $from: l, from: c, to: d } = a;
  if (r) {
    const u = du(l, i, e);
    if (u && u.from <= c && u.to >= d) {
      const f = le.create(s, u.from, u.to);
      n.setSelection(f);
    }
  }
  return !0;
}, jC = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let o = 0; o < n.length; o += 1)
    if (n[o](e))
      return !0;
  return !1;
};
function Mm(t) {
  return t instanceof le;
}
function Io(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function e2(t, e = null) {
  if (!e)
    return null;
  const n = pe.atStart(t), o = pe.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return o;
  const r = n.from, i = o.to;
  return e === "all" ? le.create(t, Io(0, r, i), Io(t.content.size, r, i)) : le.create(t, Io(e, r, i), Io(e, r, i));
}
function t2() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function uu() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const UC = (t = null, e = {}) => ({ editor: n, view: o, tr: r, dispatch: i }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const s = () => {
    (uu() || t2()) && o.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (o.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (o.hasFocus() && t === null || t === !1)
    return !0;
  if (i && t === null && !Mm(n.state.selection))
    return s(), !0;
  const a = e2(r.doc, t) || n.state.selection, l = n.state.selection.eq(a);
  return i && (l || r.setSelection(a), l && r.storedMarks && r.setStoredMarks(r.storedMarks), s()), !0;
}, WC = (t, e) => (n) => t.every((o, r) => e(o, { ...n, index: r })), KC = (t, e) => ({ tr: n, commands: o }) => o.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), n2 = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const o = e[n];
    o.nodeType === 3 && o.nodeValue && /^(\n\s\s|\n)$/.test(o.nodeValue) ? t.removeChild(o) : o.nodeType === 1 && n2(o);
  }
  return t;
};
function jl(t) {
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return n2(n);
}
function ed(t, e, n) {
  if (t instanceof wr || t instanceof W)
    return t;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const o = typeof t == "object" && t !== null, r = typeof t == "string";
  if (o)
    try {
      if (Array.isArray(t) && t.length > 0)
        return W.fromArray(t.map((a) => e.nodeFromJSON(a)));
      const s = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (i) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", i), ed("", e, n);
    }
  if (r) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const l = new qb({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (s = !0, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? la.fromSchema(l).parseSlice(jl(t), n.parseOptions) : la.fromSchema(l).parse(jl(t), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
    }
    const i = la.fromSchema(e);
    return n.slice ? i.parseSlice(jl(t), n.parseOptions).content : i.parse(jl(t), n.parseOptions);
  }
  return ed("", e, n);
}
function qC(t, e, n) {
  const o = t.steps.length - 1;
  if (o < e)
    return;
  const r = t.steps[o];
  if (!(r instanceof xt || r instanceof kt))
    return;
  const i = t.mapping.maps[o];
  let s = 0;
  i.forEach((a, l, c, d) => {
    s === 0 && (s = d);
  }), t.setSelection(pe.near(t.doc.resolve(s), n));
}
const GC = (t) => !("type" in t), JC = (t, e, n) => ({ tr: o, dispatch: r, editor: i }) => {
  var s;
  if (r) {
    n = {
      parseOptions: i.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    try {
      a = ed(e, i.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...n.parseOptions
        },
        errorOnInvalidContent: (s = n.errorOnInvalidContent) !== null && s !== void 0 ? s : i.options.enableContentCheck
      });
    } catch (m) {
      return i.emit("contentError", {
        editor: i,
        error: m,
        disableCollaboration: () => {
          i.storage.collaboration && (i.storage.collaboration.isDisabled = !0);
        }
      }), !1;
    }
    let { from: l, to: c } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, d = !0, u = !0;
    if ((GC(a) ? a : [a]).forEach((m) => {
      m.check(), d = d ? m.isText && m.marks.length === 0 : !1, u = u ? m.isBlock : !1;
    }), l === c && u) {
      const { parent: m } = o.doc.resolve(l);
      m.isTextblock && !m.type.spec.code && !m.childCount && (l -= 1, c += 1);
    }
    let h;
    if (d) {
      if (Array.isArray(e))
        h = e.map((m) => m.text || "").join("");
      else if (e instanceof W) {
        let m = "";
        e.forEach((g) => {
          g.text && (m += g.text);
        }), h = m;
      } else
        typeof e == "object" && e && e.text ? h = e.text : h = e;
      o.insertText(h, l, c);
    } else
      h = a, o.replaceWith(l, c, h);
    n.updateSelection && qC(o, o.steps.length - 1, -1), n.applyInputRules && o.setMeta("applyInputRules", { from: l, text: h }), n.applyPasteRules && o.setMeta("applyPasteRules", { from: l, text: h });
  }
  return !0;
}, YC = () => ({ state: t, dispatch: e }) => Yk(t, e), XC = () => ({ state: t, dispatch: e }) => Xk(t, e), ZC = () => ({ state: t, dispatch: e }) => Uk(t, e), QC = () => ({ state: t, dispatch: e }) => Gk(t, e), eS = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const o = Qd(t.doc, t.selection.$from.pos, -1);
    return o == null ? !1 : (n.join(o, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, tS = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const o = Qd(t.doc, t.selection.$from.pos, 1);
    return o == null ? !1 : (n.join(o, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, nS = () => ({ state: t, dispatch: e }) => Wk(t, e), oS = () => ({ state: t, dispatch: e }) => Kk(t, e);
function o2() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function rS(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let o, r, i, s;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      o = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      r = !0;
    else if (/^s(hift)?$/i.test(l))
      i = !0;
    else if (/^mod$/i.test(l))
      uu() || o2() ? s = !0 : r = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return o && (n = `Alt-${n}`), r && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), i && (n = `Shift-${n}`), n;
}
const iS = (t) => ({ editor: e, view: n, tr: o, dispatch: r }) => {
  const i = rS(t).split(/-(?!$)/), s = i.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: i.includes("Alt"),
    ctrlKey: i.includes("Ctrl"),
    metaKey: i.includes("Meta"),
    shiftKey: i.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, a));
  });
  return l == null || l.steps.forEach((c) => {
    const d = c.map(o.mapping);
    d && r && o.maybeStep(d);
  }), !0;
};
function Ba(t, e, n = {}) {
  const { from: o, to: r, empty: i } = t.selection, s = e ? St(e, t.schema) : null, a = [];
  t.doc.nodesBetween(o, r, (u, f) => {
    if (u.isText)
      return;
    const h = Math.max(o, f), m = Math.min(r, f + u.nodeSize);
    a.push({
      node: u,
      from: h,
      to: m
    });
  });
  const l = r - o, c = a.filter((u) => s ? s.name === u.node.type.name : !0).filter((u) => Qc(u.node.attrs, n, { strict: !1 }));
  return i ? !!c.length : c.reduce((u, f) => u + f.to - f.from, 0) >= l;
}
const sS = (t, e = {}) => ({ state: n, dispatch: o }) => {
  const r = St(t, n.schema);
  return Ba(n, r, e) ? Zk(n, o) : !1;
}, aS = () => ({ state: t, dispatch: e }) => nC(t, e), lS = (t) => ({ state: e, dispatch: n }) => {
  const o = St(t, e.schema);
  return dC(o)(e, n);
}, cS = () => ({ state: t, dispatch: e }) => Qk(t, e);
function fu(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function v1(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((o, r) => (n.includes(r) || (o[r] = t[r]), o), {});
}
const dS = (t, e) => ({ tr: n, state: o, dispatch: r }) => {
  let i = null, s = null;
  const a = fu(typeof t == "string" ? t : t.name, o.schema);
  return a ? (a === "node" && (i = St(t, o.schema)), a === "mark" && (s = zr(t, o.schema)), r && n.selection.ranges.forEach((l) => {
    o.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, d) => {
      i && i === c.type && n.setNodeMarkup(d, void 0, v1(c.attrs, e)), s && c.marks.length && c.marks.forEach((u) => {
        s === u.type && n.addMark(d, d + c.nodeSize, s.create(v1(u.attrs, e)));
      });
    });
  }), !0) : !1;
}, uS = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), fS = () => ({ tr: t, dispatch: e }) => {
  if (e) {
    const n = new Jt(t.doc);
    t.setSelection(n);
  }
  return !0;
}, pS = () => ({ state: t, dispatch: e }) => qk(t, e), hS = () => ({ state: t, dispatch: e }) => Jk(t, e), mS = () => ({ state: t, dispatch: e }) => oC(t, e), gS = () => ({ state: t, dispatch: e }) => sC(t, e), vS = () => ({ state: t, dispatch: e }) => iC(t, e);
function zp(t, e, n = {}, o = {}) {
  return ed(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: o.errorOnInvalidContent
  });
}
const yS = (t, e = !1, n = {}, o = {}) => ({ editor: r, tr: i, dispatch: s, commands: a }) => {
  var l, c;
  const { doc: d } = i;
  if (n.preserveWhitespace !== "full") {
    const u = zp(t, r.schema, n, {
      errorOnInvalidContent: (l = o.errorOnInvalidContent) !== null && l !== void 0 ? l : r.options.enableContentCheck
    });
    return s && i.replaceWith(0, d.content.size, u).setMeta("preventUpdate", !e), !0;
  }
  return s && i.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: d.content.size }, t, {
    parseOptions: n,
    errorOnInvalidContent: (c = o.errorOnInvalidContent) !== null && c !== void 0 ? c : r.options.enableContentCheck
  });
};
function Tm(t, e) {
  const n = zr(e, t.schema), { from: o, to: r, empty: i } = t.selection, s = [];
  i ? (t.storedMarks && s.push(...t.storedMarks), s.push(...t.selection.$head.marks())) : t.doc.nodesBetween(o, r, (l) => {
    s.push(...l.marks);
  });
  const a = s.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function bS(t, e) {
  const n = new cm(t);
  return e.forEach((o) => {
    o.steps.forEach((r) => {
      n.step(r);
    });
  }), n;
}
function wS(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function Fp(t, e) {
  const n = [];
  return t.descendants((o, r) => {
    e(o) && n.push({
      node: o,
      pos: r
    });
  }), n;
}
function xS(t, e, n) {
  const o = [];
  return t.nodesBetween(e.from, e.to, (r, i) => {
    n(r) && o.push({
      node: r,
      pos: i
    });
  }), o;
}
function r2(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const o = t.node(n);
    if (e(o))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: o
      };
  }
}
function Om(t) {
  return (e) => r2(e.$from, t);
}
function i2(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return Zw(t, n, e);
}
function kS(t, e) {
  const n = St(e, t.schema), { from: o, to: r } = t.selection, i = [];
  t.doc.nodesBetween(o, r, (a) => {
    i.push(a);
  });
  const s = i.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function s2(t, e) {
  const n = fu(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? kS(t, e) : n === "mark" ? Tm(t, e) : {};
}
function CS(t, e = JSON.stringify) {
  const n = {};
  return t.filter((o) => {
    const r = e(o);
    return Object.prototype.hasOwnProperty.call(n, r) ? !1 : n[r] = !0;
  });
}
function SS(t) {
  const e = CS(t);
  return e.length === 1 ? e : e.filter((n, o) => !e.filter((i, s) => s !== o).some((i) => n.oldRange.from >= i.oldRange.from && n.oldRange.to <= i.oldRange.to && n.newRange.from >= i.newRange.from && n.newRange.to <= i.newRange.to));
}
function AS(t) {
  const { mapping: e, steps: n } = t, o = [];
  return e.maps.forEach((r, i) => {
    const s = [];
    if (r.ranges.length)
      r.forEach((a, l) => {
        s.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[i];
      if (a === void 0 || l === void 0)
        return;
      s.push({ from: a, to: l });
    }
    s.forEach(({ from: a, to: l }) => {
      const c = e.slice(i).map(a, -1), d = e.slice(i).map(l), u = e.invert().map(c, -1), f = e.invert().map(d);
      o.push({
        oldRange: {
          from: u,
          to: f
        },
        newRange: {
          from: c,
          to: d
        }
      });
    });
  }), SS(o);
}
function Im(t, e, n) {
  const o = [];
  return t === e ? n.resolve(t).marks().forEach((r) => {
    const i = n.resolve(t), s = du(i, r.type);
    s && o.push({
      mark: r,
      ...s
    });
  }) : n.nodesBetween(t, e, (r, i) => {
    !r || (r == null ? void 0 : r.nodeSize) === void 0 || o.push(...r.marks.map((s) => ({
      from: i,
      to: i + r.nodeSize,
      mark: s
    })));
  }), o;
}
function _c(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([o]) => {
    const r = t.find((i) => i.type === e && i.name === o);
    return r ? r.attribute.keepOnSplit : !1;
  }));
}
function Hp(t, e, n = {}) {
  const { empty: o, ranges: r } = t.selection, i = e ? zr(e, t.schema) : null;
  if (o)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((u) => i ? i.name === u.type.name : !0).find((u) => Qc(u.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (r.forEach(({ $from: u, $to: f }) => {
    const h = u.pos, m = f.pos;
    t.doc.nodesBetween(h, m, (g, v) => {
      if (!g.isText && !g.marks.length)
        return;
      const y = Math.max(h, v), x = Math.min(m, v + g.nodeSize), C = x - y;
      s += C, a.push(...g.marks.map((b) => ({
        mark: b,
        from: y,
        to: x
      })));
    });
  }), s === 0)
    return !1;
  const l = a.filter((u) => i ? i.name === u.mark.type.name : !0).filter((u) => Qc(u.mark.attrs, n, { strict: !1 })).reduce((u, f) => u + f.to - f.from, 0), c = a.filter((u) => i ? u.mark.type !== i && u.mark.type.excludes(i) : !0).reduce((u, f) => u + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= s;
}
function pu(t, e, n = {}) {
  if (!e)
    return Ba(t, null, n) || Hp(t, null, n);
  const o = fu(e, t.schema);
  return o === "node" ? Ba(t, e, n) : o === "mark" ? Hp(t, e, n) : !1;
}
function Vp(t, e) {
  const { nodeExtensions: n } = au(e), o = n.find((s) => s.name === t);
  if (!o)
    return !1;
  const r = {
    name: o.name,
    options: o.options,
    storage: o.storage
  }, i = Ee(oe(o, "group", r));
  return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function hu(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  var o;
  if (n) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((o = t.text) !== null && o !== void 0 ? o : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let r = !0;
    return t.content.forEach((i) => {
      r !== !1 && (hu(i, { ignoreWhitespace: n, checkChildren: e }) || (r = !1));
    }), r;
  }
  return !1;
}
function a2(t) {
  return t instanceof de;
}
function l2(t, e, n) {
  const r = t.state.doc.content.size, i = Io(e, 0, r), s = Io(n, 0, r), a = t.coordsAtPos(i), l = t.coordsAtPos(s, -1), c = Math.min(a.top, l.top), d = Math.max(a.bottom, l.bottom), u = Math.min(a.left, l.left), f = Math.max(a.right, l.right), h = f - u, m = d - c, y = {
    top: c,
    bottom: d,
    left: u,
    right: f,
    width: h,
    height: m,
    x: u,
    y: c
  };
  return {
    ...y,
    toJSON: () => y
  };
}
function ES(t, e, n) {
  var o;
  const { selection: r } = e;
  let i = null;
  if (Mm(r) && (i = r.$cursor), i) {
    const a = (o = t.storedMarks) !== null && o !== void 0 ? o : i.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: s } = r;
  return s.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (d, u, f) => {
      if (c)
        return !1;
      if (d.isInline) {
        const h = !f || f.type.allowsMarkType(n), m = !!n.isInSet(d.marks) || !d.marks.some((g) => g.type.excludes(n));
        c = h && m;
      }
      return !c;
    }), c;
  });
}
const _S = (t, e = {}) => ({ tr: n, state: o, dispatch: r }) => {
  const { selection: i } = n, { empty: s, ranges: a } = i, l = zr(t, o.schema);
  if (r)
    if (s) {
      const c = Tm(o, l);
      n.addStoredMark(l.create({
        ...c,
        ...e
      }));
    } else
      a.forEach((c) => {
        const d = c.$from.pos, u = c.$to.pos;
        o.doc.nodesBetween(d, u, (f, h) => {
          const m = Math.max(h, d), g = Math.min(h + f.nodeSize, u);
          f.marks.find((y) => y.type === l) ? f.marks.forEach((y) => {
            l === y.type && n.addMark(m, g, l.create({
              ...y.attrs,
              ...e
            }));
          }) : n.addMark(m, g, l.create(e));
        });
      });
  return ES(o, n, l);
}, MS = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), TS = (t, e = {}) => ({ state: n, dispatch: o, chain: r }) => {
  const i = St(t, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), i.isTextblock ? r().command(({ commands: a }) => f1(i, { ...s, ...e })(n) ? !0 : a.clearNodes()).command(({ state: a }) => f1(i, { ...s, ...e })(a, o)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, OS = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: o } = e, r = Io(t, 0, o.content.size), i = de.create(o, r);
    e.setSelection(i);
  }
  return !0;
}, IS = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: o } = e, { from: r, to: i } = typeof t == "number" ? { from: t, to: t } : t, s = le.atStart(o).from, a = le.atEnd(o).to, l = Io(r, s, a), c = Io(i, s, a), d = le.create(o, l, c);
    e.setSelection(d);
  }
  return !0;
}, DS = (t) => ({ state: e, dispatch: n }) => {
  const o = St(t, e.schema);
  return pC(o)(e, n);
};
function y1(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const o = n.filter((r) => e == null ? void 0 : e.includes(r.type.name));
    t.tr.ensureMarks(o);
  }
}
const RS = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: o, editor: r }) => {
  const { selection: i, doc: s } = e, { $from: a, $to: l } = i, c = r.extensionManager.attributes, d = _c(c, a.node().type.name, a.node().attrs);
  if (i instanceof de && i.node.isBlock)
    return !a.parentOffset || !Zi(s, a.pos) ? !1 : (o && (t && y1(n, r.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const u = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : wS(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let h = u && f ? [
    {
      type: f,
      attrs: d
    }
  ] : void 0, m = Zi(e.doc, e.mapping.map(a.pos), 1, h);
  if (!h && !m && Zi(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (m = !0, h = f ? [
    {
      type: f,
      attrs: d
    }
  ] : void 0), o) {
    if (m && (i instanceof le && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, h), f && !u && !a.parentOffset && a.parent.type !== f)) {
      const g = e.mapping.map(a.before()), v = e.doc.resolve(g);
      a.node(-1).canReplaceWith(v.index(), v.index() + 1, f) && e.setNodeMarkup(e.mapping.map(a.before()), f);
    }
    t && y1(n, r.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return m;
}, PS = (t, e = {}) => ({ tr: n, state: o, dispatch: r, editor: i }) => {
  var s;
  const a = St(t, o.schema), { $from: l, $to: c } = o.selection, d = o.selection.node;
  if (d && d.isBlock || l.depth < 2 || !l.sameParent(c))
    return !1;
  const u = l.node(-1);
  if (u.type !== a)
    return !1;
  const f = i.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (r) {
      let y = W.empty;
      const x = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let z = l.depth - x; z >= l.depth - 3; z -= 1)
        y = W.from(l.node(z).copy(y));
      const C = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, b = {
        ..._c(f, l.node().type.name, l.node().attrs),
        ...e
      }, S = ((s = a.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(b)) || void 0;
      y = y.append(W.from(a.createAndFill(null, S) || void 0));
      const A = l.before(l.depth - (x - 1));
      n.replace(A, l.after(-C), new ee(y, 4 - x, 0));
      let I = -1;
      n.doc.nodesBetween(A, n.doc.content.size, (z, N) => {
        if (I > -1)
          return !1;
        z.isTextblock && z.content.size === 0 && (I = N + 1);
      }), I > -1 && n.setSelection(le.near(n.doc.resolve(I))), n.scrollIntoView();
    }
    return !0;
  }
  const h = c.pos === l.end() ? u.contentMatchAt(0).defaultType : null, m = {
    ..._c(f, u.type.name, u.attrs),
    ...e
  }, g = {
    ..._c(f, l.node().type.name, l.node().attrs),
    ...e
  };
  n.delete(l.pos, c.pos);
  const v = h ? [
    { type: a, attrs: m },
    { type: h, attrs: g }
  ] : [{ type: a, attrs: m }];
  if (!Zi(n.doc, l.pos, 2))
    return !1;
  if (r) {
    const { selection: y, storedMarks: x } = o, { splittableMarks: C } = i.extensionManager, b = x || y.$to.parentOffset && y.$from.marks();
    if (n.split(l.pos, 2, v).scrollIntoView(), !b || !r)
      return !0;
    const S = b.filter((A) => C.includes(A.type.name));
    n.ensureMarks(S);
  }
  return !0;
}, kf = (t, e) => {
  const n = Om((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const o = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (o === void 0)
    return !0;
  const r = t.doc.nodeAt(o);
  return n.node.type === (r == null ? void 0 : r.type) && Br(t.doc, n.pos) && t.join(n.pos), !0;
}, Cf = (t, e) => {
  const n = Om((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const o = t.doc.resolve(n.start).after(n.depth);
  if (o === void 0)
    return !0;
  const r = t.doc.nodeAt(o);
  return n.node.type === (r == null ? void 0 : r.type) && Br(t.doc, o) && t.join(o), !0;
}, LS = (t, e, n, o = {}) => ({ editor: r, tr: i, state: s, dispatch: a, chain: l, commands: c, can: d }) => {
  const { extensions: u, splittableMarks: f } = r.extensionManager, h = St(t, s.schema), m = St(e, s.schema), { selection: g, storedMarks: v } = s, { $from: y, $to: x } = g, C = y.blockRange(x), b = v || g.$to.parentOffset && g.$from.marks();
  if (!C)
    return !1;
  const S = Om((A) => Vp(A.type.name, u))(g);
  if (C.depth >= 1 && S && C.depth - S.depth <= 1) {
    if (S.node.type === h)
      return c.liftListItem(m);
    if (Vp(S.node.type.name, u) && h.validContent(S.node.content) && a)
      return l().command(() => (i.setNodeMarkup(S.pos, h), !0)).command(() => kf(i, h)).command(() => Cf(i, h)).run();
  }
  return !n || !b || !a ? l().command(() => d().wrapInList(h, o) ? !0 : c.clearNodes()).wrapInList(h, o).command(() => kf(i, h)).command(() => Cf(i, h)).run() : l().command(() => {
    const A = d().wrapInList(h, o), I = b.filter((z) => f.includes(z.type.name));
    return i.ensureMarks(I), A ? !0 : c.clearNodes();
  }).wrapInList(h, o).command(() => kf(i, h)).command(() => Cf(i, h)).run();
}, NS = (t, e = {}, n = {}) => ({ state: o, commands: r }) => {
  const { extendEmptyMarkRange: i = !1 } = n, s = zr(t, o.schema);
  return Hp(o, s, e) ? r.unsetMark(s, { extendEmptyMarkRange: i }) : r.setMark(s, e);
}, BS = (t, e, n = {}) => ({ state: o, commands: r }) => {
  const i = St(t, o.schema), s = St(e, o.schema), a = Ba(o, i, n);
  let l;
  return o.selection.$anchor.sameParent(o.selection.$head) && (l = o.selection.$anchor.parent.attrs), a ? r.setNode(s, l) : r.setNode(i, { ...l, ...n });
}, $S = (t, e = {}) => ({ state: n, commands: o }) => {
  const r = St(t, n.schema);
  return Ba(n, r, e) ? o.lift(r) : o.wrapIn(r, e);
}, zS = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let o = 0; o < n.length; o += 1) {
    const r = n[o];
    let i;
    if (r.spec.isInputRules && (i = r.getState(t))) {
      if (e) {
        const s = t.tr, a = i.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          s.step(a.steps[l].invert(a.docs[l]));
        if (i.text) {
          const l = s.doc.resolve(i.from).marks();
          s.replaceWith(i.from, i.to, t.schema.text(i.text, l));
        } else
          s.delete(i.from, i.to);
      }
      return !0;
    }
  }
  return !1;
}, FS = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: o, ranges: r } = n;
  return o || e && r.forEach((i) => {
    t.removeMark(i.$from.pos, i.$to.pos);
  }), !0;
}, HS = (t, e = {}) => ({ tr: n, state: o, dispatch: r }) => {
  var i;
  const { extendEmptyMarkRange: s = !1 } = e, { selection: a } = n, l = zr(t, o.schema), { $from: c, empty: d, ranges: u } = a;
  if (!r)
    return !0;
  if (d && s) {
    let { from: f, to: h } = a;
    const m = (i = c.marks().find((v) => v.type === l)) === null || i === void 0 ? void 0 : i.attrs, g = du(c, l, m);
    g && (f = g.from, h = g.to), n.removeMark(f, h, l);
  } else
    u.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, VS = (t, e = {}) => ({ tr: n, state: o, dispatch: r }) => {
  let i = null, s = null;
  const a = fu(typeof t == "string" ? t : t.name, o.schema);
  return a ? (a === "node" && (i = St(t, o.schema)), a === "mark" && (s = zr(t, o.schema)), r && n.selection.ranges.forEach((l) => {
    const c = l.$from.pos, d = l.$to.pos;
    let u, f, h, m;
    n.selection.empty ? o.doc.nodesBetween(c, d, (g, v) => {
      i && i === g.type && (h = Math.max(v, c), m = Math.min(v + g.nodeSize, d), u = v, f = g);
    }) : o.doc.nodesBetween(c, d, (g, v) => {
      v < c && i && i === g.type && (h = Math.max(v, c), m = Math.min(v + g.nodeSize, d), u = v, f = g), v >= c && v <= d && (i && i === g.type && n.setNodeMarkup(v, void 0, {
        ...g.attrs,
        ...e
      }), s && g.marks.length && g.marks.forEach((y) => {
        if (s === y.type) {
          const x = Math.max(v, c), C = Math.min(v + g.nodeSize, d);
          n.addMark(x, C, s.create({
            ...y.attrs,
            ...e
          }));
        }
      }));
    }), f && (u !== void 0 && n.setNodeMarkup(u, void 0, {
      ...f.attrs,
      ...e
    }), s && f.marks.length && f.marks.forEach((g) => {
      s === g.type && n.addMark(h, m, s.create({
        ...g.attrs,
        ...e
      }));
    }));
  }), !0) : !1;
}, jS = (t, e = {}) => ({ state: n, dispatch: o }) => {
  const r = St(t, n.schema);
  return aC(r, e)(n, o);
}, US = (t, e = {}) => ({ state: n, dispatch: o }) => {
  const r = St(t, n.schema);
  return lC(r, e)(n, o);
};
var WS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: OC,
  clearContent: IC,
  clearNodes: DC,
  command: RC,
  createParagraphNear: PC,
  cut: LC,
  deleteCurrentNode: NC,
  deleteNode: BC,
  deleteRange: $C,
  deleteSelection: zC,
  enter: FC,
  exitCode: HC,
  extendMarkRange: VC,
  first: jC,
  focus: UC,
  forEach: WC,
  insertContent: KC,
  insertContentAt: JC,
  joinBackward: ZC,
  joinDown: XC,
  joinForward: QC,
  joinItemBackward: eS,
  joinItemForward: tS,
  joinTextblockBackward: nS,
  joinTextblockForward: oS,
  joinUp: YC,
  keyboardShortcut: iS,
  lift: sS,
  liftEmptyBlock: aS,
  liftListItem: lS,
  newlineInCode: cS,
  resetAttributes: dS,
  scrollIntoView: uS,
  selectAll: fS,
  selectNodeBackward: pS,
  selectNodeForward: hS,
  selectParentNode: mS,
  selectTextblockEnd: gS,
  selectTextblockStart: vS,
  setContent: yS,
  setMark: _S,
  setMeta: MS,
  setNode: TS,
  setNodeSelection: OS,
  setTextSelection: IS,
  sinkListItem: DS,
  splitBlock: RS,
  splitListItem: PS,
  toggleList: LS,
  toggleMark: NS,
  toggleNode: BS,
  toggleWrap: $S,
  undoInputRule: zS,
  unsetAllMarks: FS,
  unsetMark: HS,
  updateAttributes: VS,
  wrapIn: jS,
  wrapInList: US
});
const KS = Te.create({
  name: "commands",
  addCommands() {
    return {
      ...WS
    };
  }
}), qS = Te.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Ne({
        key: new Be("tiptapDrop"),
        props: {
          handleDrop: (t, e, n, o) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: o
            });
          }
        }
      })
    ];
  }
}), GS = Te.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Ne({
        key: new Be("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), JS = Te.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Ne({
        key: new Be("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const o = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(o), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const o = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(o), !1;
            }
          }
        }
      })
    ];
  }
}), YS = Te.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: d, $anchor: u } = l, { pos: f, parent: h } = u, m = u.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : u, g = m.parent.type.spec.isolating, v = u.pos - u.parentOffset, y = g && m.parent.childCount === 1 ? v === u.pos : pe.atStart(c).from === f;
        return !d || !h.type.isTextblock || h.textContent.length || !y || y && u.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), o = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, r = {
      ...o
    }, i = {
      ...o,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return uu() || o2() ? i : r;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Ne({
        key: new Be("clearDocument"),
        appendTransaction: (t, e, n) => {
          if (t.some((g) => g.getMeta("composition")))
            return;
          const o = t.some((g) => g.docChanged) && !e.doc.eq(n.doc), r = t.some((g) => g.getMeta("preventClearDocument"));
          if (!o || r)
            return;
          const { empty: i, from: s, to: a } = e.selection, l = pe.atStart(e.doc).from, c = pe.atEnd(e.doc).to;
          if (i || !(s === l && a === c) || !hu(n.doc))
            return;
          const f = n.tr, h = iu({
            state: n,
            transaction: f
          }), { commands: m } = new su({
            editor: this.editor,
            state: h
          });
          if (m.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), XS = Te.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Ne({
        key: new Be("tiptapPaste"),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
}), ZS = Te.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Ne({
        key: new Be("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class Zr {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, o = !1, r = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = o, this.resolvedPos = e, this.editor = n, this.currentNode = r;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, o = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, o = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: o }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new Zr(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Zr(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Zr(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, o) => {
      const r = n.isBlock && !n.isTextblock, i = n.isAtom && !n.isText, s = this.pos + o + (i ? 0 : 1), a = this.resolvedPos.doc.resolve(s);
      if (!r && a.depth <= this.depth)
        return;
      const l = new Zr(a, this.editor, r, r ? n : null);
      r && (l.actualDepth = this.depth + 1), e.push(new Zr(a, this.editor, r, r ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let o = null, r = this.parent;
    for (; r && !o; ) {
      if (r.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const i = r.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const l = s[a];
            if (i[l] !== n[l])
              break;
          }
        } else
          o = r;
      r = r.parent;
    }
    return o;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, o = !1) {
    let r = [];
    if (!this.children || this.children.length === 0)
      return r;
    const i = Object.keys(n);
    return this.children.forEach((s) => {
      o && r.length > 0 || (s.node.type.name === e && i.every((l) => n[l] === s.node.attrs[l]) && r.push(s), !(o && r.length > 0) && (r = r.concat(s.querySelectorAll(e, n, o))));
    }), r;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
}
const QS = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function eA(t, e, n) {
  const o = document.querySelector("style[data-tiptap-style]");
  if (o !== null)
    return o;
  const r = document.createElement("style");
  return e && r.setAttribute("nonce", e), r.setAttribute("data-tiptap-style", ""), r.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(r), r;
}
let c2 = class extends hC {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: o, moved: r }) => this.options.onDrop(n, o, r)), this.on("paste", ({ event: n, slice: o }) => this.options.onPaste(n, o)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = eA(QS, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, n) {
    const o = Xw(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: o });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = this.state.plugins;
    let o = n;
    if ([].concat(e).forEach((i) => {
      const s = typeof i == "string" ? `${i}$` : i.key;
      o = n.filter((a) => !a.key.startsWith(s));
    }), n.length === o.length)
      return;
    const r = this.state.reconfigure({
      plugins: o
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const r = [...this.options.enableCoreExtensions ? [
      GS,
      TC.configure({
        blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      KS,
      JS,
      YS,
      ZS,
      qS,
      XS
    ].filter((i) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[i.name] !== !1 : !0) : [], ...this.options.extensions].filter((i) => ["extension", "node", "mark"].includes(i == null ? void 0 : i.type));
    this.extensionManager = new Ji(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new su({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let n;
    try {
      n = zp(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (s) {
      if (!(s instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(s.message))
        throw s;
      this.emit("contentError", {
        editor: this,
        error: s,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
        }
      }), n = zp(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const o = e2(n, this.options.autofocus);
    this.view = new Pk(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Gi.create({
        doc: n,
        selection: o || void 0
      })
    });
    const r = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(r), this.createNodeViews(), this.prependClass();
    const i = this.view.dom;
    i.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((s) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(s);
      });
      return;
    }
    const n = this.state.apply(e), o = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), o && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const r = e.getMeta("focus"), i = e.getMeta("blur");
    r && this.emit("focus", {
      editor: this,
      event: r.event,
      transaction: e
    }), i && this.emit("blur", {
      editor: this,
      event: i.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return s2(this.state, e);
  }
  isActive(e, n) {
    const o = typeof e == "string" ? e : null, r = typeof e == "string" ? n : e;
    return pu(this.state, o, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return Am(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: o = {} } = e || {};
    return i2(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ..._m(this.schema),
        ...o
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return hu(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var o;
    return ((o = this.$doc) === null || o === void 0 ? void 0 : o.querySelector(e, n)) || null;
  }
  $nodes(e, n) {
    var o;
    return ((o = this.$doc) === null || o === void 0 ? void 0 : o.querySelectorAll(e, n)) || null;
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new Zr(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function mi(t) {
  return new lu({
    find: t.find,
    handler: ({ state: e, range: n, match: o }) => {
      const r = Ee(t.getAttributes, void 0, o);
      if (r === !1 || r === null)
        return null;
      const { tr: i } = e, s = o[o.length - 1], a = o[0];
      if (s) {
        const l = a.search(/\S/), c = n.from + a.indexOf(s), d = c + s.length;
        if (Im(n.from, n.to, e.doc).filter((h) => h.mark.type.excluded.find((g) => g === t.type && g !== h.mark.type)).filter((h) => h.to > c).length)
          return null;
        d < n.to && i.delete(d, n.to), c > n.from && i.delete(n.from + l, c);
        const f = n.from + l + s.length;
        i.addMark(n.from + l, f, t.type.create(r || {})), i.removeStoredMark(t.type);
      }
    }
  });
}
function d2(t) {
  return new lu({
    find: t.find,
    handler: ({ state: e, range: n, match: o }) => {
      const r = Ee(t.getAttributes, void 0, o) || {}, { tr: i } = e, s = n.from;
      let a = n.to;
      const l = t.type.create(r);
      if (o[1]) {
        const c = o[0].lastIndexOf(o[1]);
        let d = s + c;
        d > a ? d = a : a = d + o[1].length;
        const u = o[0][o[0].length - 1];
        i.insertText(u, s + o[0].length - 1), i.replaceWith(d, a, l);
      } else if (o[0]) {
        const c = t.type.isInline ? s : s - 1;
        i.insert(c, t.type.create(r)).delete(i.mapping.map(s), i.mapping.map(a));
      }
      i.scrollIntoView();
    }
  });
}
function jp(t) {
  return new lu({
    find: t.find,
    handler: ({ state: e, range: n, match: o }) => {
      const r = e.doc.resolve(n.from), i = Ee(t.getAttributes, void 0, o) || {};
      if (!r.node(-1).canReplaceWith(r.index(-1), r.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, i);
    }
  });
}
function cs(t) {
  return new lu({
    find: t.find,
    handler: ({ state: e, range: n, match: o, chain: r }) => {
      const i = Ee(t.getAttributes, void 0, o) || {}, s = e.tr.delete(n.from, n.to), l = s.doc.resolve(n.from).blockRange(), c = l && lm(l, t.type, i);
      if (!c)
        return null;
      if (s.wrap(l, c), t.keepMarks && t.editor) {
        const { selection: u, storedMarks: f } = e, { splittableMarks: h } = t.editor.extensionManager, m = f || u.$to.parentOffset && u.$from.marks();
        if (m) {
          const g = m.filter((v) => h.includes(v.type.name));
          s.ensureMarks(g);
        }
      }
      if (t.keepAttributes) {
        const u = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        r().updateAttributes(u, i).run();
      }
      const d = s.doc.resolve(n.from - 1).nodeBefore;
      d && d.type === t.type && Br(s.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(o, d)) && s.join(n.from - 1);
    }
  });
}
let ot = class Up {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ee(oe(this, "addOptions", {
      name: this.name
    }))), this.storage = Ee(oe(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Up(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => cu(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Up(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Ee(oe(n, "addOptions", {
      name: n.name
    })), n.storage = Ee(oe(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
class tA {
  constructor(e, n, o) {
    this.isDragging = !1, this.component = e, this.editor = n.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...o
    }, this.extension = n.extension, this.node = n.node, this.decorations = n.decorations, this.innerDecorations = n.innerDecorations, this.view = n.view, this.HTMLAttributes = n.HTMLAttributes, this.getPos = n.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var n, o, r, i, s, a, l;
    const { view: c } = this.editor, d = e.target, u = d.nodeType === 3 ? (n = d.parentElement) === null || n === void 0 ? void 0 : n.closest("[data-drag-handle]") : d.closest("[data-drag-handle]");
    if (!this.dom || !((o = this.contentDOM) === null || o === void 0) && o.contains(d) || !u)
      return;
    let f = 0, h = 0;
    if (this.dom !== u) {
      const y = this.dom.getBoundingClientRect(), x = u.getBoundingClientRect(), C = (r = e.offsetX) !== null && r !== void 0 ? r : (i = e.nativeEvent) === null || i === void 0 ? void 0 : i.offsetX, b = (s = e.offsetY) !== null && s !== void 0 ? s : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetY;
      f = x.x - y.x + C, h = x.y - y.y + b;
    }
    (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(this.dom, f, h);
    const m = this.getPos();
    if (typeof m != "number")
      return;
    const g = de.create(c.state.doc, m), v = c.state.tr.setSelection(g);
    c.dispatch(v);
  }
  stopEvent(e) {
    var n;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const o = e.target;
    if (!(this.dom.contains(o) && !(!((n = this.contentDOM) === null || n === void 0) && n.contains(o))))
      return !1;
    const i = e.type.startsWith("drag"), s = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(o.tagName) || o.isContentEditable) && !s && !i)
      return !0;
    const { isEditable: l } = this.editor, { isDragging: c } = this, d = !!this.node.type.spec.draggable, u = de.isSelectable(this.node), f = e.type === "copy", h = e.type === "paste", m = e.type === "cut", g = e.type === "mousedown";
    if (!d && u && i && e.target === this.dom && e.preventDefault(), d && i && !c && e.target === this.dom)
      return e.preventDefault(), !1;
    if (d && l && !c && g) {
      const v = o.closest("[data-drag-handle]");
      v && (this.dom === v || this.dom.contains(v)) && (this.isDragging = !0, document.addEventListener("dragend", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("drop", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("mouseup", () => {
        this.isDragging = !1;
      }, { once: !0 }));
    }
    return !(c || s || f || h || m || g && u);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (uu() || t2()) && this.editor.isFocused && [
      ...Array.from(e.addedNodes),
      ...Array.from(e.removedNodes)
    ].every((o) => o.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: n }) => {
      const o = this.getPos();
      return typeof o != "number" ? !1 : (n.setNodeMarkup(o, void 0, {
        ...this.node.attrs,
        ...e
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number")
      return;
    const n = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: n });
  }
}
function Er(t) {
  return new CC({
    find: t.find,
    handler: ({ state: e, range: n, match: o, pasteEvent: r }) => {
      const i = Ee(t.getAttributes, void 0, o, r);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, a = o[o.length - 1], l = o[0];
      let c = n.to;
      if (a) {
        const d = l.search(/\S/), u = n.from + l.indexOf(a), f = u + a.length;
        if (Im(n.from, n.to, e.doc).filter((m) => m.mark.type.excluded.find((v) => v === t.type && v !== m.mark.type)).filter((m) => m.to > u).length)
          return null;
        f < n.to && s.delete(f, n.to), u > n.from && s.delete(n.from + d, u), c = n.from + d + a.length, s.addMark(n.from + d, c, t.type.create(i || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
function nA(t) {
  return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var Xt = "top", Mn = "bottom", Tn = "right", Zt = "left", Dm = "auto", wl = [Xt, Mn, Tn, Zt], ds = "start", $a = "end", oA = "clippingParents", u2 = "viewport", qs = "popper", rA = "reference", b1 = /* @__PURE__ */ wl.reduce(function(t, e) {
  return t.concat([e + "-" + ds, e + "-" + $a]);
}, []), f2 = /* @__PURE__ */ [].concat(wl, [Dm]).reduce(function(t, e) {
  return t.concat([e, e + "-" + ds, e + "-" + $a]);
}, []), iA = "beforeRead", sA = "read", aA = "afterRead", lA = "beforeMain", cA = "main", dA = "afterMain", uA = "beforeWrite", fA = "write", pA = "afterWrite", hA = [iA, sA, aA, lA, cA, dA, uA, fA, pA];
function io(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function un(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function gi(t) {
  var e = un(t).Element;
  return t instanceof e || t instanceof Element;
}
function En(t) {
  var e = un(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Rm(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = un(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function mA(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var o = e.styles[n] || {}, r = e.attributes[n] || {}, i = e.elements[n];
    !En(i) || !io(i) || (Object.assign(i.style, o), Object.keys(r).forEach(function(s) {
      var a = r[s];
      a === !1 ? i.removeAttribute(s) : i.setAttribute(s, a === !0 ? "" : a);
    }));
  });
}
function gA(t) {
  var e = t.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(o) {
      var r = e.elements[o], i = e.attributes[o] || {}, s = Object.keys(e.styles.hasOwnProperty(o) ? e.styles[o] : n[o]), a = s.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !En(r) || !io(r) || (Object.assign(r.style, a), Object.keys(i).forEach(function(l) {
        r.removeAttribute(l);
      }));
    });
  };
}
const p2 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: mA,
  effect: gA,
  requires: ["computeStyles"]
};
function Zn(t) {
  return t.split("-")[0];
}
var ci = Math.max, td = Math.min, us = Math.round;
function Wp() {
  var t = navigator.userAgentData;
  return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function h2() {
  return !/^((?!chrome|android).)*safari/i.test(Wp());
}
function fs(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var o = t.getBoundingClientRect(), r = 1, i = 1;
  e && En(t) && (r = t.offsetWidth > 0 && us(o.width) / t.offsetWidth || 1, i = t.offsetHeight > 0 && us(o.height) / t.offsetHeight || 1);
  var s = gi(t) ? un(t) : window, a = s.visualViewport, l = !h2() && n, c = (o.left + (l && a ? a.offsetLeft : 0)) / r, d = (o.top + (l && a ? a.offsetTop : 0)) / i, u = o.width / r, f = o.height / i;
  return {
    width: u,
    height: f,
    top: d,
    right: c + u,
    bottom: d + f,
    left: c,
    x: c,
    y: d
  };
}
function Pm(t) {
  var e = fs(t), n = t.offsetWidth, o = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - o) <= 1 && (o = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: n,
    height: o
  };
}
function m2(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && Rm(n)) {
    var o = e;
    do {
      if (o && t.isSameNode(o))
        return !0;
      o = o.parentNode || o.host;
    } while (o);
  }
  return !1;
}
function $o(t) {
  return un(t).getComputedStyle(t);
}
function vA(t) {
  return ["table", "td", "th"].indexOf(io(t)) >= 0;
}
function Fr(t) {
  return ((gi(t) ? t.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t.document
  )) || window.document).documentElement;
}
function mu(t) {
  return io(t) === "html" ? t : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t.parentNode || // DOM Element detected
    (Rm(t) ? t.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    Fr(t)
  );
}
function w1(t) {
  return !En(t) || // https://github.com/popperjs/popper-core/issues/837
  $o(t).position === "fixed" ? null : t.offsetParent;
}
function yA(t) {
  var e = /firefox/i.test(Wp()), n = /Trident/i.test(Wp());
  if (n && En(t)) {
    var o = $o(t);
    if (o.position === "fixed")
      return null;
  }
  var r = mu(t);
  for (Rm(r) && (r = r.host); En(r) && ["html", "body"].indexOf(io(r)) < 0; ) {
    var i = $o(r);
    if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
      return r;
    r = r.parentNode;
  }
  return null;
}
function xl(t) {
  for (var e = un(t), n = w1(t); n && vA(n) && $o(n).position === "static"; )
    n = w1(n);
  return n && (io(n) === "html" || io(n) === "body" && $o(n).position === "static") ? e : n || yA(t) || e;
}
function Lm(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function fa(t, e, n) {
  return ci(t, td(e, n));
}
function bA(t, e, n) {
  var o = fa(t, e, n);
  return o > n ? n : o;
}
function g2() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function v2(t) {
  return Object.assign({}, g2(), t);
}
function y2(t, e) {
  return e.reduce(function(n, o) {
    return n[o] = t, n;
  }, {});
}
var wA = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, v2(typeof e != "number" ? e : y2(e, wl));
};
function xA(t) {
  var e, n = t.state, o = t.name, r = t.options, i = n.elements.arrow, s = n.modifiersData.popperOffsets, a = Zn(n.placement), l = Lm(a), c = [Zt, Tn].indexOf(a) >= 0, d = c ? "height" : "width";
  if (!(!i || !s)) {
    var u = wA(r.padding, n), f = Pm(i), h = l === "y" ? Xt : Zt, m = l === "y" ? Mn : Tn, g = n.rects.reference[d] + n.rects.reference[l] - s[l] - n.rects.popper[d], v = s[l] - n.rects.reference[l], y = xl(i), x = y ? l === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, C = g / 2 - v / 2, b = u[h], S = x - f[d] - u[m], A = x / 2 - f[d] / 2 + C, I = fa(b, A, S), z = l;
    n.modifiersData[o] = (e = {}, e[z] = I, e.centerOffset = I - A, e);
  }
}
function kA(t) {
  var e = t.state, n = t.options, o = n.element, r = o === void 0 ? "[data-popper-arrow]" : o;
  r != null && (typeof r == "string" && (r = e.elements.popper.querySelector(r), !r) || m2(e.elements.popper, r) && (e.elements.arrow = r));
}
const CA = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: xA,
  effect: kA,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function ps(t) {
  return t.split("-")[1];
}
var SA = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function AA(t, e) {
  var n = t.x, o = t.y, r = e.devicePixelRatio || 1;
  return {
    x: us(n * r) / r || 0,
    y: us(o * r) / r || 0
  };
}
function x1(t) {
  var e, n = t.popper, o = t.popperRect, r = t.placement, i = t.variation, s = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, d = t.roundOffsets, u = t.isFixed, f = s.x, h = f === void 0 ? 0 : f, m = s.y, g = m === void 0 ? 0 : m, v = typeof d == "function" ? d({
    x: h,
    y: g
  }) : {
    x: h,
    y: g
  };
  h = v.x, g = v.y;
  var y = s.hasOwnProperty("x"), x = s.hasOwnProperty("y"), C = Zt, b = Xt, S = window;
  if (c) {
    var A = xl(n), I = "clientHeight", z = "clientWidth";
    if (A === un(n) && (A = Fr(n), $o(A).position !== "static" && a === "absolute" && (I = "scrollHeight", z = "scrollWidth")), A = A, r === Xt || (r === Zt || r === Tn) && i === $a) {
      b = Mn;
      var N = u && A === S && S.visualViewport ? S.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        A[I]
      );
      g -= N - o.height, g *= l ? 1 : -1;
    }
    if (r === Zt || (r === Xt || r === Mn) && i === $a) {
      C = Tn;
      var M = u && A === S && S.visualViewport ? S.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        A[z]
      );
      h -= M - o.width, h *= l ? 1 : -1;
    }
  }
  var $ = Object.assign({
    position: a
  }, c && SA), L = d === !0 ? AA({
    x: h,
    y: g
  }, un(n)) : {
    x: h,
    y: g
  };
  if (h = L.x, g = L.y, l) {
    var Y;
    return Object.assign({}, $, (Y = {}, Y[b] = x ? "0" : "", Y[C] = y ? "0" : "", Y.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + g + "px)" : "translate3d(" + h + "px, " + g + "px, 0)", Y));
  }
  return Object.assign({}, $, (e = {}, e[b] = x ? g + "px" : "", e[C] = y ? h + "px" : "", e.transform = "", e));
}
function EA(t) {
  var e = t.state, n = t.options, o = n.gpuAcceleration, r = o === void 0 ? !0 : o, i = n.adaptive, s = i === void 0 ? !0 : i, a = n.roundOffsets, l = a === void 0 ? !0 : a, c = {
    placement: Zn(e.placement),
    variation: ps(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: r,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, x1(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: s,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, x1(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const _A = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: EA,
  data: {}
};
var Ul = {
  passive: !0
};
function MA(t) {
  var e = t.state, n = t.instance, o = t.options, r = o.scroll, i = r === void 0 ? !0 : r, s = o.resize, a = s === void 0 ? !0 : s, l = un(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return i && c.forEach(function(d) {
    d.addEventListener("scroll", n.update, Ul);
  }), a && l.addEventListener("resize", n.update, Ul), function() {
    i && c.forEach(function(d) {
      d.removeEventListener("scroll", n.update, Ul);
    }), a && l.removeEventListener("resize", n.update, Ul);
  };
}
const TA = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: MA,
  data: {}
};
var OA = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Mc(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return OA[e];
  });
}
var IA = {
  start: "end",
  end: "start"
};
function k1(t) {
  return t.replace(/start|end/g, function(e) {
    return IA[e];
  });
}
function Nm(t) {
  var e = un(t), n = e.pageXOffset, o = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: o
  };
}
function Bm(t) {
  return fs(Fr(t)).left + Nm(t).scrollLeft;
}
function DA(t, e) {
  var n = un(t), o = Fr(t), r = n.visualViewport, i = o.clientWidth, s = o.clientHeight, a = 0, l = 0;
  if (r) {
    i = r.width, s = r.height;
    var c = h2();
    (c || !c && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: a + Bm(t),
    y: l
  };
}
function RA(t) {
  var e, n = Fr(t), o = Nm(t), r = (e = t.ownerDocument) == null ? void 0 : e.body, i = ci(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), s = ci(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -o.scrollLeft + Bm(t), l = -o.scrollTop;
  return $o(r || n).direction === "rtl" && (a += ci(n.clientWidth, r ? r.clientWidth : 0) - i), {
    width: i,
    height: s,
    x: a,
    y: l
  };
}
function $m(t) {
  var e = $o(t), n = e.overflow, o = e.overflowX, r = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + r + o);
}
function b2(t) {
  return ["html", "body", "#document"].indexOf(io(t)) >= 0 ? t.ownerDocument.body : En(t) && $m(t) ? t : b2(mu(t));
}
function pa(t, e) {
  var n;
  e === void 0 && (e = []);
  var o = b2(t), r = o === ((n = t.ownerDocument) == null ? void 0 : n.body), i = un(o), s = r ? [i].concat(i.visualViewport || [], $m(o) ? o : []) : o, a = e.concat(s);
  return r ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(pa(mu(s)))
  );
}
function Kp(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function PA(t, e) {
  var n = fs(t, !1, e === "fixed");
  return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n;
}
function C1(t, e, n) {
  return e === u2 ? Kp(DA(t, n)) : gi(e) ? PA(e, n) : Kp(RA(Fr(t)));
}
function LA(t) {
  var e = pa(mu(t)), n = ["absolute", "fixed"].indexOf($o(t).position) >= 0, o = n && En(t) ? xl(t) : t;
  return gi(o) ? e.filter(function(r) {
    return gi(r) && m2(r, o) && io(r) !== "body";
  }) : [];
}
function NA(t, e, n, o) {
  var r = e === "clippingParents" ? LA(t) : [].concat(e), i = [].concat(r, [n]), s = i[0], a = i.reduce(function(l, c) {
    var d = C1(t, c, o);
    return l.top = ci(d.top, l.top), l.right = td(d.right, l.right), l.bottom = td(d.bottom, l.bottom), l.left = ci(d.left, l.left), l;
  }, C1(t, s, o));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function w2(t) {
  var e = t.reference, n = t.element, o = t.placement, r = o ? Zn(o) : null, i = o ? ps(o) : null, s = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (r) {
    case Xt:
      l = {
        x: s,
        y: e.y - n.height
      };
      break;
    case Mn:
      l = {
        x: s,
        y: e.y + e.height
      };
      break;
    case Tn:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case Zt:
      l = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var c = r ? Lm(r) : null;
  if (c != null) {
    var d = c === "y" ? "height" : "width";
    switch (i) {
      case ds:
        l[c] = l[c] - (e[d] / 2 - n[d] / 2);
        break;
      case $a:
        l[c] = l[c] + (e[d] / 2 - n[d] / 2);
        break;
    }
  }
  return l;
}
function za(t, e) {
  e === void 0 && (e = {});
  var n = e, o = n.placement, r = o === void 0 ? t.placement : o, i = n.strategy, s = i === void 0 ? t.strategy : i, a = n.boundary, l = a === void 0 ? oA : a, c = n.rootBoundary, d = c === void 0 ? u2 : c, u = n.elementContext, f = u === void 0 ? qs : u, h = n.altBoundary, m = h === void 0 ? !1 : h, g = n.padding, v = g === void 0 ? 0 : g, y = v2(typeof v != "number" ? v : y2(v, wl)), x = f === qs ? rA : qs, C = t.rects.popper, b = t.elements[m ? x : f], S = NA(gi(b) ? b : b.contextElement || Fr(t.elements.popper), l, d, s), A = fs(t.elements.reference), I = w2({
    reference: A,
    element: C,
    strategy: "absolute",
    placement: r
  }), z = Kp(Object.assign({}, C, I)), N = f === qs ? z : A, M = {
    top: S.top - N.top + y.top,
    bottom: N.bottom - S.bottom + y.bottom,
    left: S.left - N.left + y.left,
    right: N.right - S.right + y.right
  }, $ = t.modifiersData.offset;
  if (f === qs && $) {
    var L = $[r];
    Object.keys(M).forEach(function(Y) {
      var J = [Tn, Mn].indexOf(Y) >= 0 ? 1 : -1, ne = [Xt, Mn].indexOf(Y) >= 0 ? "y" : "x";
      M[Y] += L[ne] * J;
    });
  }
  return M;
}
function BA(t, e) {
  e === void 0 && (e = {});
  var n = e, o = n.placement, r = n.boundary, i = n.rootBoundary, s = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? f2 : l, d = ps(o), u = d ? a ? b1 : b1.filter(function(m) {
    return ps(m) === d;
  }) : wl, f = u.filter(function(m) {
    return c.indexOf(m) >= 0;
  });
  f.length === 0 && (f = u);
  var h = f.reduce(function(m, g) {
    return m[g] = za(t, {
      placement: g,
      boundary: r,
      rootBoundary: i,
      padding: s
    })[Zn(g)], m;
  }, {});
  return Object.keys(h).sort(function(m, g) {
    return h[m] - h[g];
  });
}
function $A(t) {
  if (Zn(t) === Dm)
    return [];
  var e = Mc(t);
  return [k1(t), e, k1(e)];
}
function zA(t) {
  var e = t.state, n = t.options, o = t.name;
  if (!e.modifiersData[o]._skip) {
    for (var r = n.mainAxis, i = r === void 0 ? !0 : r, s = n.altAxis, a = s === void 0 ? !0 : s, l = n.fallbackPlacements, c = n.padding, d = n.boundary, u = n.rootBoundary, f = n.altBoundary, h = n.flipVariations, m = h === void 0 ? !0 : h, g = n.allowedAutoPlacements, v = e.options.placement, y = Zn(v), x = y === v, C = l || (x || !m ? [Mc(v)] : $A(v)), b = [v].concat(C).reduce(function(be, we) {
      return be.concat(Zn(we) === Dm ? BA(e, {
        placement: we,
        boundary: d,
        rootBoundary: u,
        padding: c,
        flipVariations: m,
        allowedAutoPlacements: g
      }) : we);
    }, []), S = e.rects.reference, A = e.rects.popper, I = /* @__PURE__ */ new Map(), z = !0, N = b[0], M = 0; M < b.length; M++) {
      var $ = b[M], L = Zn($), Y = ps($) === ds, J = [Xt, Mn].indexOf(L) >= 0, ne = J ? "width" : "height", F = za(e, {
        placement: $,
        boundary: d,
        rootBoundary: u,
        altBoundary: f,
        padding: c
      }), R = J ? Y ? Tn : Zt : Y ? Mn : Xt;
      S[ne] > A[ne] && (R = Mc(R));
      var H = Mc(R), K = [];
      if (i && K.push(F[L] <= 0), a && K.push(F[R] <= 0, F[H] <= 0), K.every(function(be) {
        return be;
      })) {
        N = $, z = !1;
        break;
      }
      I.set($, K);
    }
    if (z)
      for (var Q = m ? 3 : 1, Z = function(we) {
        var Re = b.find(function(Ie) {
          var Ge = I.get(Ie);
          if (Ge)
            return Ge.slice(0, we).every(function(gt) {
              return gt;
            });
        });
        if (Re)
          return N = Re, "break";
      }, ue = Q; ue > 0; ue--) {
        var Se = Z(ue);
        if (Se === "break")
          break;
      }
    e.placement !== N && (e.modifiersData[o]._skip = !0, e.placement = N, e.reset = !0);
  }
}
const FA = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: zA,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function S1(t, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - n.y,
    right: t.right - e.width + n.x,
    bottom: t.bottom - e.height + n.y,
    left: t.left - e.width - n.x
  };
}
function A1(t) {
  return [Xt, Tn, Mn, Zt].some(function(e) {
    return t[e] >= 0;
  });
}
function HA(t) {
  var e = t.state, n = t.name, o = e.rects.reference, r = e.rects.popper, i = e.modifiersData.preventOverflow, s = za(e, {
    elementContext: "reference"
  }), a = za(e, {
    altBoundary: !0
  }), l = S1(s, o), c = S1(a, r, i), d = A1(l), u = A1(c);
  e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: d,
    hasPopperEscaped: u
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": d,
    "data-popper-escaped": u
  });
}
const VA = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: HA
};
function jA(t, e, n) {
  var o = Zn(t), r = [Zt, Xt].indexOf(o) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t
  })) : n, s = i[0], a = i[1];
  return s = s || 0, a = (a || 0) * r, [Zt, Tn].indexOf(o) >= 0 ? {
    x: a,
    y: s
  } : {
    x: s,
    y: a
  };
}
function UA(t) {
  var e = t.state, n = t.options, o = t.name, r = n.offset, i = r === void 0 ? [0, 0] : r, s = f2.reduce(function(d, u) {
    return d[u] = jA(u, e.rects, i), d;
  }, {}), a = s[e.placement], l = a.x, c = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[o] = s;
}
const WA = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: UA
};
function KA(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = w2({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const qA = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: KA,
  data: {}
};
function GA(t) {
  return t === "x" ? "y" : "x";
}
function JA(t) {
  var e = t.state, n = t.options, o = t.name, r = n.mainAxis, i = r === void 0 ? !0 : r, s = n.altAxis, a = s === void 0 ? !1 : s, l = n.boundary, c = n.rootBoundary, d = n.altBoundary, u = n.padding, f = n.tether, h = f === void 0 ? !0 : f, m = n.tetherOffset, g = m === void 0 ? 0 : m, v = za(e, {
    boundary: l,
    rootBoundary: c,
    padding: u,
    altBoundary: d
  }), y = Zn(e.placement), x = ps(e.placement), C = !x, b = Lm(y), S = GA(b), A = e.modifiersData.popperOffsets, I = e.rects.reference, z = e.rects.popper, N = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, M = typeof N == "number" ? {
    mainAxis: N,
    altAxis: N
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, N), $ = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, L = {
    x: 0,
    y: 0
  };
  if (A) {
    if (i) {
      var Y, J = b === "y" ? Xt : Zt, ne = b === "y" ? Mn : Tn, F = b === "y" ? "height" : "width", R = A[b], H = R + v[J], K = R - v[ne], Q = h ? -z[F] / 2 : 0, Z = x === ds ? I[F] : z[F], ue = x === ds ? -z[F] : -I[F], Se = e.elements.arrow, be = h && Se ? Pm(Se) : {
        width: 0,
        height: 0
      }, we = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : g2(), Re = we[J], Ie = we[ne], Ge = fa(0, I[F], be[F]), gt = C ? I[F] / 2 - Q - Ge - Re - M.mainAxis : Z - Ge - Re - M.mainAxis, We = C ? -I[F] / 2 + Q + Ge + Ie + M.mainAxis : ue + Ge + Ie + M.mainAxis, Ft = e.elements.arrow && xl(e.elements.arrow), mn = Ft ? b === "y" ? Ft.clientTop || 0 : Ft.clientLeft || 0 : 0, Rn = (Y = $ == null ? void 0 : $[b]) != null ? Y : 0, go = R + gt - Rn - mn, Ur = R + We - Rn, Lt = fa(h ? td(H, go) : H, R, h ? ci(K, Ur) : K);
      A[b] = Lt, L[b] = Lt - R;
    }
    if (a) {
      var Wr, Yo = b === "x" ? Xt : Zt, me = b === "x" ? Mn : Tn, gn = A[S], tt = S === "y" ? "height" : "width", je = gn + v[Yo], vn = gn - v[me], tn = [Xt, Zt].indexOf(y) !== -1, Xo = (Wr = $ == null ? void 0 : $[S]) != null ? Wr : 0, Zo = tn ? je : gn - I[tt] - z[tt] - Xo + M.altAxis, te = tn ? gn + I[tt] + z[tt] - Xo - M.altAxis : vn, re = h && tn ? bA(Zo, gn, te) : fa(h ? Zo : je, gn, h ? te : vn);
      A[S] = re, L[S] = re - gn;
    }
    e.modifiersData[o] = L;
  }
}
const YA = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: JA,
  requiresIfExists: ["offset"]
};
function XA(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function ZA(t) {
  return t === un(t) || !En(t) ? Nm(t) : XA(t);
}
function QA(t) {
  var e = t.getBoundingClientRect(), n = us(e.width) / t.offsetWidth || 1, o = us(e.height) / t.offsetHeight || 1;
  return n !== 1 || o !== 1;
}
function e7(t, e, n) {
  n === void 0 && (n = !1);
  var o = En(e), r = En(e) && QA(e), i = Fr(e), s = fs(t, r, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (o || !o && !n) && ((io(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  $m(i)) && (a = ZA(e)), En(e) ? (l = fs(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : i && (l.x = Bm(i))), {
    x: s.left + a.scrollLeft - l.x,
    y: s.top + a.scrollTop - l.y,
    width: s.width,
    height: s.height
  };
}
function t7(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), o = [];
  t.forEach(function(i) {
    e.set(i.name, i);
  });
  function r(i) {
    n.add(i.name);
    var s = [].concat(i.requires || [], i.requiresIfExists || []);
    s.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && r(l);
      }
    }), o.push(i);
  }
  return t.forEach(function(i) {
    n.has(i.name) || r(i);
  }), o;
}
function n7(t) {
  var e = t7(t);
  return hA.reduce(function(n, o) {
    return n.concat(e.filter(function(r) {
      return r.phase === o;
    }));
  }, []);
}
function o7(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function r7(t) {
  var e = t.reduce(function(n, o) {
    var r = n[o.name];
    return n[o.name] = r ? Object.assign({}, r, o, {
      options: Object.assign({}, r.options, o.options),
      data: Object.assign({}, r.data, o.data)
    }) : o, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var E1 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function _1() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(o) {
    return !(o && typeof o.getBoundingClientRect == "function");
  });
}
function i7(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, o = n === void 0 ? [] : n, r = e.defaultOptions, i = r === void 0 ? E1 : r;
  return function(a, l, c) {
    c === void 0 && (c = i);
    var d = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, E1, i),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, u = [], f = !1, h = {
      state: d,
      setOptions: function(y) {
        var x = typeof y == "function" ? y(d.options) : y;
        g(), d.options = Object.assign({}, i, d.options, x), d.scrollParents = {
          reference: gi(a) ? pa(a) : a.contextElement ? pa(a.contextElement) : [],
          popper: pa(l)
        };
        var C = n7(r7([].concat(o, d.options.modifiers)));
        return d.orderedModifiers = C.filter(function(b) {
          return b.enabled;
        }), m(), h.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var y = d.elements, x = y.reference, C = y.popper;
          if (_1(x, C)) {
            d.rects = {
              reference: e7(x, xl(C), d.options.strategy === "fixed"),
              popper: Pm(C)
            }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function(M) {
              return d.modifiersData[M.name] = Object.assign({}, M.data);
            });
            for (var b = 0; b < d.orderedModifiers.length; b++) {
              if (d.reset === !0) {
                d.reset = !1, b = -1;
                continue;
              }
              var S = d.orderedModifiers[b], A = S.fn, I = S.options, z = I === void 0 ? {} : I, N = S.name;
              typeof A == "function" && (d = A({
                state: d,
                options: z,
                name: N,
                instance: h
              }) || d);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: o7(function() {
        return new Promise(function(v) {
          h.forceUpdate(), v(d);
        });
      }),
      destroy: function() {
        g(), f = !0;
      }
    };
    if (!_1(a, l))
      return h;
    h.setOptions(c).then(function(v) {
      !f && c.onFirstUpdate && c.onFirstUpdate(v);
    });
    function m() {
      d.orderedModifiers.forEach(function(v) {
        var y = v.name, x = v.options, C = x === void 0 ? {} : x, b = v.effect;
        if (typeof b == "function") {
          var S = b({
            state: d,
            name: y,
            instance: h,
            options: C
          }), A = function() {
          };
          u.push(S || A);
        }
      });
    }
    function g() {
      u.forEach(function(v) {
        return v();
      }), u = [];
    }
    return h;
  };
}
var s7 = [TA, qA, _A, p2, WA, FA, YA, CA, VA], a7 = /* @__PURE__ */ i7({
  defaultModifiers: s7
}), l7 = "tippy-box", x2 = "tippy-content", c7 = "tippy-backdrop", k2 = "tippy-arrow", C2 = "tippy-svg-arrow", Jr = {
  passive: !0,
  capture: !0
}, S2 = function() {
  return document.body;
};
function d7(t, e) {
  return {}.hasOwnProperty.call(t, e);
}
function Sf(t, e, n) {
  if (Array.isArray(t)) {
    var o = t[e];
    return o ?? (Array.isArray(n) ? n[e] : n);
  }
  return t;
}
function zm(t, e) {
  var n = {}.toString.call(t);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function A2(t, e) {
  return typeof t == "function" ? t.apply(void 0, e) : t;
}
function M1(t, e) {
  if (e === 0)
    return t;
  var n;
  return function(o) {
    clearTimeout(n), n = setTimeout(function() {
      t(o);
    }, e);
  };
}
function u7(t, e) {
  var n = Object.assign({}, t);
  return e.forEach(function(o) {
    delete n[o];
  }), n;
}
function f7(t) {
  return t.split(/\s+/).filter(Boolean);
}
function Ui(t) {
  return [].concat(t);
}
function T1(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function p7(t) {
  return t.filter(function(e, n) {
    return t.indexOf(e) === n;
  });
}
function h7(t) {
  return t.split("-")[0];
}
function nd(t) {
  return [].slice.call(t);
}
function O1(t) {
  return Object.keys(t).reduce(function(e, n) {
    return t[n] !== void 0 && (e[n] = t[n]), e;
  }, {});
}
function ha() {
  return document.createElement("div");
}
function Fa(t) {
  return ["Element", "Fragment"].some(function(e) {
    return zm(t, e);
  });
}
function m7(t) {
  return zm(t, "NodeList");
}
function g7(t) {
  return zm(t, "MouseEvent");
}
function v7(t) {
  return !!(t && t._tippy && t._tippy.reference === t);
}
function y7(t) {
  return Fa(t) ? [t] : m7(t) ? nd(t) : Array.isArray(t) ? t : nd(document.querySelectorAll(t));
}
function Af(t, e) {
  t.forEach(function(n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function I1(t, e) {
  t.forEach(function(n) {
    n && n.setAttribute("data-state", e);
  });
}
function b7(t) {
  var e, n = Ui(t), o = n[0];
  return o != null && (e = o.ownerDocument) != null && e.body ? o.ownerDocument : document;
}
function w7(t, e) {
  var n = e.clientX, o = e.clientY;
  return t.every(function(r) {
    var i = r.popperRect, s = r.popperState, a = r.props, l = a.interactiveBorder, c = h7(s.placement), d = s.modifiersData.offset;
    if (!d)
      return !0;
    var u = c === "bottom" ? d.top.y : 0, f = c === "top" ? d.bottom.y : 0, h = c === "right" ? d.left.x : 0, m = c === "left" ? d.right.x : 0, g = i.top - o + u > l, v = o - i.bottom - f > l, y = i.left - n + h > l, x = n - i.right - m > l;
    return g || v || y || x;
  });
}
function Ef(t, e, n) {
  var o = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(r) {
    t[o](r, n);
  });
}
function D1(t, e) {
  for (var n = e; n; ) {
    var o;
    if (t.contains(n))
      return !0;
    n = n.getRootNode == null || (o = n.getRootNode()) == null ? void 0 : o.host;
  }
  return !1;
}
var Gn = {
  isTouch: !1
}, R1 = 0;
function x7() {
  Gn.isTouch || (Gn.isTouch = !0, window.performance && document.addEventListener("mousemove", E2));
}
function E2() {
  var t = performance.now();
  t - R1 < 20 && (Gn.isTouch = !1, document.removeEventListener("mousemove", E2)), R1 = t;
}
function k7() {
  var t = document.activeElement;
  if (v7(t)) {
    var e = t._tippy;
    t.blur && !e.state.isVisible && t.blur();
  }
}
function C7() {
  document.addEventListener("touchstart", x7, Jr), window.addEventListener("blur", k7);
}
var S7 = typeof window < "u" && typeof document < "u", A7 = S7 ? (
  // @ts-ignore
  !!window.msCrypto
) : !1;
function $i(t) {
  var e = t === "destroy" ? "n already-" : " ";
  return [t + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function P1(t) {
  var e = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return t.replace(e, " ").replace(n, "").trim();
}
function E7(t) {
  return P1(`
  %ctippy.js

  %c` + P1(t) + `

  %c👷‍ This is a development-only message. It will be removed in production.
  `);
}
function _2(t) {
  return [
    E7(t),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var Ha;
process.env.NODE_ENV !== "production" && _7();
function _7() {
  Ha = /* @__PURE__ */ new Set();
}
function Ao(t, e) {
  if (t && !Ha.has(e)) {
    var n;
    Ha.add(e), (n = console).warn.apply(n, _2(e));
  }
}
function qp(t, e) {
  if (t && !Ha.has(e)) {
    var n;
    Ha.add(e), (n = console).error.apply(n, _2(e));
  }
}
function M7(t) {
  var e = !t, n = Object.prototype.toString.call(t) === "[object Object]" && !t.addEventListener;
  qp(e, ["tippy() was passed", "`" + String(t) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), qp(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var M2 = {
  animateFill: !1,
  followCursor: !1,
  inlinePositioning: !1,
  sticky: !1
}, T7 = {
  allowHTML: !1,
  animation: "fade",
  arrow: !0,
  content: "",
  inertia: !1,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
}, an = Object.assign({
  appendTo: S2,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: !0,
  ignoreAttributes: !1,
  interactive: !1,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: !1,
  touch: !0,
  trigger: "mouseenter focus",
  triggerTarget: null
}, M2, T7), O7 = Object.keys(an), I7 = function(e) {
  process.env.NODE_ENV !== "production" && O2(e, []);
  var n = Object.keys(e);
  n.forEach(function(o) {
    an[o] = e[o];
  });
};
function T2(t) {
  var e = t.plugins || [], n = e.reduce(function(o, r) {
    var i = r.name, s = r.defaultValue;
    if (i) {
      var a;
      o[i] = t[i] !== void 0 ? t[i] : (a = an[i]) != null ? a : s;
    }
    return o;
  }, {});
  return Object.assign({}, t, n);
}
function D7(t, e) {
  var n = e ? Object.keys(T2(Object.assign({}, an, {
    plugins: e
  }))) : O7, o = n.reduce(function(r, i) {
    var s = (t.getAttribute("data-tippy-" + i) || "").trim();
    if (!s)
      return r;
    if (i === "content")
      r[i] = s;
    else
      try {
        r[i] = JSON.parse(s);
      } catch {
        r[i] = s;
      }
    return r;
  }, {});
  return o;
}
function L1(t, e) {
  var n = Object.assign({}, e, {
    content: A2(e.content, [t])
  }, e.ignoreAttributes ? {} : D7(t, e.plugins));
  return n.aria = Object.assign({}, an.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function O2(t, e) {
  t === void 0 && (t = {}), e === void 0 && (e = []);
  var n = Object.keys(t);
  n.forEach(function(o) {
    var r = u7(an, Object.keys(M2)), i = !d7(r, o);
    i && (i = e.filter(function(s) {
      return s.name === o;
    }).length === 0), Ao(i, ["`" + o + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var R7 = function() {
  return "innerHTML";
};
function Gp(t, e) {
  t[R7()] = e;
}
function N1(t) {
  var e = ha();
  return t === !0 ? e.className = k2 : (e.className = C2, Fa(t) ? e.appendChild(t) : Gp(e, t)), e;
}
function B1(t, e) {
  Fa(e.content) ? (Gp(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? Gp(t, e.content) : t.textContent = e.content);
}
function Jp(t) {
  var e = t.firstElementChild, n = nd(e.children);
  return {
    box: e,
    content: n.find(function(o) {
      return o.classList.contains(x2);
    }),
    arrow: n.find(function(o) {
      return o.classList.contains(k2) || o.classList.contains(C2);
    }),
    backdrop: n.find(function(o) {
      return o.classList.contains(c7);
    })
  };
}
function I2(t) {
  var e = ha(), n = ha();
  n.className = l7, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var o = ha();
  o.className = x2, o.setAttribute("data-state", "hidden"), B1(o, t.props), e.appendChild(n), n.appendChild(o), r(t.props, t.props);
  function r(i, s) {
    var a = Jp(e), l = a.box, c = a.content, d = a.arrow;
    s.theme ? l.setAttribute("data-theme", s.theme) : l.removeAttribute("data-theme"), typeof s.animation == "string" ? l.setAttribute("data-animation", s.animation) : l.removeAttribute("data-animation"), s.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth, s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"), (i.content !== s.content || i.allowHTML !== s.allowHTML) && B1(c, t.props), s.arrow ? d ? i.arrow !== s.arrow && (l.removeChild(d), l.appendChild(N1(s.arrow))) : l.appendChild(N1(s.arrow)) : d && l.removeChild(d);
  }
  return {
    popper: e,
    onUpdate: r
  };
}
I2.$$tippy = !0;
var P7 = 1, Wl = [], _f = [];
function L7(t, e) {
  var n = L1(t, Object.assign({}, an, T2(O1(e)))), o, r, i, s = !1, a = !1, l = !1, c = !1, d, u, f, h = [], m = M1(go, n.interactiveDebounce), g, v = P7++, y = null, x = p7(n.plugins), C = {
    // Is the instance currently enabled?
    isEnabled: !0,
    // Is the tippy currently showing and not transitioning out?
    isVisible: !1,
    // Has the instance been destroyed?
    isDestroyed: !1,
    // Is the tippy currently mounted to the DOM?
    isMounted: !1,
    // Has the tippy finished transitioning in?
    isShown: !1
  }, b = {
    // properties
    id: v,
    reference: t,
    popper: ha(),
    popperInstance: y,
    props: n,
    state: C,
    plugins: x,
    // methods
    clearDelayTimeouts: Zo,
    setProps: te,
    setContent: re,
    show: ke,
    hide: Ue,
    hideWithInteractivity: bt,
    enable: tn,
    disable: Xo,
    unmount: Pn,
    destroy: nf
  };
  if (!n.render)
    return process.env.NODE_ENV !== "production" && qp(!0, "render() function has not been supplied."), b;
  var S = n.render(b), A = S.popper, I = S.onUpdate;
  A.setAttribute("data-tippy-root", ""), A.id = "tippy-" + b.id, b.popper = A, t._tippy = b, A._tippy = b;
  var z = x.map(function(V) {
    return V.fn(b);
  }), N = t.hasAttribute("aria-expanded");
  return Ft(), Q(), R(), H("onCreate", [b]), n.showOnCreate && je(), A.addEventListener("mouseenter", function() {
    b.props.interactive && b.state.isVisible && b.clearDelayTimeouts();
  }), A.addEventListener("mouseleave", function() {
    b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && J().addEventListener("mousemove", m);
  }), b;
  function M() {
    var V = b.props.touch;
    return Array.isArray(V) ? V : [V, 0];
  }
  function $() {
    return M()[0] === "hold";
  }
  function L() {
    var V;
    return !!((V = b.props.render) != null && V.$$tippy);
  }
  function Y() {
    return g || t;
  }
  function J() {
    var V = Y().parentNode;
    return V ? b7(V) : document;
  }
  function ne() {
    return Jp(A);
  }
  function F(V) {
    return b.state.isMounted && !b.state.isVisible || Gn.isTouch || d && d.type === "focus" ? 0 : Sf(b.props.delay, V ? 0 : 1, an.delay);
  }
  function R(V) {
    V === void 0 && (V = !1), A.style.pointerEvents = b.props.interactive && !V ? "" : "none", A.style.zIndex = "" + b.props.zIndex;
  }
  function H(V, ie, ge) {
    if (ge === void 0 && (ge = !0), z.forEach(function($e) {
      $e[V] && $e[V].apply($e, ie);
    }), ge) {
      var Ke;
      (Ke = b.props)[V].apply(Ke, ie);
    }
  }
  function K() {
    var V = b.props.aria;
    if (V.content) {
      var ie = "aria-" + V.content, ge = A.id, Ke = Ui(b.props.triggerTarget || t);
      Ke.forEach(function($e) {
        var Ht = $e.getAttribute(ie);
        if (b.state.isVisible)
          $e.setAttribute(ie, Ht ? Ht + " " + ge : ge);
        else {
          var yn = Ht && Ht.replace(ge, "").trim();
          yn ? $e.setAttribute(ie, yn) : $e.removeAttribute(ie);
        }
      });
    }
  }
  function Q() {
    if (!(N || !b.props.aria.expanded)) {
      var V = Ui(b.props.triggerTarget || t);
      V.forEach(function(ie) {
        b.props.interactive ? ie.setAttribute("aria-expanded", b.state.isVisible && ie === Y() ? "true" : "false") : ie.removeAttribute("aria-expanded");
      });
    }
  }
  function Z() {
    J().removeEventListener("mousemove", m), Wl = Wl.filter(function(V) {
      return V !== m;
    });
  }
  function ue(V) {
    if (!(Gn.isTouch && (l || V.type === "mousedown"))) {
      var ie = V.composedPath && V.composedPath()[0] || V.target;
      if (!(b.props.interactive && D1(A, ie))) {
        if (Ui(b.props.triggerTarget || t).some(function(ge) {
          return D1(ge, ie);
        })) {
          if (Gn.isTouch || b.state.isVisible && b.props.trigger.indexOf("click") >= 0)
            return;
        } else
          H("onClickOutside", [b, V]);
        b.props.hideOnClick === !0 && (b.clearDelayTimeouts(), b.hide(), a = !0, setTimeout(function() {
          a = !1;
        }), b.state.isMounted || Re());
      }
    }
  }
  function Se() {
    l = !0;
  }
  function be() {
    l = !1;
  }
  function we() {
    var V = J();
    V.addEventListener("mousedown", ue, !0), V.addEventListener("touchend", ue, Jr), V.addEventListener("touchstart", be, Jr), V.addEventListener("touchmove", Se, Jr);
  }
  function Re() {
    var V = J();
    V.removeEventListener("mousedown", ue, !0), V.removeEventListener("touchend", ue, Jr), V.removeEventListener("touchstart", be, Jr), V.removeEventListener("touchmove", Se, Jr);
  }
  function Ie(V, ie) {
    gt(V, function() {
      !b.state.isVisible && A.parentNode && A.parentNode.contains(A) && ie();
    });
  }
  function Ge(V, ie) {
    gt(V, ie);
  }
  function gt(V, ie) {
    var ge = ne().box;
    function Ke($e) {
      $e.target === ge && (Ef(ge, "remove", Ke), ie());
    }
    if (V === 0)
      return ie();
    Ef(ge, "remove", u), Ef(ge, "add", Ke), u = Ke;
  }
  function We(V, ie, ge) {
    ge === void 0 && (ge = !1);
    var Ke = Ui(b.props.triggerTarget || t);
    Ke.forEach(function($e) {
      $e.addEventListener(V, ie, ge), h.push({
        node: $e,
        eventType: V,
        handler: ie,
        options: ge
      });
    });
  }
  function Ft() {
    $() && (We("touchstart", Rn, {
      passive: !0
    }), We("touchend", Ur, {
      passive: !0
    })), f7(b.props.trigger).forEach(function(V) {
      if (V !== "manual")
        switch (We(V, Rn), V) {
          case "mouseenter":
            We("mouseleave", Ur);
            break;
          case "focus":
            We(A7 ? "focusout" : "blur", Lt);
            break;
          case "focusin":
            We("focusout", Lt);
            break;
        }
    });
  }
  function mn() {
    h.forEach(function(V) {
      var ie = V.node, ge = V.eventType, Ke = V.handler, $e = V.options;
      ie.removeEventListener(ge, Ke, $e);
    }), h = [];
  }
  function Rn(V) {
    var ie, ge = !1;
    if (!(!b.state.isEnabled || Wr(V) || a)) {
      var Ke = ((ie = d) == null ? void 0 : ie.type) === "focus";
      d = V, g = V.currentTarget, Q(), !b.state.isVisible && g7(V) && Wl.forEach(function($e) {
        return $e(V);
      }), V.type === "click" && (b.props.trigger.indexOf("mouseenter") < 0 || s) && b.props.hideOnClick !== !1 && b.state.isVisible ? ge = !0 : je(V), V.type === "click" && (s = !ge), ge && !Ke && vn(V);
    }
  }
  function go(V) {
    var ie = V.target, ge = Y().contains(ie) || A.contains(ie);
    if (!(V.type === "mousemove" && ge)) {
      var Ke = tt().concat(A).map(function($e) {
        var Ht, yn = $e._tippy, Ri = (Ht = yn.popperInstance) == null ? void 0 : Ht.state;
        return Ri ? {
          popperRect: $e.getBoundingClientRect(),
          popperState: Ri,
          props: n
        } : null;
      }).filter(Boolean);
      w7(Ke, V) && (Z(), vn(V));
    }
  }
  function Ur(V) {
    var ie = Wr(V) || b.props.trigger.indexOf("click") >= 0 && s;
    if (!ie) {
      if (b.props.interactive) {
        b.hideWithInteractivity(V);
        return;
      }
      vn(V);
    }
  }
  function Lt(V) {
    b.props.trigger.indexOf("focusin") < 0 && V.target !== Y() || b.props.interactive && V.relatedTarget && A.contains(V.relatedTarget) || vn(V);
  }
  function Wr(V) {
    return Gn.isTouch ? $() !== V.type.indexOf("touch") >= 0 : !1;
  }
  function Yo() {
    me();
    var V = b.props, ie = V.popperOptions, ge = V.placement, Ke = V.offset, $e = V.getReferenceClientRect, Ht = V.moveTransition, yn = L() ? Jp(A).arrow : null, Ri = $e ? {
      getBoundingClientRect: $e,
      contextElement: $e.contextElement || Y()
    } : t, f0 = {
      name: "$$tippy",
      enabled: !0,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Ll) {
        var Pi = Ll.state;
        if (L()) {
          var J6 = ne(), rf = J6.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(Nl) {
            Nl === "placement" ? rf.setAttribute("data-placement", Pi.placement) : Pi.attributes.popper["data-popper-" + Nl] ? rf.setAttribute("data-" + Nl, "") : rf.removeAttribute("data-" + Nl);
          }), Pi.attributes.popper = {};
        }
      }
    }, Kr = [{
      name: "offset",
      options: {
        offset: Ke
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !Ht
      }
    }, f0];
    L() && yn && Kr.push({
      name: "arrow",
      options: {
        element: yn,
        padding: 3
      }
    }), Kr.push.apply(Kr, (ie == null ? void 0 : ie.modifiers) || []), b.popperInstance = a7(Ri, A, Object.assign({}, ie, {
      placement: ge,
      onFirstUpdate: f,
      modifiers: Kr
    }));
  }
  function me() {
    b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null);
  }
  function gn() {
    var V = b.props.appendTo, ie, ge = Y();
    b.props.interactive && V === S2 || V === "parent" ? ie = ge.parentNode : ie = A2(V, [ge]), ie.contains(A) || ie.appendChild(A), b.state.isMounted = !0, Yo(), process.env.NODE_ENV !== "production" && Ao(b.props.interactive && V === an.appendTo && ge.nextElementSibling !== A, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function tt() {
    return nd(A.querySelectorAll("[data-tippy-root]"));
  }
  function je(V) {
    b.clearDelayTimeouts(), V && H("onTrigger", [b, V]), we();
    var ie = F(!0), ge = M(), Ke = ge[0], $e = ge[1];
    Gn.isTouch && Ke === "hold" && $e && (ie = $e), ie ? o = setTimeout(function() {
      b.show();
    }, ie) : b.show();
  }
  function vn(V) {
    if (b.clearDelayTimeouts(), H("onUntrigger", [b, V]), !b.state.isVisible) {
      Re();
      return;
    }
    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(V.type) >= 0 && s)) {
      var ie = F(!1);
      ie ? r = setTimeout(function() {
        b.state.isVisible && b.hide();
      }, ie) : i = requestAnimationFrame(function() {
        b.hide();
      });
    }
  }
  function tn() {
    b.state.isEnabled = !0;
  }
  function Xo() {
    b.hide(), b.state.isEnabled = !1;
  }
  function Zo() {
    clearTimeout(o), clearTimeout(r), cancelAnimationFrame(i);
  }
  function te(V) {
    if (process.env.NODE_ENV !== "production" && Ao(b.state.isDestroyed, $i("setProps")), !b.state.isDestroyed) {
      H("onBeforeUpdate", [b, V]), mn();
      var ie = b.props, ge = L1(t, Object.assign({}, ie, O1(V), {
        ignoreAttributes: !0
      }));
      b.props = ge, Ft(), ie.interactiveDebounce !== ge.interactiveDebounce && (Z(), m = M1(go, ge.interactiveDebounce)), ie.triggerTarget && !ge.triggerTarget ? Ui(ie.triggerTarget).forEach(function(Ke) {
        Ke.removeAttribute("aria-expanded");
      }) : ge.triggerTarget && t.removeAttribute("aria-expanded"), Q(), R(), I && I(ie, ge), b.popperInstance && (Yo(), tt().forEach(function(Ke) {
        requestAnimationFrame(Ke._tippy.popperInstance.forceUpdate);
      })), H("onAfterUpdate", [b, V]);
    }
  }
  function re(V) {
    b.setProps({
      content: V
    });
  }
  function ke() {
    process.env.NODE_ENV !== "production" && Ao(b.state.isDestroyed, $i("show"));
    var V = b.state.isVisible, ie = b.state.isDestroyed, ge = !b.state.isEnabled, Ke = Gn.isTouch && !b.props.touch, $e = Sf(b.props.duration, 0, an.duration);
    if (!(V || ie || ge || Ke) && !Y().hasAttribute("disabled") && (H("onShow", [b], !1), b.props.onShow(b) !== !1)) {
      if (b.state.isVisible = !0, L() && (A.style.visibility = "visible"), R(), we(), b.state.isMounted || (A.style.transition = "none"), L()) {
        var Ht = ne(), yn = Ht.box, Ri = Ht.content;
        Af([yn, Ri], 0);
      }
      f = function() {
        var Kr;
        if (!(!b.state.isVisible || c)) {
          if (c = !0, A.offsetHeight, A.style.transition = b.props.moveTransition, L() && b.props.animation) {
            var of = ne(), Ll = of.box, Pi = of.content;
            Af([Ll, Pi], $e), I1([Ll, Pi], "visible");
          }
          K(), Q(), T1(_f, b), (Kr = b.popperInstance) == null || Kr.forceUpdate(), H("onMount", [b]), b.props.animation && L() && Ge($e, function() {
            b.state.isShown = !0, H("onShown", [b]);
          });
        }
      }, gn();
    }
  }
  function Ue() {
    process.env.NODE_ENV !== "production" && Ao(b.state.isDestroyed, $i("hide"));
    var V = !b.state.isVisible, ie = b.state.isDestroyed, ge = !b.state.isEnabled, Ke = Sf(b.props.duration, 1, an.duration);
    if (!(V || ie || ge) && (H("onHide", [b], !1), b.props.onHide(b) !== !1)) {
      if (b.state.isVisible = !1, b.state.isShown = !1, c = !1, s = !1, L() && (A.style.visibility = "hidden"), Z(), Re(), R(!0), L()) {
        var $e = ne(), Ht = $e.box, yn = $e.content;
        b.props.animation && (Af([Ht, yn], Ke), I1([Ht, yn], "hidden"));
      }
      K(), Q(), b.props.animation ? L() && Ie(Ke, b.unmount) : b.unmount();
    }
  }
  function bt(V) {
    process.env.NODE_ENV !== "production" && Ao(b.state.isDestroyed, $i("hideWithInteractivity")), J().addEventListener("mousemove", m), T1(Wl, m), m(V);
  }
  function Pn() {
    process.env.NODE_ENV !== "production" && Ao(b.state.isDestroyed, $i("unmount")), b.state.isVisible && b.hide(), b.state.isMounted && (me(), tt().forEach(function(V) {
      V._tippy.unmount();
    }), A.parentNode && A.parentNode.removeChild(A), _f = _f.filter(function(V) {
      return V !== b;
    }), b.state.isMounted = !1, H("onHidden", [b]));
  }
  function nf() {
    process.env.NODE_ENV !== "production" && Ao(b.state.isDestroyed, $i("destroy")), !b.state.isDestroyed && (b.clearDelayTimeouts(), b.unmount(), mn(), delete t._tippy, b.state.isDestroyed = !0, H("onDestroy", [b]));
  }
}
function Hr(t, e) {
  e === void 0 && (e = {});
  var n = an.plugins.concat(e.plugins || []);
  process.env.NODE_ENV !== "production" && (M7(t), O2(e, n)), C7();
  var o = Object.assign({}, e, {
    plugins: n
  }), r = y7(t);
  if (process.env.NODE_ENV !== "production") {
    var i = Fa(o.content), s = r.length > 1;
    Ao(i && s, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var a = r.reduce(function(l, c) {
    var d = c && L7(c, o);
    return d && l.push(d), l;
  }, []);
  return Fa(t) ? a[0] : a;
}
Hr.defaultProps = an;
Hr.setDefaultProps = I7;
Hr.currentInput = Gn;
Object.assign({}, p2, {
  effect: function(e) {
    var n = e.state, o = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, o.popper), n.styles = o, n.elements.arrow && Object.assign(n.elements.arrow.style, o.arrow);
  }
});
var Fm = {
  name: "sticky",
  defaultValue: !1,
  fn: function(e) {
    var n = e.reference, o = e.popper;
    function r() {
      return e.popperInstance ? e.popperInstance.state.elements.reference : n;
    }
    function i(c) {
      return e.props.sticky === !0 || e.props.sticky === c;
    }
    var s = null, a = null;
    function l() {
      var c = i("reference") ? r().getBoundingClientRect() : null, d = i("popper") ? o.getBoundingClientRect() : null;
      (c && $1(s, c) || d && $1(a, d)) && e.popperInstance && e.popperInstance.update(), s = c, a = d, e.state.isMounted && requestAnimationFrame(l);
    }
    return {
      onMount: function() {
        e.props.sticky && l();
      }
    };
  }
};
function $1(t, e) {
  return t && e ? t.top !== e.top || t.right !== e.right || t.bottom !== e.bottom || t.left !== e.left : !0;
}
Hr.setDefaultProps({
  render: I2
});
class N7 {
  constructor({ editor: e, element: n, view: o, tippyOptions: r = {}, updateDelay: i = 250, shouldShow: s }) {
    this.preventHide = !1, this.shouldShow = ({ view: a, state: l, from: c, to: d }) => {
      const { doc: u, selection: f } = l, { empty: h } = f, m = !u.textBetween(c, d).length && Mm(l.selection), g = this.element.contains(document.activeElement);
      return !(!(a.hasFocus() || g) || h || m || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: a }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (a) => {
      this.blurHandler({ event: a });
    }, this.handleDebouncedUpdate = (a, l) => {
      const c = !(l != null && l.selection.eq(a.state.selection)), d = !(l != null && l.doc.eq(a.state.doc));
      !c && !d || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(a, c, d, l);
      }, this.updateDelay));
    }, this.updateHandler = (a, l, c, d) => {
      var u, f, h;
      const { state: m, composing: g } = a, { selection: v } = m;
      if (g || !l && !c)
        return;
      this.createTooltip();
      const { ranges: x } = v, C = Math.min(...x.map((A) => A.$from.pos)), b = Math.max(...x.map((A) => A.$to.pos));
      if (!((u = this.shouldShow) === null || u === void 0 ? void 0 : u.call(this, {
        editor: this.editor,
        element: this.element,
        view: a,
        state: m,
        oldState: d,
        from: C,
        to: b
      }))) {
        this.hide();
        return;
      }
      (f = this.tippy) === null || f === void 0 || f.setProps({
        getReferenceClientRect: ((h = this.tippyOptions) === null || h === void 0 ? void 0 : h.getReferenceClientRect) || (() => {
          if (a2(m.selection)) {
            let A = a.nodeDOM(C);
            if (A) {
              const I = A.dataset.nodeViewWrapper ? A : A.querySelector("[data-node-view-wrapper]");
              if (I && (A = I.firstChild), A)
                return A.getBoundingClientRect();
            }
          }
          return l2(a, C, b);
        })
      }), this.show();
    }, this.editor = e, this.element = n, this.view = o, this.updateDelay = i, s && (this.shouldShow = s), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = r, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Hr(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    const { state: o } = e, r = o.selection.from !== o.selection.to;
    if (this.updateDelay > 0 && r) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const i = !(n != null && n.selection.eq(e.state.selection)), s = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, i, s, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const D2 = (t) => new Ne({
  key: typeof t.pluginKey == "string" ? new Be(t.pluginKey) : t.pluginKey,
  view: (e) => new N7({ view: e, ...t })
});
Te.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      D2({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
class B7 {
  getTextContent(e) {
    return i2(e, { textSerializers: _m(this.editor.schema) });
  }
  constructor({ editor: e, element: n, view: o, tippyOptions: r = {}, shouldShow: i }) {
    this.preventHide = !1, this.shouldShow = ({ view: s, state: a }) => {
      const { selection: l } = a, { $anchor: c, empty: d } = l, u = c.depth === 1, f = c.parent.isTextblock && !c.parent.type.spec.code && !c.parent.textContent && c.parent.childCount === 0 && !this.getTextContent(c.parent);
      return !(!s.hasFocus() || !d || !u || !f || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: s }) => {
      var a;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      s != null && s.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(s.relatedTarget)) || (s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (s) => {
      this.blurHandler({ event: s });
    }, this.editor = e, this.element = n, this.view = o, i && (this.shouldShow = i), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = r, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Hr(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    var o, r, i;
    const { state: s } = e, { doc: a, selection: l } = s, { from: c, to: d } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l))
      return;
    if (this.createTooltip(), !((o = this.shouldShow) === null || o === void 0 ? void 0 : o.call(this, {
      editor: this.editor,
      view: e,
      state: s,
      oldState: n
    }))) {
      this.hide();
      return;
    }
    (r = this.tippy) === null || r === void 0 || r.setProps({
      getReferenceClientRect: ((i = this.tippyOptions) === null || i === void 0 ? void 0 : i.getReferenceClientRect) || (() => l2(e, c, d))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const R2 = (t) => new Ne({
  key: typeof t.pluginKey == "string" ? new Be(t.pluginKey) : t.pluginKey,
  view: (e) => new B7({ view: e, ...t })
});
Te.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      R2({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
const As = T({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = O(null);
    return _e(() => {
      const { updateDelay: o, editor: r, pluginKey: i, shouldShow: s, tippyOptions: a } = t;
      r.registerPlugin(D2({
        updateDelay: o,
        editor: r,
        element: n.value,
        pluginKey: i,
        shouldShow: s,
        tippyOptions: a
      }));
    }), jo(() => {
      const { pluginKey: o, editor: r } = t;
      r.unregisterPlugin(o);
    }), () => {
      var o;
      return jt("div", { ref: n }, (o = e.default) === null || o === void 0 ? void 0 : o.call(e));
    };
  }
});
function z1(t) {
  return tm((e, n) => ({
    get() {
      return e(), t;
    },
    set(o) {
      t = o, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          n();
        });
      });
    }
  }));
}
class P2 extends c2 {
  constructor(e = {}) {
    return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = z1(this.view.state), this.reactiveExtensionStorage = z1(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
      this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), Vc(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, n) {
    const o = super.registerPlugin(e, n);
    return this.reactiveState && (this.reactiveState.value = o), o;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    const n = super.unregisterPlugin(e);
    return this.reactiveState && n && (this.reactiveState.value = n), n;
  }
}
const $7 = T({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(t) {
    const e = O(), n = In();
    return Pe(() => {
      const o = t.editor;
      o && o.options.element && e.value && qe(() => {
        if (!e.value || !o.options.element.firstChild)
          return;
        const r = p(e.value);
        e.value.append(...o.options.element.childNodes), o.contentComponent = n.ctx._, n && (o.appContext = {
          ...n.appContext,
          // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
          // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
          // @ts-expect-error forward instance's 'provides' into appContext
          provides: n.provides
        }), o.setOptions({
          element: r
        }), o.createNodeViews();
      });
    }), jo(() => {
      const o = t.editor;
      o && (o.contentComponent = null, o.appContext = null);
    }), { rootEl: e };
  },
  render() {
    return jt("div", {
      ref: (t) => {
        this.rootEl = t;
      }
    });
  }
});
T({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: !0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t, { slots: e }) {
    const n = O(null);
    return _e(() => {
      const { pluginKey: o, editor: r, tippyOptions: i, shouldShow: s } = t;
      r.registerPlugin(R2({
        pluginKey: o,
        editor: r,
        element: n.value,
        tippyOptions: i,
        shouldShow: s
      }));
    }), jo(() => {
      const { pluginKey: o, editor: r } = t;
      r.unregisterPlugin(o);
    }), () => {
      var o;
      return jt("div", { ref: n }, (o = e.default) === null || o === void 0 ? void 0 : o.call(e));
    };
  }
});
const z7 = T({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return jt(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
}), kl = T({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var t, e;
    return jt(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (e = (t = this.$slots).default) === null || e === void 0 ? void 0 : e.call(t));
  }
}), nJ = (t = {}) => {
  const e = Xd();
  return _e(() => {
    e.value = new P2(t);
  }), jo(() => {
    var n, o, r;
    const i = (n = e.value) === null || n === void 0 ? void 0 : n.options.element, s = i == null ? void 0 : i.cloneNode(!0);
    (o = i == null ? void 0 : i.parentNode) === null || o === void 0 || o.replaceChild(s, i), (r = e.value) === null || r === void 0 || r.destroy();
  }), e;
};
class L2 {
  constructor(e, { props: n = {}, editor: o }) {
    this.editor = o, this.component = Vc(e), this.el = document.createElement("div"), this.props = zn(n), this.renderedComponent = this.renderComponent();
  }
  get element() {
    return this.renderedComponent.el;
  }
  get ref() {
    var e, n, o, r;
    return !((n = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || n === void 0) && n.exposed ? this.renderedComponent.vNode.component.exposed : (r = (o = this.renderedComponent.vNode) === null || o === void 0 ? void 0 : o.component) === null || r === void 0 ? void 0 : r.proxy;
  }
  renderComponent() {
    let e = jt(this.component, this.props);
    return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && p0(e, this.el), { vNode: e, destroy: () => {
      this.el && p0(null, this.el), this.el = null, e = null;
    }, el: this.el ? this.el.firstElementChild : null };
  }
  updateProps(e = {}) {
    Object.entries(e).forEach(([n, o]) => {
      this.props[n] = o;
    }), this.renderComponent();
  }
  destroy() {
    this.renderedComponent.destroy();
  }
}
const Cl = {
  editor: {
    type: Object,
    required: !0
  },
  node: {
    type: Object,
    required: !0
  },
  decorations: {
    type: Object,
    required: !0
  },
  selected: {
    type: Boolean,
    required: !0
  },
  extension: {
    type: Object,
    required: !0
  },
  getPos: {
    type: Function,
    required: !0
  },
  updateAttributes: {
    type: Function,
    required: !0
  },
  deleteNode: {
    type: Function,
    required: !0
  },
  view: {
    type: Object,
    required: !0
  },
  innerDecorations: {
    type: Object,
    required: !0
  },
  HTMLAttributes: {
    type: Object,
    required: !0
  }
};
class F7 extends tA {
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (r = {}) => this.updateAttributes(r),
      deleteNode: () => this.deleteNode()
    }, n = this.onDragStart.bind(this);
    this.decorationClasses = O(this.getDecorationClasses());
    const o = T({
      extends: { ...this.component },
      props: Object.keys(e),
      template: this.component.template,
      setup: (r) => {
        var i, s;
        return Ma("onDragStart", n), Ma("decorationClasses", this.decorationClasses), (s = (i = this.component).setup) === null || s === void 0 ? void 0 : s.call(i, r, {
          expose: () => {
          }
        });
      },
      // add support for scoped styles
      // @ts-ignore
      // eslint-disable-next-line
      __scopeId: this.component.__scopeId,
      // add support for CSS Modules
      // @ts-ignore
      // eslint-disable-next-line
      __cssModules: this.component.__cssModules,
      // add support for vue devtools
      // @ts-ignore
      // eslint-disable-next-line
      __name: this.component.__name,
      // @ts-ignore
      // eslint-disable-next-line
      __file: this.component.__file
    });
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new L2(o, {
      editor: this.editor,
      props: e
    });
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper"))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]");
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from: e, to: n } = this.editor.state.selection, o = this.getPos();
    if (typeof o == "number")
      if (e <= o && n >= o + this.node.nodeSize) {
        if (this.renderer.props.selected)
          return;
        this.selectNode();
      } else {
        if (!this.renderer.props.selected)
          return;
        this.deselectNode();
      }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, n, o) {
    const r = (i) => {
      this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(i);
    };
    if (typeof this.options.update == "function") {
      const i = this.node, s = this.decorations, a = this.innerDecorations;
      return this.node = e, this.decorations = n, this.innerDecorations = o, this.options.update({
        oldNode: i,
        oldDecorations: s,
        newNode: e,
        newDecorations: n,
        oldInnerDecorations: a,
        innerDecorations: o,
        updateProps: () => r({ node: e, decorations: n, innerDecorations: o })
      });
    }
    return e.type !== this.node.type ? !1 : (e === this.node && this.decorations === n && this.innerDecorations === o || (this.node = e, this.decorations = n, this.innerDecorations = o, r({ node: e, decorations: n, innerDecorations: o })), !0);
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  getDecorationClasses() {
    return this.decorations.map((e) => e.type.attrs.class).flat().join(" ");
  }
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate);
  }
}
function Sl(t, e) {
  return (n) => {
    if (!n.editor.contentComponent)
      return {};
    const o = typeof t == "function" && "__vccOpts" in t ? t.__vccOpts : t;
    return new F7(o, n, e);
  };
}
const N2 = "zhHans", F1 = 200, H7 = 20, H1 = 1e5, V1 = 16, Kl = 10, ql = 10, Gl = 2, V7 = "#262626", j7 = [
  "#000000",
  "#262626",
  "#595959",
  "#8C8C8C",
  "#BFBFBF",
  "#D9D9D9",
  "#E9E9E9",
  "#F5F5F5",
  "#FAFAFA",
  "#FFFFFF",
  "#F5222D",
  "#FA541C",
  "#FA8C16",
  "#FADB14",
  "#52C41A",
  "#13C2C2",
  "#1890FF",
  "#2F54EB",
  "#722ED1",
  "#EB2F96",
  "#FFE8E6",
  "#FFECE0",
  "#FFEFD1",
  "#FCFCCA",
  "#E4F7D2",
  "#D3F5F0",
  "#D4EEFC",
  "#DEE8FC",
  "#EFE1FA",
  "#FAE1EB",
  "#FFA39E",
  "#FFBB96",
  "#FFD591",
  "#FFFB8F",
  "#B7EB8F",
  "#87E8DE",
  "#91D5FF",
  "#ADC6FF",
  "#D3ADF7",
  "#FFADD2",
  "#FF4D4F",
  "#FF7A45",
  "#FFA940",
  "#FFEC3D",
  "#73D13D",
  "#36CFC9",
  "#40A9FF",
  "#597EF7",
  "#9254DE",
  "#F759AB",
  "#CF1322",
  "#D4380D",
  "#D46B08",
  "#D4B106",
  "#389E0D",
  "#08979C",
  "#096DD9",
  "#1D39C4",
  "#531DAB",
  "#C41D7F",
  "#820014",
  "#871400",
  "#873800",
  "#614700",
  "#135200",
  "#00474F",
  "#003A8C",
  "#061178",
  "#22075E",
  "#780650"
], U7 = [
  "10px",
  "11px",
  "12px",
  "14px",
  "16px",
  "18px",
  "20px",
  "22px",
  "24px",
  "26px",
  "28px",
  "36px",
  "48px",
  "72px"
], zi = "defaut";
var od = /* @__PURE__ */ ((t) => (t[t["size-small"] = 480] = "size-small", t[t["size-medium"] = 640] = "size-medium", t["size-large"] = "100%", t))(od || {});
const B2 = "1", W7 = {
  text: [
    "AI",
    "divider",
    "text-bubble",
    "divider",
    "bold",
    "italic",
    "underline",
    "strike",
    "code",
    "link",
    "divider",
    "color",
    "highlight",
    "textAlign"
  ],
  video: ["video-size-small", "video-size-medium", "video-size-large", "divider", "remove"]
}, K7 = [
  "Arial",
  "Arial Black",
  "Georgia",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Verdana",
  "Courier New",
  "Lucida Console",
  "Monaco",
  "monospace"
], q7 = K7.reduce(
  (t, e) => (t[e] = e, t),
  {}
);
var $2 = typeof global == "object" && global && global.Object === Object && global, G7 = typeof self == "object" && self && self.Object === Object && self, fo = $2 || G7 || Function("return this")(), so = fo.Symbol, z2 = Object.prototype, J7 = z2.hasOwnProperty, Y7 = z2.toString, Gs = so ? so.toStringTag : void 0;
function X7(t) {
  var e = J7.call(t, Gs), n = t[Gs];
  try {
    t[Gs] = void 0;
    var o = !0;
  } catch {
  }
  var r = Y7.call(t);
  return o && (e ? t[Gs] = n : delete t[Gs]), r;
}
var Z7 = Object.prototype, Q7 = Z7.toString;
function eE(t) {
  return Q7.call(t);
}
var tE = "[object Null]", nE = "[object Undefined]", j1 = so ? so.toStringTag : void 0;
function ki(t) {
  return t == null ? t === void 0 ? nE : tE : j1 && j1 in Object(t) ? X7(t) : eE(t);
}
function _r(t) {
  return t != null && typeof t == "object";
}
var oE = "[object Symbol]";
function gu(t) {
  return typeof t == "symbol" || _r(t) && ki(t) == oE;
}
function F2(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length, r = Array(o); ++n < o; )
    r[n] = e(t[n], n, t);
  return r;
}
var ao = Array.isArray, rE = 1 / 0, U1 = so ? so.prototype : void 0, W1 = U1 ? U1.toString : void 0;
function rd(t) {
  if (typeof t == "string")
    return t;
  if (ao(t))
    return F2(t, rd) + "";
  if (gu(t))
    return W1 ? W1.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -rE ? "-0" : e;
}
var iE = /\s/;
function sE(t) {
  for (var e = t.length; e-- && iE.test(t.charAt(e)); )
    ;
  return e;
}
var aE = /^\s+/;
function lE(t) {
  return t && t.slice(0, sE(t) + 1).replace(aE, "");
}
function Mr(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var K1 = NaN, cE = /^[-+]0x[0-9a-f]+$/i, dE = /^0b[01]+$/i, uE = /^0o[0-7]+$/i, fE = parseInt;
function Yp(t) {
  if (typeof t == "number")
    return t;
  if (gu(t))
    return K1;
  if (Mr(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Mr(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = lE(t);
  var n = dE.test(t);
  return n || uE.test(t) ? fE(t.slice(2), n ? 2 : 8) : cE.test(t) ? K1 : +t;
}
var q1 = 1 / 0, pE = 17976931348623157e292;
function hE(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = Yp(t), t === q1 || t === -q1) {
    var e = t < 0 ? -1 : 1;
    return e * pE;
  }
  return t === t ? t : 0;
}
function mE(t) {
  var e = hE(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
function Hm(t) {
  return t;
}
var gE = "[object AsyncFunction]", vE = "[object Function]", yE = "[object GeneratorFunction]", bE = "[object Proxy]";
function H2(t) {
  if (!Mr(t))
    return !1;
  var e = ki(t);
  return e == vE || e == yE || e == gE || e == bE;
}
var Mf = fo["__core-js_shared__"], G1 = function() {
  var t = /[^.]+$/.exec(Mf && Mf.keys && Mf.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function wE(t) {
  return !!G1 && G1 in t;
}
var xE = Function.prototype, kE = xE.toString;
function Ci(t) {
  if (t != null) {
    try {
      return kE.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var CE = /[\\^$.*+?()[\]{}|]/g, SE = /^\[object .+?Constructor\]$/, AE = Function.prototype, EE = Object.prototype, _E = AE.toString, ME = EE.hasOwnProperty, TE = RegExp(
  "^" + _E.call(ME).replace(CE, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function OE(t) {
  if (!Mr(t) || wE(t))
    return !1;
  var e = H2(t) ? TE : SE;
  return e.test(Ci(t));
}
function IE(t, e) {
  return t == null ? void 0 : t[e];
}
function Si(t, e) {
  var n = IE(t, e);
  return OE(n) ? n : void 0;
}
var Xp = Si(fo, "WeakMap");
function DE(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
var RE = 800, PE = 16, LE = Date.now;
function NE(t) {
  var e = 0, n = 0;
  return function() {
    var o = LE(), r = PE - (o - n);
    if (n = o, r > 0) {
      if (++e >= RE)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function BE(t) {
  return function() {
    return t;
  };
}
var J1 = function() {
  try {
    var t = Si(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}(), $E = J1 ? function(t, e) {
  return J1(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: BE(e),
    writable: !0
  });
} : Hm, zE = NE($E);
function FE(t, e, n, o) {
  for (var r = t.length, i = n + -1; ++i < r; )
    if (e(t[i], i, t))
      return i;
  return -1;
}
function HE(t) {
  return t !== t;
}
function VE(t, e, n) {
  for (var o = n - 1, r = t.length; ++o < r; )
    if (t[o] === e)
      return o;
  return -1;
}
function jE(t, e, n) {
  return e === e ? VE(t, e, n) : FE(t, HE, n);
}
function UE(t, e) {
  var n = t == null ? 0 : t.length;
  return !!n && jE(t, e, 0) > -1;
}
var WE = 9007199254740991, KE = /^(?:0|[1-9]\d*)$/;
function V2(t, e) {
  var n = typeof t;
  return e = e ?? WE, !!e && (n == "number" || n != "symbol" && KE.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function j2(t, e) {
  return t === e || t !== t && e !== e;
}
var Y1 = Math.max;
function qE(t, e, n) {
  return e = Y1(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var o = arguments, r = -1, i = Y1(o.length - e, 0), s = Array(i); ++r < i; )
      s[r] = o[e + r];
    r = -1;
    for (var a = Array(e + 1); ++r < e; )
      a[r] = o[r];
    return a[e] = n(s), DE(t, this, a);
  };
}
function GE(t, e) {
  return zE(qE(t, e, Hm), t + "");
}
var JE = 9007199254740991;
function Vm(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= JE;
}
function U2(t) {
  return t != null && Vm(t.length) && !H2(t);
}
var YE = Object.prototype;
function XE(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || YE;
  return t === n;
}
function ZE(t, e) {
  for (var n = -1, o = Array(t); ++n < t; )
    o[n] = e(n);
  return o;
}
var QE = "[object Arguments]";
function X1(t) {
  return _r(t) && ki(t) == QE;
}
var W2 = Object.prototype, e_ = W2.hasOwnProperty, t_ = W2.propertyIsEnumerable, jm = X1(/* @__PURE__ */ function() {
  return arguments;
}()) ? X1 : function(t) {
  return _r(t) && e_.call(t, "callee") && !t_.call(t, "callee");
};
function n_() {
  return !1;
}
var K2 = typeof exports == "object" && exports && !exports.nodeType && exports, Z1 = K2 && typeof module == "object" && module && !module.nodeType && module, o_ = Z1 && Z1.exports === K2, Q1 = o_ ? fo.Buffer : void 0, r_ = Q1 ? Q1.isBuffer : void 0, Zp = r_ || n_, i_ = "[object Arguments]", s_ = "[object Array]", a_ = "[object Boolean]", l_ = "[object Date]", c_ = "[object Error]", d_ = "[object Function]", u_ = "[object Map]", f_ = "[object Number]", p_ = "[object Object]", h_ = "[object RegExp]", m_ = "[object Set]", g_ = "[object String]", v_ = "[object WeakMap]", y_ = "[object ArrayBuffer]", b_ = "[object DataView]", w_ = "[object Float32Array]", x_ = "[object Float64Array]", k_ = "[object Int8Array]", C_ = "[object Int16Array]", S_ = "[object Int32Array]", A_ = "[object Uint8Array]", E_ = "[object Uint8ClampedArray]", __ = "[object Uint16Array]", M_ = "[object Uint32Array]", it = {};
it[w_] = it[x_] = it[k_] = it[C_] = it[S_] = it[A_] = it[E_] = it[__] = it[M_] = !0;
it[i_] = it[s_] = it[y_] = it[a_] = it[b_] = it[l_] = it[c_] = it[d_] = it[u_] = it[f_] = it[p_] = it[h_] = it[m_] = it[g_] = it[v_] = !1;
function T_(t) {
  return _r(t) && Vm(t.length) && !!it[ki(t)];
}
function Um(t) {
  return function(e) {
    return t(e);
  };
}
var q2 = typeof exports == "object" && exports && !exports.nodeType && exports, ma = q2 && typeof module == "object" && module && !module.nodeType && module, O_ = ma && ma.exports === q2, Tf = O_ && $2.process, id = function() {
  try {
    var t = ma && ma.require && ma.require("util").types;
    return t || Tf && Tf.binding && Tf.binding("util");
  } catch {
  }
}(), ev = id && id.isTypedArray, G2 = ev ? Um(ev) : T_, I_ = Object.prototype, D_ = I_.hasOwnProperty;
function R_(t, e) {
  var n = ao(t), o = !n && jm(t), r = !n && !o && Zp(t), i = !n && !o && !r && G2(t), s = n || o || r || i, a = s ? ZE(t.length, String) : [], l = a.length;
  for (var c in t)
    D_.call(t, c) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    i && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    V2(c, l))) && a.push(c);
  return a;
}
function P_(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var L_ = P_(Object.keys, Object), N_ = Object.prototype, B_ = N_.hasOwnProperty;
function $_(t) {
  if (!XE(t))
    return L_(t);
  var e = [];
  for (var n in Object(t))
    B_.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
function J2(t) {
  return U2(t) ? R_(t) : $_(t);
}
var z_ = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, F_ = /^\w*$/;
function Wm(t, e) {
  if (ao(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || gu(t) ? !0 : F_.test(t) || !z_.test(t) || e != null && t in Object(e);
}
var Va = Si(Object, "create");
function H_() {
  this.__data__ = Va ? Va(null) : {}, this.size = 0;
}
function V_(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var j_ = "__lodash_hash_undefined__", U_ = Object.prototype, W_ = U_.hasOwnProperty;
function K_(t) {
  var e = this.__data__;
  if (Va) {
    var n = e[t];
    return n === j_ ? void 0 : n;
  }
  return W_.call(e, t) ? e[t] : void 0;
}
var q_ = Object.prototype, G_ = q_.hasOwnProperty;
function J_(t) {
  var e = this.__data__;
  return Va ? e[t] !== void 0 : G_.call(e, t);
}
var Y_ = "__lodash_hash_undefined__";
function X_(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = Va && e === void 0 ? Y_ : e, this;
}
function vi(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var o = t[e];
    this.set(o[0], o[1]);
  }
}
vi.prototype.clear = H_;
vi.prototype.delete = V_;
vi.prototype.get = K_;
vi.prototype.has = J_;
vi.prototype.set = X_;
function Z_() {
  this.__data__ = [], this.size = 0;
}
function vu(t, e) {
  for (var n = t.length; n--; )
    if (j2(t[n][0], e))
      return n;
  return -1;
}
var Q_ = Array.prototype, eM = Q_.splice;
function tM(t) {
  var e = this.__data__, n = vu(e, t);
  if (n < 0)
    return !1;
  var o = e.length - 1;
  return n == o ? e.pop() : eM.call(e, n, 1), --this.size, !0;
}
function nM(t) {
  var e = this.__data__, n = vu(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function oM(t) {
  return vu(this.__data__, t) > -1;
}
function rM(t, e) {
  var n = this.__data__, o = vu(n, t);
  return o < 0 ? (++this.size, n.push([t, e])) : n[o][1] = e, this;
}
function Uo(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var o = t[e];
    this.set(o[0], o[1]);
  }
}
Uo.prototype.clear = Z_;
Uo.prototype.delete = tM;
Uo.prototype.get = nM;
Uo.prototype.has = oM;
Uo.prototype.set = rM;
var ja = Si(fo, "Map");
function iM() {
  this.size = 0, this.__data__ = {
    hash: new vi(),
    map: new (ja || Uo)(),
    string: new vi()
  };
}
function sM(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function yu(t, e) {
  var n = t.__data__;
  return sM(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function aM(t) {
  var e = yu(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function lM(t) {
  return yu(this, t).get(t);
}
function cM(t) {
  return yu(this, t).has(t);
}
function dM(t, e) {
  var n = yu(this, t), o = n.size;
  return n.set(t, e), this.size += n.size == o ? 0 : 1, this;
}
function Wo(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var o = t[e];
    this.set(o[0], o[1]);
  }
}
Wo.prototype.clear = iM;
Wo.prototype.delete = aM;
Wo.prototype.get = lM;
Wo.prototype.has = cM;
Wo.prototype.set = dM;
var uM = "Expected a function";
function Km(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(uM);
  var n = function() {
    var o = arguments, r = e ? e.apply(this, o) : o[0], i = n.cache;
    if (i.has(r))
      return i.get(r);
    var s = t.apply(this, o);
    return n.cache = i.set(r, s) || i, s;
  };
  return n.cache = new (Km.Cache || Wo)(), n;
}
Km.Cache = Wo;
var fM = 500;
function pM(t) {
  var e = Km(t, function(o) {
    return n.size === fM && n.clear(), o;
  }), n = e.cache;
  return e;
}
var hM = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, mM = /\\(\\)?/g, gM = pM(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(hM, function(n, o, r, i) {
    e.push(r ? i.replace(mM, "$1") : o || n);
  }), e;
});
function Qp(t) {
  return t == null ? "" : rd(t);
}
function Y2(t, e) {
  return ao(t) ? t : Wm(t, e) ? [t] : gM(Qp(t));
}
var vM = 1 / 0;
function bu(t) {
  if (typeof t == "string" || gu(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -vM ? "-0" : e;
}
function X2(t, e) {
  e = Y2(e, t);
  for (var n = 0, o = e.length; t != null && n < o; )
    t = t[bu(e[n++])];
  return n && n == o ? t : void 0;
}
function yM(t, e, n) {
  var o = t == null ? void 0 : X2(t, e);
  return o === void 0 ? n : o;
}
function Z2(t, e) {
  for (var n = -1, o = e.length, r = t.length; ++n < o; )
    t[r + n] = e[n];
  return t;
}
var tv = so ? so.isConcatSpreadable : void 0;
function bM(t) {
  return ao(t) || jm(t) || !!(tv && t && t[tv]);
}
function wM(t, e, n, o, r) {
  var i = -1, s = t.length;
  for (n || (n = bM), r || (r = []); ++i < s; ) {
    var a = t[i];
    n(a) && Z2(r, a);
  }
  return r;
}
function xM(t, e, n) {
  var o = -1, r = t.length;
  e < 0 && (e = -e > r ? 0 : r + e), n = n > r ? r : n, n < 0 && (n += r), r = e > n ? 0 : n - e >>> 0, e >>>= 0;
  for (var i = Array(r); ++o < r; )
    i[o] = t[o + e];
  return i;
}
function kM(t, e, n) {
  var o = t.length;
  return n = n === void 0 ? o : n, !e && n >= o ? t : xM(t, e, n);
}
var CM = "\\ud800-\\udfff", SM = "\\u0300-\\u036f", AM = "\\ufe20-\\ufe2f", EM = "\\u20d0-\\u20ff", _M = SM + AM + EM, MM = "\\ufe0e\\ufe0f", TM = "\\u200d", OM = RegExp("[" + TM + CM + _M + MM + "]");
function qm(t) {
  return OM.test(t);
}
function IM(t) {
  return t.split("");
}
var Q2 = "\\ud800-\\udfff", DM = "\\u0300-\\u036f", RM = "\\ufe20-\\ufe2f", PM = "\\u20d0-\\u20ff", LM = DM + RM + PM, NM = "\\ufe0e\\ufe0f", BM = "[" + Q2 + "]", eh = "[" + LM + "]", th = "\\ud83c[\\udffb-\\udfff]", $M = "(?:" + eh + "|" + th + ")", ex = "[^" + Q2 + "]", tx = "(?:\\ud83c[\\udde6-\\uddff]){2}", nx = "[\\ud800-\\udbff][\\udc00-\\udfff]", zM = "\\u200d", ox = $M + "?", rx = "[" + NM + "]?", FM = "(?:" + zM + "(?:" + [ex, tx, nx].join("|") + ")" + rx + ox + ")*", HM = rx + ox + FM, VM = "(?:" + [ex + eh + "?", eh, tx, nx, BM].join("|") + ")", jM = RegExp(th + "(?=" + th + ")|" + VM + HM, "g");
function UM(t) {
  return t.match(jM) || [];
}
function WM(t) {
  return qm(t) ? UM(t) : IM(t);
}
function KM() {
  this.__data__ = new Uo(), this.size = 0;
}
function qM(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
function GM(t) {
  return this.__data__.get(t);
}
function JM(t) {
  return this.__data__.has(t);
}
var YM = 200;
function XM(t, e) {
  var n = this.__data__;
  if (n instanceof Uo) {
    var o = n.__data__;
    if (!ja || o.length < YM - 1)
      return o.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new Wo(o);
  }
  return n.set(t, e), this.size = n.size, this;
}
function Lo(t) {
  var e = this.__data__ = new Uo(t);
  this.size = e.size;
}
Lo.prototype.clear = KM;
Lo.prototype.delete = qM;
Lo.prototype.get = GM;
Lo.prototype.has = JM;
Lo.prototype.set = XM;
function ZM(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length, r = 0, i = []; ++n < o; ) {
    var s = t[n];
    e(s, n, t) && (i[r++] = s);
  }
  return i;
}
function QM() {
  return [];
}
var eT = Object.prototype, tT = eT.propertyIsEnumerable, nv = Object.getOwnPropertySymbols, nT = nv ? function(t) {
  return t == null ? [] : (t = Object(t), ZM(nv(t), function(e) {
    return tT.call(t, e);
  }));
} : QM;
function oT(t, e, n) {
  var o = e(t);
  return ao(t) ? o : Z2(o, n(t));
}
function ov(t) {
  return oT(t, J2, nT);
}
var nh = Si(fo, "DataView"), oh = Si(fo, "Promise"), rh = Si(fo, "Set"), rv = "[object Map]", rT = "[object Object]", iv = "[object Promise]", sv = "[object Set]", av = "[object WeakMap]", lv = "[object DataView]", iT = Ci(nh), sT = Ci(ja), aT = Ci(oh), lT = Ci(rh), cT = Ci(Xp), ar = ki;
(nh && ar(new nh(new ArrayBuffer(1))) != lv || ja && ar(new ja()) != rv || oh && ar(oh.resolve()) != iv || rh && ar(new rh()) != sv || Xp && ar(new Xp()) != av) && (ar = function(t) {
  var e = ki(t), n = e == rT ? t.constructor : void 0, o = n ? Ci(n) : "";
  if (o)
    switch (o) {
      case iT:
        return lv;
      case sT:
        return rv;
      case aT:
        return iv;
      case lT:
        return sv;
      case cT:
        return av;
    }
  return e;
});
var cv = fo.Uint8Array, dT = "__lodash_hash_undefined__";
function uT(t) {
  return this.__data__.set(t, dT), this;
}
function fT(t) {
  return this.__data__.has(t);
}
function Ua(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new Wo(); ++e < n; )
    this.add(t[e]);
}
Ua.prototype.add = Ua.prototype.push = uT;
Ua.prototype.has = fT;
function pT(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length; ++n < o; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
function ix(t, e) {
  return t.has(e);
}
var hT = 1, mT = 2;
function sx(t, e, n, o, r, i) {
  var s = n & hT, a = t.length, l = e.length;
  if (a != l && !(s && l > a))
    return !1;
  var c = i.get(t), d = i.get(e);
  if (c && d)
    return c == e && d == t;
  var u = -1, f = !0, h = n & mT ? new Ua() : void 0;
  for (i.set(t, e), i.set(e, t); ++u < a; ) {
    var m = t[u], g = e[u];
    if (o)
      var v = s ? o(g, m, u, e, t, i) : o(m, g, u, t, e, i);
    if (v !== void 0) {
      if (v)
        continue;
      f = !1;
      break;
    }
    if (h) {
      if (!pT(e, function(y, x) {
        if (!ix(h, x) && (m === y || r(m, y, n, o, i)))
          return h.push(x);
      })) {
        f = !1;
        break;
      }
    } else if (!(m === g || r(m, g, n, o, i))) {
      f = !1;
      break;
    }
  }
  return i.delete(t), i.delete(e), f;
}
function gT(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(o, r) {
    n[++e] = [r, o];
  }), n;
}
function vT(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(o) {
    n[++e] = o;
  }), n;
}
var yT = 1, bT = 2, wT = "[object Boolean]", xT = "[object Date]", kT = "[object Error]", CT = "[object Map]", ST = "[object Number]", AT = "[object RegExp]", ET = "[object Set]", _T = "[object String]", MT = "[object Symbol]", TT = "[object ArrayBuffer]", OT = "[object DataView]", dv = so ? so.prototype : void 0, Of = dv ? dv.valueOf : void 0;
function IT(t, e, n, o, r, i, s) {
  switch (n) {
    case OT:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case TT:
      return !(t.byteLength != e.byteLength || !i(new cv(t), new cv(e)));
    case wT:
    case xT:
    case ST:
      return j2(+t, +e);
    case kT:
      return t.name == e.name && t.message == e.message;
    case AT:
    case _T:
      return t == e + "";
    case CT:
      var a = gT;
    case ET:
      var l = o & yT;
      if (a || (a = vT), t.size != e.size && !l)
        return !1;
      var c = s.get(t);
      if (c)
        return c == e;
      o |= bT, s.set(t, e);
      var d = sx(a(t), a(e), o, r, i, s);
      return s.delete(t), d;
    case MT:
      if (Of)
        return Of.call(t) == Of.call(e);
  }
  return !1;
}
var DT = 1, RT = Object.prototype, PT = RT.hasOwnProperty;
function LT(t, e, n, o, r, i) {
  var s = n & DT, a = ov(t), l = a.length, c = ov(e), d = c.length;
  if (l != d && !s)
    return !1;
  for (var u = l; u--; ) {
    var f = a[u];
    if (!(s ? f in e : PT.call(e, f)))
      return !1;
  }
  var h = i.get(t), m = i.get(e);
  if (h && m)
    return h == e && m == t;
  var g = !0;
  i.set(t, e), i.set(e, t);
  for (var v = s; ++u < l; ) {
    f = a[u];
    var y = t[f], x = e[f];
    if (o)
      var C = s ? o(x, y, f, e, t, i) : o(y, x, f, t, e, i);
    if (!(C === void 0 ? y === x || r(y, x, n, o, i) : C)) {
      g = !1;
      break;
    }
    v || (v = f == "constructor");
  }
  if (g && !v) {
    var b = t.constructor, S = e.constructor;
    b != S && "constructor" in t && "constructor" in e && !(typeof b == "function" && b instanceof b && typeof S == "function" && S instanceof S) && (g = !1);
  }
  return i.delete(t), i.delete(e), g;
}
var NT = 1, uv = "[object Arguments]", fv = "[object Array]", Jl = "[object Object]", BT = Object.prototype, pv = BT.hasOwnProperty;
function $T(t, e, n, o, r, i) {
  var s = ao(t), a = ao(e), l = s ? fv : ar(t), c = a ? fv : ar(e);
  l = l == uv ? Jl : l, c = c == uv ? Jl : c;
  var d = l == Jl, u = c == Jl, f = l == c;
  if (f && Zp(t)) {
    if (!Zp(e))
      return !1;
    s = !0, d = !1;
  }
  if (f && !d)
    return i || (i = new Lo()), s || G2(t) ? sx(t, e, n, o, r, i) : IT(t, e, l, n, o, r, i);
  if (!(n & NT)) {
    var h = d && pv.call(t, "__wrapped__"), m = u && pv.call(e, "__wrapped__");
    if (h || m) {
      var g = h ? t.value() : t, v = m ? e.value() : e;
      return i || (i = new Lo()), r(g, v, n, o, i);
    }
  }
  return f ? (i || (i = new Lo()), LT(t, e, n, o, r, i)) : !1;
}
function wu(t, e, n, o, r) {
  return t === e ? !0 : t == null || e == null || !_r(t) && !_r(e) ? t !== t && e !== e : $T(t, e, n, o, wu, r);
}
var zT = 1, FT = 2;
function HT(t, e, n, o) {
  var r = n.length, i = r;
  if (t == null)
    return !i;
  for (t = Object(t); r--; ) {
    var s = n[r];
    if (s[2] ? s[1] !== t[s[0]] : !(s[0] in t))
      return !1;
  }
  for (; ++r < i; ) {
    s = n[r];
    var a = s[0], l = t[a], c = s[1];
    if (s[2]) {
      if (l === void 0 && !(a in t))
        return !1;
    } else {
      var d = new Lo(), u;
      if (!(u === void 0 ? wu(c, l, zT | FT, o, d) : u))
        return !1;
    }
  }
  return !0;
}
function ax(t) {
  return t === t && !Mr(t);
}
function VT(t) {
  for (var e = J2(t), n = e.length; n--; ) {
    var o = e[n], r = t[o];
    e[n] = [o, r, ax(r)];
  }
  return e;
}
function lx(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
function jT(t) {
  var e = VT(t);
  return e.length == 1 && e[0][2] ? lx(e[0][0], e[0][1]) : function(n) {
    return n === t || HT(n, t, e);
  };
}
function UT(t, e) {
  return t != null && e in Object(t);
}
function WT(t, e, n) {
  e = Y2(e, t);
  for (var o = -1, r = e.length, i = !1; ++o < r; ) {
    var s = bu(e[o]);
    if (!(i = t != null && n(t, s)))
      break;
    t = t[s];
  }
  return i || ++o != r ? i : (r = t == null ? 0 : t.length, !!r && Vm(r) && V2(s, r) && (ao(t) || jm(t)));
}
function KT(t, e) {
  return t != null && WT(t, e, UT);
}
var qT = 1, GT = 2;
function JT(t, e) {
  return Wm(t) && ax(e) ? lx(bu(t), e) : function(n) {
    var o = yM(n, t);
    return o === void 0 && o === e ? KT(n, t) : wu(e, o, qT | GT);
  };
}
function cx(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
function YT(t) {
  return function(e) {
    return X2(e, t);
  };
}
function XT(t) {
  return Wm(t) ? cx(bu(t)) : YT(t);
}
function ZT(t) {
  return typeof t == "function" ? t : t == null ? Hm : typeof t == "object" ? ao(t) ? JT(t[0], t[1]) : jT(t) : XT(t);
}
var If = function() {
  return fo.Date.now();
}, QT = "Expected a function", e9 = Math.max, t9 = Math.min;
function n9(t, e, n) {
  var o, r, i, s, a, l, c = 0, d = !1, u = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(QT);
  e = Yp(e) || 0, Mr(n) && (d = !!n.leading, u = "maxWait" in n, i = u ? e9(Yp(n.maxWait) || 0, e) : i, f = "trailing" in n ? !!n.trailing : f);
  function h(A) {
    var I = o, z = r;
    return o = r = void 0, c = A, s = t.apply(z, I), s;
  }
  function m(A) {
    return c = A, a = setTimeout(y, e), d ? h(A) : s;
  }
  function g(A) {
    var I = A - l, z = A - c, N = e - I;
    return u ? t9(N, i - z) : N;
  }
  function v(A) {
    var I = A - l, z = A - c;
    return l === void 0 || I >= e || I < 0 || u && z >= i;
  }
  function y() {
    var A = If();
    if (v(A))
      return x(A);
    a = setTimeout(y, g(A));
  }
  function x(A) {
    return a = void 0, f && o ? h(A) : (o = r = void 0, s);
  }
  function C() {
    a !== void 0 && clearTimeout(a), c = 0, o = l = r = a = void 0;
  }
  function b() {
    return a === void 0 ? s : x(If());
  }
  function S() {
    var A = If(), I = v(A);
    if (o = arguments, r = this, l = A, I) {
      if (a === void 0)
        return m(l);
      if (u)
        return clearTimeout(a), a = setTimeout(y, e), h(l);
    }
    return a === void 0 && (a = setTimeout(y, e)), s;
  }
  return S.cancel = C, S.flush = b, S;
}
function Df(t) {
  return _r(t) && U2(t);
}
var o9 = 200;
function r9(t, e, n, o) {
  var r = -1, i = UE, s = !0, a = t.length, l = [], c = e.length;
  if (!a)
    return l;
  n && (e = F2(e, Um(n))), e.length >= o9 && (i = ix, s = !1, e = new Ua(e));
  e:
    for (; ++r < a; ) {
      var d = t[r], u = n == null ? d : n(d);
      if (d = d !== 0 ? d : 0, s && u === u) {
        for (var f = c; f--; )
          if (e[f] === u)
            continue e;
        l.push(d);
      } else
        i(e, u, o) || l.push(d);
    }
  return l;
}
function i9(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
var s9 = GE(function(t, e) {
  var n = i9(e);
  return Df(n) && (n = void 0), Df(t) ? r9(t, wM(e, 1, Df), ZT(n)) : [];
});
function a9(t, e) {
  return wu(t, e);
}
var l9 = "[object RegExp]";
function c9(t) {
  return _r(t) && ki(t) == l9;
}
var hv = id && id.isRegExp, d9 = hv ? Um(hv) : c9, u9 = cx("length"), dx = "\\ud800-\\udfff", f9 = "\\u0300-\\u036f", p9 = "\\ufe20-\\ufe2f", h9 = "\\u20d0-\\u20ff", m9 = f9 + p9 + h9, g9 = "\\ufe0e\\ufe0f", v9 = "[" + dx + "]", ih = "[" + m9 + "]", sh = "\\ud83c[\\udffb-\\udfff]", y9 = "(?:" + ih + "|" + sh + ")", ux = "[^" + dx + "]", fx = "(?:\\ud83c[\\udde6-\\uddff]){2}", px = "[\\ud800-\\udbff][\\udc00-\\udfff]", b9 = "\\u200d", hx = y9 + "?", mx = "[" + g9 + "]?", w9 = "(?:" + b9 + "(?:" + [ux, fx, px].join("|") + ")" + mx + hx + ")*", x9 = mx + hx + w9, k9 = "(?:" + [ux + ih + "?", ih, fx, px, v9].join("|") + ")", mv = RegExp(sh + "(?=" + sh + ")|" + k9 + x9, "g");
function C9(t) {
  for (var e = mv.lastIndex = 0; mv.test(t); )
    ++e;
  return e;
}
function S9(t) {
  return qm(t) ? C9(t) : u9(t);
}
var A9 = "Expected a function";
function sd(t, e, n) {
  var o = !0, r = !0;
  if (typeof t != "function")
    throw new TypeError(A9);
  return Mr(n) && (o = "leading" in n ? !!n.leading : o, r = "trailing" in n ? !!n.trailing : r), n9(t, e, {
    leading: o,
    maxWait: e,
    trailing: r
  });
}
var E9 = 30, _9 = "...", M9 = /\w*$/;
function T9(t, e) {
  var n = E9, o = _9;
  if (Mr(e)) {
    var r = "separator" in e ? e.separator : r;
    n = "length" in e ? mE(e.length) : n, o = "omission" in e ? rd(e.omission) : o;
  }
  t = Qp(t);
  var i = t.length;
  if (qm(t)) {
    var s = WM(t);
    i = s.length;
  }
  if (n >= i)
    return t;
  var a = n - S9(o);
  if (a < 1)
    return o;
  var l = s ? kM(s, 0, a).join("") : t.slice(0, a);
  if (r === void 0)
    return l + o;
  if (s && (a += l.length - a), d9(r)) {
    if (t.slice(a).search(r)) {
      var c, d = l;
      for (r.global || (r = RegExp(r.source, Qp(M9.exec(r)) + "g")), r.lastIndex = 0; c = r.exec(d); )
        var u = c.index;
      l = l.slice(0, u === void 0 ? a : u);
    }
  } else if (t.indexOf(rd(r), a) != a) {
    var f = l.lastIndexOf(r);
    f > -1 && (l = l.slice(0, f));
  }
  return l + o;
}
const Tc = (t, e = "px") => {
  if (!t)
    return t;
  const n = ah(t) ? String(t) : t, o = parseFloat(n), r = n.match(/[a-zA-Z%]+$/), i = r ? r[0] : e;
  return isNaN(o) ? t : o + i;
};
function O9(t, e, n) {
  return t < e ? e : t > n ? n : t;
}
const ah = (t) => typeof t == "number", I9 = (t) => typeof t == "function";
function xu(t, e) {
  const { extensions: n = [] } = t.extensionManager ?? {};
  return !!n.find((r) => r.name === e);
}
const D9 = {
  "editor.remove": "删除",
  "editor.copy": "复制",
  "editor.words": "单词",
  "editor.characters": "字符",
  "editor.default": "默认",
  "editor.recent": "最近使用",
  "editor.moremark": "更多文本样式",
  "editor.nofill": "无填充色",
  "editor.format": "格式刷",
  "editor.close": "关闭",
  "editor.modify": "修改",
  "editor.preview.tooltip": "预览",
  "editor.draghandle.tooltip": "可拖拽和点击",
  "editor.copyToClipboard": "复制到剪切板",
  "editor.importWord.tooltip": "导入Word",
  "editor.importWord.success": "导入成功",
  "editor.importWord.fileTooLarge": "文件大小超出限制",
  "editor.importWord.error": "导入失败,文件不支持",
  "editor.slash": "输入 '/' 唤起更多",
  "editor.slash.empty": "暂无搜索结果",
  "editor.slash.format": "格式",
  "editor.slash.insert": "插入",
  "editor.slash.embed": "嵌入第三方服务",
  "editor.content": "请输入正文",
  "editor.size.small.tooltip": "小尺寸",
  "editor.size.medium.tooltip": "中等尺寸",
  "editor.size.large.tooltip": "铺满",
  "editor.bold.tooltip": "粗体",
  "editor.italic.tooltip": "斜体",
  "editor.underline.tooltip": "下划线",
  "editor.strike.tooltip": "删除线",
  "editor.color.tooltip": "文本颜色",
  "editor.color.more": "更多颜色",
  "editor.lineheight.tooltip": "行高",
  "editor.highlight.tooltip": "文本高亮",
  "editor.heading.tooltip": "正文与标题",
  "editor.heading.h1.tooltip": "标题 1",
  "editor.heading.h2.tooltip": "标题 2",
  "editor.heading.h3.tooltip": "标题 3",
  "editor.heading.h4.tooltip": "标题 4",
  "editor.heading.h5.tooltip": "标题 5",
  "editor.heading.h6.tooltip": "标题 6",
  "editor.paragraph.tooltip": "正文",
  "editor.textalign.tooltip": "对齐方式",
  "editor.textalign.left.tooltip": "左对齐",
  "editor.textalign.center.tooltip": "居中对齐",
  "editor.textalign.right.tooltip": "右对齐",
  "editor.textalign.justify.tooltip": "两端对齐",
  "editor.fontFamily.tooltip": "字体",
  "editor.fontFamily.default": "默认字体",
  "editor.fontSize.tooltip": "字号调整",
  "editor.fontSize.default.tooltip": "默认字号",
  "editor.superscript.tooltip": "上标",
  "editor.subscript.tooltip": "下标",
  "editor.bulletlist.tooltip": "无序列表",
  "editor.bulletlist.disc.tooltip": "默认",
  "editor.bulletlist.circle.tooltip": "空心圆",
  "editor.bulletlist.square.tooltip": "方形",
  "editor.orderedlist.tooltip": "有序列表",
  "editor.orderedlist.decimal.tooltip": "默认",
  "editor.orderedlist.decimalLeadingZero.tooltip": "补零数字",
  "editor.orderedlist.lowerRoman.tooltip": "小写罗马数字",
  "editor.orderedlist.upperRoman.tooltip": "大写罗马数字",
  "editor.orderedlist.lowerLatin.tooltip": "小写英文编号",
  "editor.orderedlist.upperLatin.tooltip": "大写英文编号",
  "editor.orderedlist.tradChineseInformal.tooltip": "中文编号",
  "editor.orderedlist.simpChineseFormal.tooltip": "大写中文编号",
  "editor.tasklist.tooltip": "任务列表",
  "editor.indent": "缩进调整",
  "editor.indent.tooltip": "增加缩进",
  "editor.outdent.tooltip": "减少缩进",
  "editor.columns.tooltip": "分栏",
  "editor.link.tooltip": "链接",
  "editor.link.unlink.tooltip": "取消链接",
  "editor.link.open.tooltip": "打开链接",
  "editor.link.edit.tooltip": "编辑链接",
  "editor.link.dialog.title": "插入链接",
  "editor.link.dialog.link": "链接",
  "editor.link.dialog.text": "文本",
  "editor.link.dialog.openInNewTab": "是否在新窗口打开",
  "editor.link.dialog.link.placeholder": "链接地址",
  "editor.link.dialog.text.placeholder": "添加描述",
  "editor.link.dialog.button.apply": "应用",
  "editor.image.tooltip": "图片",
  "editor.image.menu.flipX": "水平翻转",
  "editor.image.menu.flipY": "垂直翻转",
  "editor.image.menu.size": "宽高",
  "editor.image.menu.size.width": "宽度",
  "editor.image.menu.size.height": "高度",
  "editor.image.dragger.tooltip": "点击或者拖动图片到该区域来上传",
  "editor.image.float.left.tooltip": "左浮动",
  "editor.image.float.none.tooltip": "无浮动",
  "editor.image.float.right.tooltip": "右浮动",
  "editor.image.dialog.title": "插入图片",
  "editor.image.dialog.tab.url": "网络图片",
  "editor.image.dialog.tab.upload": "上传",
  "editor.image.dialog.uploading": "正在上传",
  "editor.image.dialog.form.link": "链接",
  "editor.image.dialog.placeholder": "请输入图片链接",
  "editor.image.dialog.form.alt": "说明",
  "editor.image.dialog.form.aspectRatio": "锁定原有长宽比",
  "editor.image.dialog.form.file": "文件",
  "editor.image.dialog.button.apply": "应用",
  "editor.video.tooltip": "视频",
  "editor.video.dialog.tab.upload": "上传",
  "editor.video.dialog.uploading": "正在上传",
  "editor.video.dialog.title": "插入视频",
  "editor.video.dialog.link": "网络链接",
  "editor.video.dialog.placeholder": "请输入链接地址",
  "editor.video.dialog.button.apply": "应用",
  "editor.table.tooltip": "表格",
  "editor.table.menu.insert_table": "插入表格",
  "editor.table.menu.insert_table.with_header_row": "带标题行",
  "editor.table.menu.insertColumnBefore": "向左插入一列",
  "editor.table.menu.insertColumnAfter": "向右插入一列",
  "editor.table.menu.deleteColumn": "删除列",
  "editor.table.menu.insertRowAbove": "向上插入一行",
  "editor.table.menu.insertRowBelow": "向下插入一行",
  "editor.table.menu.deleteRow": "删除行",
  "editor.table.menu.mergeCells": "合并单元格",
  "editor.table.menu.splitCells": "拆分单元格",
  "editor.table.menu.deleteTable": "删除表格",
  "editor.table.menu.setCellsBgColor": "单元格背景颜色",
  "editor.blockquote.tooltip": "引用",
  "editor.horizontalrule.tooltip": "分隔线",
  "editor.code.tooltip": "代码",
  "editor.codeblock.tooltip": "代码块",
  "editor.clear.tooltip": "清除格式",
  "editor.undo.tooltip": "撤销",
  "editor.redo.tooltip": "重做",
  "editor.fullscreen.tooltip.fullscreen": "全屏",
  "editor.fullscreen.tooltip.exit": "退出全屏",
  "editor.imageUpload.fileTypeNotSupported": "图片类型不支持",
  "editor.imageUpload.fileSizeTooBig": "图片大小不支持, 最大",
  "editor.AI.placeholder": "向智能助手提问 ...",
  "editor.AI.generating": "正在生成",
  "editor.AI.insert": "插入选区下方",
  "editor.AI.replace": "替换选中内容",
  "editor.AI.regenerate": "重新生成",
  "editor.AI.close": "关闭",
  "editor.AI.stop": "停止",
  "editor.AI.ask": "智能助手",
  "editor.AI.error": "AI 错误",
  "editor.AI.editorNotFound": "未找到编辑器",
  "editor.AI.noSelection": "请先选择一些文本",
  "editor.AI.unknownError": "发生未知错误",
  "editor.AI.noCachedPrompt": "未找到缓存的提示",
  "editor.AI.regenerateError": "重新生成失败",
  "editor.AI.shortcutError": "快捷操作执行失败",
  "editor.menubar.file": "文件",
  "editor.menubar.edit": "编辑",
  "editor.menubar.view": "视图",
  "editor.menubar.insert": "插入",
  "editor.menubar.format": "格式",
  "editor.menubar.menu.newDoc": "新的文档",
  "editor.menubar.menu.restoreLastDraft": "恢复上一次的草稿",
  "editor.menubar.menu.print": "打印",
  "editor.menubar.menu.cut": "剪切",
  "editor.menubar.menu.copy": "复制",
  "editor.menubar.menu.paste": "黏贴",
  "editor.menubar.menu.pasteAsText": "纯文本黏贴",
  "editor.menubar.menu.selectAll": "全选",
  "editor.menubar.menu.preview": "预览",
  "editor.menubar.menu.spellCheck": "拼写检查",
  "editor.findAndReplace.tooltip": "查找和替换",
  "editor.findAndReplace.find": "查找",
  "editor.findAndReplace.replace": "替换",
  "editor.findAndReplace.replaceAll": "全部替换",
  "editor.findAndReplace.caseSensitive": "区分大小写",
  "editor.printer.tooltip": "打印",
  "editor.AI.shortcuts.generate.title": "从选中内容生成",
  "editor.AI.shortcuts.generate.improve": "改进写作",
  "editor.AI.shortcuts.generate.shorter": "精简内容",
  "editor.AI.shortcuts.generate.longer": "扩展内容",
  "editor.AI.shortcuts.generate.summarize": "总结内容",
  "editor.AI.shortcuts.generate.continue": "继续写作",
  "editor.AI.shortcuts.tone.title": "改变语气",
  "editor.AI.shortcuts.tone.professional": "专业的",
  "editor.AI.shortcuts.tone.casual": "随意的",
  "editor.AI.shortcuts.tone.direct": "直接的",
  "editor.AI.shortcuts.tone.confident": "自信的",
  "editor.AI.shortcuts.tone.friendly": "友好的",
  "editor.AI.shortcuts.translate.title": "翻译",
  "editor.AI.shortcuts.translate.english": "英语",
  "editor.AI.shortcuts.translate.chinese": "简体中文",
  "editor.AI.shortcuts.translate.spanish": "西班牙语",
  "editor.AI.shortcuts.translate.german": "德语",
  "editor.AI.shortcuts.translate.french": "法语",
  "editor.AI.shortcuts.translate.portuguese": "葡萄牙语",
  "editor.AI.shortcuts.translate.korean": "韩语",
  "editor.AI.shortcuts.translate.japanese": "日语",
  "editor.AI.shortcuts.translate.hindi": "印地语",
  "editor.AI.shortcuts.translate.russian": "俄语",
  "editor.AI.shortcuts.translate.arabic": "阿拉伯语",
  "editor.AI.shortcuts.style.title": "改变风格",
  "editor.AI.shortcuts.style.business": "商务",
  "editor.AI.shortcuts.style.legal": "法律",
  "editor.AI.shortcuts.style.journalism": "新闻",
  "editor.AI.shortcuts.style.medical": "医疗",
  "editor.AI.shortcuts.style.poetic": "诗意的"
}, R9 = D9, P9 = {
  "editor.remove": "Remove",
  "editor.copy": "Copy",
  "editor.words": "WORDS",
  "editor.characters": "CHARACTERS",
  "editor.default": "Default",
  "editor.recent": "Recently Used",
  "editor.nofill": "Remove Color",
  "editor.format": "Format Painter",
  "editor.close": "Close",
  "editor.modify": "Modify",
  "editor.preview.tooltip": "Preview",
  "editor.draghandle.tooltip": "Click And Drag",
  "editor.copyToClipboard": "CopyToClipboard",
  "editor.importWord.tooltip": "Import from Word",
  "editor.importWord.success": "Import Success",
  "editor.importWord.fileTooLarge": "File is Too large",
  "editor.importWord.error": "Import Failed, File not supported",
  "editor.slash": "Press '/' for commands",
  "editor.slash.empty": "No Result",
  "editor.slash.format": "Format",
  "editor.slash.insert": "Insert",
  "editor.slash.embed": "Embed Services",
  "editor.content": "Please input content",
  "editor.moremark": "More Text Styles",
  "editor.size.small.tooltip": "Small",
  "editor.size.medium.tooltip": "Medium",
  "editor.size.large.tooltip": "Cover",
  "editor.bold.tooltip": "Bold",
  "editor.italic.tooltip": "Italic",
  "editor.underline.tooltip": "Underline",
  "editor.strike.tooltip": "Strike",
  "editor.color.tooltip": "Color",
  "editor.color.more": "Color Picker",
  "editor.highlight.tooltip": "Highlight",
  "editor.lineheight.tooltip": "Line Height",
  "editor.heading.tooltip": "Headings",
  "editor.heading.h1.tooltip": "Heading 1",
  "editor.heading.h2.tooltip": "Heading 2",
  "editor.heading.h3.tooltip": "Heading 3",
  "editor.heading.h4.tooltip": "Heading 4",
  "editor.heading.h5.tooltip": "Heading 5",
  "editor.heading.h6.tooltip": "Heading 6",
  "editor.paragraph.tooltip": "Paragraph",
  "editor.textalign.tooltip": "Align",
  "editor.textalign.left.tooltip": "Left",
  "editor.textalign.center.tooltip": "Center",
  "editor.textalign.right.tooltip": "Right",
  "editor.textalign.justify.tooltip": "Justify",
  "editor.indent": "Indent",
  "editor.indent.indent": "Increase Indent",
  "editor.indent.outdent": "Decrease Indent",
  "editor.fontFamily.tooltip": "Font family",
  "editor.fontFamily.default": "Default",
  "editor.fontSize.tooltip": "Font size",
  "editor.fontSize.default.tooltip": "Default",
  "editor.superscript.tooltip": "Superscript",
  "editor.subscript.tooltip": "Subscript",
  "editor.bulletlist.tooltip": "Bullet List",
  "editor.bulletlist.disc.tooltip": "Disc",
  "editor.bulletlist.circle.tooltip": "Circle",
  "editor.bulletlist.square.tooltip": "Square",
  "editor.orderedlist.tooltip": "Ordered List",
  "editor.orderedlist.decimal.tooltip": "Decimal",
  "editor.orderedlist.decimalLeadingZero.tooltip": "Decimal with leading zero",
  "editor.orderedlist.lowerRoman.tooltip": "Lower Roman",
  "editor.orderedlist.upperRoman.tooltip": "Upper Roman",
  "editor.orderedlist.lowerLatin.tooltip": "Lower Latin",
  "editor.orderedlist.upperLatin.tooltip": "Upper Latin",
  "editor.orderedlist.tradChineseInformal.tooltip": "Trad Chinese Informal",
  "editor.orderedlist.simpChineseFormal.tooltip": "Simp Chinese Informal",
  "editor.tasklist.tooltip": "Task List",
  "editor.indent.tooltip": "Indent",
  "editor.outdent.tooltip": "Outdent",
  "editor.columns.tooltip": "Columns",
  "editor.link.tooltip": "Link",
  "editor.link.unlink.tooltip": "UnLink",
  "editor.link.open.tooltip": "Open Link",
  "editor.link.edit.tooltip": "Edit Link",
  "editor.link.dialog.title": "Insert Link",
  "editor.link.dialog.link": "Link",
  "editor.link.dialog.text": "Text",
  "editor.link.dialog.openInNewTab": "Open In New Tab",
  "editor.link.dialog.link.placeholder": "Link Address",
  "editor.link.dialog.text.placeholder": "Add Description",
  "editor.link.dialog.button.apply": "Apply",
  "editor.image.tooltip": "Image",
  "editor.image.menu.flipX": "Flip vertical",
  "editor.image.menu.flipY": "Flip horizontal",
  "editor.image.menu.size": "Set Size",
  "editor.image.menu.size.width": "Width",
  "editor.image.menu.size.height": "Height",
  "editor.image.dragger.tooltip": "Click or drag the image to the area to upload",
  "editor.image.float.left.tooltip": "Float left",
  "editor.image.float.none.tooltip": "Float none",
  "editor.image.float.right.tooltip": "Float right",
  "editor.image.dialog.title": "Add an image",
  "editor.image.dialog.tab.url": "Url",
  "editor.image.dialog.tab.upload": "Upload",
  "editor.image.dialog.uploading": "Uploading",
  "editor.image.dialog.form.link": "Link",
  "editor.image.dialog.placeholder": "Link",
  "editor.image.dialog.form.alt": "Alt",
  "editor.image.dialog.form.aspectRatio": "Lock original aspect ratio",
  "editor.image.dialog.form.file": "File",
  "editor.image.dialog.button.apply": "apply",
  "editor.video.tooltip": "Video",
  "editor.video.dialog.tab.upload": "Upload",
  "editor.video.dialog.uploading": "Uploading",
  "editor.video.dialog.title": "Embed or upload a video",
  "editor.video.dialog.link": "link",
  "editor.video.dialog.placeholder": "Link",
  "editor.video.dialog.button.apply": "apply",
  "editor.table.tooltip": "Table",
  "editor.table.menu.insert_table": "Insert Table",
  "editor.table.menu.insert_table.with_header_row": "With header row",
  "editor.table.menu.insertColumnBefore": "Insert Column Before",
  "editor.table.menu.insertColumnAfter": "Insert Column After",
  "editor.table.menu.deleteColumn": "Delete Column",
  "editor.table.menu.insertRowAbove": "Insert Row Above",
  "editor.table.menu.insertRowBelow": "Insert Row Below",
  "editor.table.menu.deleteRow": "Delete Row",
  "editor.table.menu.mergeCells": "Merge Cells",
  "editor.table.menu.splitCells": "Split Cells",
  "editor.table.menu.deleteTable": "Delete Table",
  "editor.table.menu.setCellsBgColor": "Cell Background Color",
  "editor.blockquote.tooltip": "Blockquote",
  "editor.horizontalrule.tooltip": "Horizontal Rule",
  "editor.code.tooltip": "Code",
  "editor.codeblock.tooltip": "Code Block",
  "editor.clear.tooltip": "Clear Format",
  "editor.undo.tooltip": "Undo",
  "editor.redo.tooltip": "Redo",
  "editor.fullscreen.tooltip.fullscreen": "Fullscreen",
  "editor.fullscreen.tooltip.exit": "Fullscreen Exit",
  "editor.imageUpload.fileTypeNotSupported": "File type not supported",
  "editor.imageUpload.fileSizeTooBig": "File size too big, Maximum size is",
  "editor.AI.placeholder": "Ask AI ...",
  "editor.AI.generating": "Generating",
  "editor.AI.insert": "Insert below selection",
  "editor.AI.replace": "Replace selected content",
  "editor.AI.regenerate": "Regenerate",
  "editor.AI.close": "Close",
  "editor.AI.stop": "Stop",
  "editor.AI.ask": "Ask AI",
  "editor.AI.error": "AI Error",
  "editor.AI.editorNotFound": "Editor not found",
  "editor.AI.noSelection": "Please select some text first",
  "editor.AI.unknownError": "An unknown error occurred",
  "editor.AI.noCachedPrompt": "No cached prompt found",
  "editor.AI.regenerateError": "Failed to regenerate response",
  "editor.AI.shortcutError": "Failed to execute shortcut",
  "editor.menubar.file": "File",
  "editor.menubar.edit": "Edit",
  "editor.menubar.view": "View",
  "editor.menubar.insert": "Insert",
  "editor.menubar.format": "Format",
  "editor.menubar.menu.newDoc": "New Document",
  "editor.menubar.menu.restoreLastDraft": "Restore last draft",
  "editor.menubar.menu.print": "Print",
  "editor.menubar.menu.cut": "Cut",
  "editor.menubar.menu.copy": "Copy",
  "editor.menubar.menu.paste": "Paste",
  "editor.menubar.menu.pasteAsText": "Paste as text",
  "editor.menubar.menu.selectAll": "Select all",
  "editor.menubar.menu.preview": "Preview",
  "editor.menubar.menu.spellCheck": "Spell check",
  "editor.findAndReplace.tooltip": "Find and replace",
  "editor.findAndReplace.find": "Find",
  "editor.findAndReplace.replace": "Replace",
  "editor.findAndReplace.replaceAll": "Replace All",
  "editor.findAndReplace.caseSensitive": "Case Sensitive",
  "editor.printer.tooltip": "Print",
  "editor.AI.shortcuts.generate.title": "Generate from selection",
  "editor.AI.shortcuts.generate.improve": "Improve writing",
  "editor.AI.shortcuts.generate.shorter": "Make shorter",
  "editor.AI.shortcuts.generate.longer": "Make longer",
  "editor.AI.shortcuts.generate.summarize": "Summarize",
  "editor.AI.shortcuts.generate.continue": "Continue",
  "editor.AI.shortcuts.tone.title": "Change Tone",
  "editor.AI.shortcuts.tone.professional": "Professional",
  "editor.AI.shortcuts.tone.casual": "Casual",
  "editor.AI.shortcuts.tone.direct": "Direct",
  "editor.AI.shortcuts.tone.confident": "Confident",
  "editor.AI.shortcuts.tone.friendly": "Friendly",
  "editor.AI.shortcuts.translate.title": "Translate",
  "editor.AI.shortcuts.translate.english": "English",
  "editor.AI.shortcuts.translate.chinese": "Simplified Chinese",
  "editor.AI.shortcuts.translate.spanish": "Spanish",
  "editor.AI.shortcuts.translate.german": "German",
  "editor.AI.shortcuts.translate.french": "French",
  "editor.AI.shortcuts.translate.portuguese": "Portuguese",
  "editor.AI.shortcuts.translate.korean": "Korean",
  "editor.AI.shortcuts.translate.japanese": "Japanese",
  "editor.AI.shortcuts.translate.hindi": "Hindi",
  "editor.AI.shortcuts.translate.russian": "Russian",
  "editor.AI.shortcuts.translate.arabic": "Arabic",
  "editor.AI.shortcuts.style.title": "Change Style",
  "editor.AI.shortcuts.style.business": "Business",
  "editor.AI.shortcuts.style.legal": "Legal",
  "editor.AI.shortcuts.style.journalism": "Journalism",
  "editor.AI.shortcuts.style.medical": "Medical",
  "editor.AI.shortcuts.style.poetic": "Poetic"
}, L9 = P9;
function N9(t) {
  return t = t || /* @__PURE__ */ new Map(), {
    /**
     * A Map of event names to registered handler functions.
     */
    all: t,
    /**
     * Register an event handler for the given type.
     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events
     * @param {Function} handler Function to call in response to given event
     * @memberOf mitt
     */
    on(e, n) {
      const o = t.get(e);
      o ? o.push(n) : t.set(e, [n]);
    },
    /**
     * Remove an event handler for the given type.
     * If `handler` is omitted, all handlers of the given type are removed.
     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)
     * @param {Function} [handler] Handler function to remove
     * @memberOf mitt
     */
    off(e, n) {
      const o = t.get(e);
      o && (n ? o.splice(o.indexOf(n) >>> 0, 1) : t.set(e, []));
    },
    /**
     * Invoke all handlers for the given type.
     * If present, `'*'` handlers are invoked after type-matched handlers.
     *
     * Note: Manually firing '*' handlers is not supported.
     *
     * @param {string|symbol} type The event type to invoke
     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler
     * @memberOf mitt
     */
    emit(e, n) {
      let o = t.get(e);
      o && o.slice().map((r) => {
        r(n);
      }), o = t.get("*"), o && o.slice().map((r) => {
        r(e, n);
      });
    }
  };
}
const Wi = {
  lang: N2,
  message: {
    zhHans: R9,
    en: L9
  }
};
class B9 {
  constructor() {
    Ws(this, "emitter");
    this.emitter = N9();
  }
  get lang() {
    return Wi.lang;
  }
  set lang(e) {
    if (!this.isLangSupported(e)) {
      console.warn(`Can't find the current language "${e}", Using language "${Wi.lang}" by default`);
      return;
    }
    Wi.lang = e, this.emitter.emit("lang", e);
  }
  get message() {
    return Wi.message;
  }
  set message(e) {
    Wi.message = e;
  }
  loadLangMessage(e) {
    return this.message[e];
  }
  isLangSupported(e) {
    return Object.keys(this.message).includes(e);
  }
  setLang(e) {
    this.lang = e;
  }
  registerWatchLang(e) {
    return this.emitter.on("lang", e), {
      unsubscribe: () => {
        this.emitter.off("lang", e);
      }
    };
  }
  setMessage(e, n) {
    this.message[e] = n;
  }
  buildLocalesHandler(e) {
    e || (e = this.lang);
    const n = this.loadLangMessage(e);
    return function(r) {
      return n[r] || r;
    };
  }
}
const lh = new B9(), et = () => {
  const t = O(Wi.lang), e = P(() => lh.buildLocalesHandler(p(t)));
  return Pe((n) => {
    const o = lh.registerWatchLang((r) => {
      t.value = r;
    });
    n(() => {
      o.unsubscribe();
    });
  }), {
    lang: t,
    t: e
  };
}, oJ = lh, $9 = zn({
  extensions: []
});
function z9() {
  return {
    state: $9
  };
}
function Es(t) {
  return om() ? (rm(t), !0) : !1;
}
function F9() {
  const t = /* @__PURE__ */ new Set(), e = (r) => {
    t.delete(r);
  };
  return {
    on: (r) => {
      t.add(r);
      const i = () => e(r);
      return Es(i), {
        off: i
      };
    },
    off: e,
    trigger: (...r) => Promise.all(Array.from(t).map((i) => i(...r)))
  };
}
function H9(t) {
  let e = !1, n;
  const o = nm(!0);
  return (...r) => (e || (n = o.run(() => t(...r)), e = !0), n);
}
function Tr(t) {
  return typeof t == "function" ? t() : p(t);
}
const Gm = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const V9 = (t) => typeof t < "u", gx = (t) => t != null, j9 = Object.prototype.toString, U9 = (t) => j9.call(t) === "[object Object]", Qn = () => {
}, W9 = (t, e) => Object.prototype.hasOwnProperty.call(t, e), K9 = /* @__PURE__ */ q9();
function q9() {
  var t, e;
  return Gm && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function vx(t, e) {
  function n(...o) {
    return new Promise((r, i) => {
      Promise.resolve(t(() => e.apply(this, o), { fn: e, thisArg: this, args: o })).then(r).catch(i);
    });
  }
  return n;
}
const yx = (t) => t();
function G9(t, e = {}) {
  let n, o, r = Qn;
  const i = (a) => {
    clearTimeout(a), r(), r = Qn;
  };
  return (a) => {
    const l = Tr(t), c = Tr(e.maxWait);
    return n && i(n), l <= 0 || c !== void 0 && c <= 0 ? (o && (i(o), o = null), Promise.resolve(a())) : new Promise((d, u) => {
      r = e.rejectOnCancel ? u : d, c && !o && (o = setTimeout(() => {
        n && i(n), o = null, d(a());
      }, c)), n = setTimeout(() => {
        o && i(o), o = null, d(a());
      }, l);
    });
  };
}
function J9(t = yx) {
  const e = O(!0);
  function n() {
    e.value = !1;
  }
  function o() {
    e.value = !0;
  }
  const r = (...i) => {
    e.value && t(...i);
  };
  return { isActive: Cs(e), pause: n, resume: o, eventFilter: r };
}
function Y9(t) {
  return In();
}
function X9(...t) {
  if (t.length !== 1)
    return _b(...t);
  const e = t[0];
  return typeof e == "function" ? Cs(tm(() => ({ get: e, set: Qn }))) : O(e);
}
function Z9(t, e = 200, n = {}) {
  return vx(
    G9(e, n),
    t
  );
}
function Q9(t, e, n = {}) {
  const {
    eventFilter: o = yx,
    ...r
  } = n;
  return ce(
    t,
    vx(
      o,
      e
    ),
    r
  );
}
function eO(t, e, n = {}) {
  const {
    eventFilter: o,
    ...r
  } = n, { eventFilter: i, pause: s, resume: a, isActive: l } = J9(o);
  return { stop: Q9(
    t,
    e,
    {
      ...r,
      eventFilter: i
    }
  ), pause: s, resume: a, isActive: l };
}
function Jm(t, e = !0, n) {
  Y9() ? _e(t, n) : e ? t() : qe(t);
}
function Vt(t) {
  var e;
  const n = Tr(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const On = Gm ? window : void 0, tO = Gm ? window.document : void 0;
function No(...t) {
  let e, n, o, r;
  if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, o, r] = t, e = On) : [e, n, o, r] = t, !e)
    return Qn;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const i = [], s = () => {
    i.forEach((d) => d()), i.length = 0;
  }, a = (d, u, f, h) => (d.addEventListener(u, f, h), () => d.removeEventListener(u, f, h)), l = ce(
    () => [Vt(e), Tr(r)],
    ([d, u]) => {
      if (s(), !d)
        return;
      const f = U9(u) ? { ...u } : u;
      i.push(
        ...n.flatMap((h) => o.map((m) => a(d, h, m, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    l(), s();
  };
  return Es(c), c;
}
let gv = !1;
function nO(t, e, n = {}) {
  const { window: o = On, ignore: r = [], capture: i = !0, detectIframe: s = !1 } = n;
  if (!o)
    return Qn;
  K9 && !gv && (gv = !0, Array.from(o.document.body.children).forEach((f) => f.addEventListener("click", Qn)), o.document.documentElement.addEventListener("click", Qn));
  let a = !0;
  const l = (f) => r.some((h) => {
    if (typeof h == "string")
      return Array.from(o.document.querySelectorAll(h)).some((m) => m === f.target || f.composedPath().includes(m));
    {
      const m = Vt(h);
      return m && (f.target === m || f.composedPath().includes(m));
    }
  }), d = [
    No(o, "click", (f) => {
      const h = Vt(t);
      if (!(!h || h === f.target || f.composedPath().includes(h))) {
        if (f.detail === 0 && (a = !l(f)), !a) {
          a = !0;
          return;
        }
        e(f);
      }
    }, { passive: !0, capture: i }),
    No(o, "pointerdown", (f) => {
      const h = Vt(t);
      a = !l(f) && !!(h && !f.composedPath().includes(h));
    }, { passive: !0 }),
    s && No(o, "blur", (f) => {
      setTimeout(() => {
        var h;
        const m = Vt(t);
        ((h = o.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(m != null && m.contains(o.document.activeElement)) && e(f);
      }, 0);
    })
  ].filter(Boolean);
  return () => d.forEach((f) => f());
}
function oO() {
  const t = O(!1), e = In();
  return e && _e(() => {
    t.value = !0;
  }, e), t;
}
function ku(t) {
  const e = oO();
  return P(() => (e.value, !!t()));
}
function rO(t, e = {}) {
  const { window: n = On } = e, o = ku(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
  let r;
  const i = O(!1), s = (c) => {
    i.value = c.matches;
  }, a = () => {
    r && ("removeEventListener" in r ? r.removeEventListener("change", s) : r.removeListener(s));
  }, l = Pe(() => {
    o.value && (a(), r = n.matchMedia(Tr(t)), "addEventListener" in r ? r.addEventListener("change", s) : r.addListener(s), i.value = r.matches);
  });
  return Es(() => {
    l(), a(), r = void 0;
  }), i;
}
function iO(t) {
  return JSON.parse(JSON.stringify(t));
}
const Yl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Xl = "__vueuse_ssr_handlers__", sO = /* @__PURE__ */ aO();
function aO() {
  return Xl in Yl || (Yl[Xl] = Yl[Xl] || {}), Yl[Xl];
}
function bx(t, e) {
  return sO[t] || e;
}
function lO(t) {
  return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number";
}
const cO = {
  boolean: {
    read: (t) => t === "true",
    write: (t) => String(t)
  },
  object: {
    read: (t) => JSON.parse(t),
    write: (t) => JSON.stringify(t)
  },
  number: {
    read: (t) => Number.parseFloat(t),
    write: (t) => String(t)
  },
  any: {
    read: (t) => t,
    write: (t) => String(t)
  },
  string: {
    read: (t) => t,
    write: (t) => String(t)
  },
  map: {
    read: (t) => new Map(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t.entries()))
  },
  set: {
    read: (t) => new Set(JSON.parse(t)),
    write: (t) => JSON.stringify(Array.from(t))
  },
  date: {
    read: (t) => new Date(t),
    write: (t) => t.toISOString()
  }
}, vv = "vueuse-storage";
function wx(t, e, n, o = {}) {
  var r;
  const {
    flush: i = "pre",
    deep: s = !0,
    listenToStorageChanges: a = !0,
    writeDefaults: l = !0,
    mergeDefaults: c = !1,
    shallow: d,
    window: u = On,
    eventFilter: f,
    onError: h = (M) => {
      console.error(M);
    },
    initOnMounted: m
  } = o, g = (d ? Xd : O)(typeof e == "function" ? e() : e);
  if (!n)
    try {
      n = bx("getDefaultStorage", () => {
        var M;
        return (M = On) == null ? void 0 : M.localStorage;
      })();
    } catch (M) {
      h(M);
    }
  if (!n)
    return g;
  const v = Tr(e), y = lO(v), x = (r = o.serializer) != null ? r : cO[y], { pause: C, resume: b } = eO(
    g,
    () => A(g.value),
    { flush: i, deep: s, eventFilter: f }
  );
  u && a && Jm(() => {
    No(u, "storage", z), No(u, vv, N), m && z();
  }), m || z();
  function S(M, $) {
    u && u.dispatchEvent(new CustomEvent(vv, {
      detail: {
        key: t,
        oldValue: M,
        newValue: $,
        storageArea: n
      }
    }));
  }
  function A(M) {
    try {
      const $ = n.getItem(t);
      if (M == null)
        S($, null), n.removeItem(t);
      else {
        const L = x.write(M);
        $ !== L && (n.setItem(t, L), S($, L));
      }
    } catch ($) {
      h($);
    }
  }
  function I(M) {
    const $ = M ? M.newValue : n.getItem(t);
    if ($ == null)
      return l && v != null && n.setItem(t, x.write(v)), v;
    if (!M && c) {
      const L = x.read($);
      return typeof c == "function" ? c(L, v) : y === "object" && !Array.isArray(L) ? { ...v, ...L } : L;
    } else
      return typeof $ != "string" ? $ : x.read($);
  }
  function z(M) {
    if (!(M && M.storageArea !== n)) {
      if (M && M.key == null) {
        g.value = v;
        return;
      }
      if (!(M && M.key !== t)) {
        C();
        try {
          (M == null ? void 0 : M.newValue) !== x.write(g.value) && (g.value = I(M));
        } catch ($) {
          h($);
        } finally {
          M ? qe(b) : b();
        }
      }
    }
  }
  function N(M) {
    z(M.detail);
  }
  return g;
}
function xx(t) {
  return rO("(prefers-color-scheme: dark)", t);
}
function dO(t = {}) {
  const {
    selector: e = "html",
    attribute: n = "class",
    initialValue: o = "auto",
    window: r = On,
    storage: i,
    storageKey: s = "vueuse-color-scheme",
    listenToStorageChanges: a = !0,
    storageRef: l,
    emitAuto: c,
    disableTransition: d = !0
  } = t, u = {
    auto: "",
    light: "light",
    dark: "dark",
    ...t.modes || {}
  }, f = xx({ window: r }), h = P(() => f.value ? "dark" : "light"), m = l || (s == null ? X9(o) : wx(s, o, i, { window: r, listenToStorageChanges: a })), g = P(() => m.value === "auto" ? h.value : m.value), v = bx(
    "updateHTMLAttrs",
    (b, S, A) => {
      const I = typeof b == "string" ? r == null ? void 0 : r.document.querySelector(b) : Vt(b);
      if (!I)
        return;
      let z;
      if (d && (z = r.document.createElement("style"), z.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), r.document.head.appendChild(z)), S === "class") {
        const N = A.split(/\s/g);
        Object.values(u).flatMap((M) => (M || "").split(/\s/g)).filter(Boolean).forEach((M) => {
          N.includes(M) ? I.classList.add(M) : I.classList.remove(M);
        });
      } else
        I.setAttribute(S, A);
      d && (r.getComputedStyle(z).opacity, document.head.removeChild(z));
    }
  );
  function y(b) {
    var S;
    v(e, n, (S = u[b]) != null ? S : b);
  }
  function x(b) {
    t.onChanged ? t.onChanged(b, y) : y(b);
  }
  ce(g, x, { flush: "post", immediate: !0 }), Jm(() => x(g.value));
  const C = P({
    get() {
      return c ? m.value : g.value;
    },
    set(b) {
      m.value = b;
    }
  });
  try {
    return Object.assign(C, { store: m, system: h, state: g });
  } catch {
    return C;
  }
}
function uO(t, e, n = {}) {
  const { window: o = On, ...r } = n;
  let i;
  const s = ku(() => o && "MutationObserver" in o), a = () => {
    i && (i.disconnect(), i = void 0);
  }, l = P(() => {
    const f = Tr(t), h = (Array.isArray(f) ? f : [f]).map(Vt).filter(gx);
    return new Set(h);
  }), c = ce(
    () => l.value,
    (f) => {
      a(), s.value && o && f.size && (i = new MutationObserver(e), f.forEach((h) => i.observe(h, r)));
    },
    { immediate: !0, flush: "post" }
  ), d = () => i == null ? void 0 : i.takeRecords(), u = () => {
    a(), c();
  };
  return Es(u), {
    isSupported: s,
    stop: u,
    takeRecords: d
  };
}
function fO(t = {}) {
  const {
    valueDark: e = "dark",
    valueLight: n = "",
    window: o = On
  } = t, r = dO({
    ...t,
    onChanged: (a, l) => {
      var c;
      t.onChanged ? (c = t.onChanged) == null || c.call(t, a === "dark", l, a) : l(a);
    },
    modes: {
      dark: e,
      light: n
    }
  }), i = P(() => r.system ? r.system.value : xx({ window: o }).value ? "dark" : "light");
  return P({
    get() {
      return r.value === "dark";
    },
    set(a) {
      const l = a ? "dark" : "light";
      i.value === l ? r.value = "auto" : r.value = l;
    }
  });
}
function pO(t, e, n = {}) {
  const { window: o = On, ...r } = n;
  let i;
  const s = ku(() => o && "ResizeObserver" in o), a = () => {
    i && (i.disconnect(), i = void 0);
  }, l = P(() => Array.isArray(t) ? t.map((u) => Vt(u)) : [Vt(t)]), c = ce(
    l,
    (u) => {
      if (a(), s.value && o) {
        i = new ResizeObserver(e);
        for (const f of u)
          f && i.observe(f, r);
      }
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    a(), c();
  };
  return Es(d), {
    isSupported: s,
    stop: d
  };
}
function hO(t, e = {}) {
  const {
    reset: n = !0,
    windowResize: o = !0,
    windowScroll: r = !0,
    immediate: i = !0
  } = e, s = O(0), a = O(0), l = O(0), c = O(0), d = O(0), u = O(0), f = O(0), h = O(0);
  function m() {
    const g = Vt(t);
    if (!g) {
      n && (s.value = 0, a.value = 0, l.value = 0, c.value = 0, d.value = 0, u.value = 0, f.value = 0, h.value = 0);
      return;
    }
    const v = g.getBoundingClientRect();
    s.value = v.height, a.value = v.bottom, l.value = v.left, c.value = v.right, d.value = v.top, u.value = v.width, f.value = v.x, h.value = v.y;
  }
  return pO(t, m), ce(() => Vt(t), (g) => !g && m()), uO(t, m, {
    attributeFilter: ["style", "class"]
  }), r && No("scroll", m, { capture: !0, passive: !0 }), o && No("resize", m, { passive: !0 }), Jm(() => {
    i && m();
  }), {
    height: s,
    bottom: a,
    left: l,
    right: c,
    top: d,
    width: u,
    x: f,
    y: h,
    update: m
  };
}
function mO(t, e, n = {}) {
  const {
    root: o,
    rootMargin: r = "0px",
    threshold: i = 0.1,
    window: s = On,
    immediate: a = !0
  } = n, l = ku(() => s && "IntersectionObserver" in s), c = P(() => {
    const m = Tr(t);
    return (Array.isArray(m) ? m : [m]).map(Vt).filter(gx);
  });
  let d = Qn;
  const u = O(a), f = l.value ? ce(
    () => [c.value, Vt(o), u.value],
    ([m, g]) => {
      if (d(), !u.value || !m.length)
        return;
      const v = new IntersectionObserver(
        e,
        {
          root: Vt(g),
          rootMargin: r,
          threshold: i
        }
      );
      m.forEach((y) => y && v.observe(y)), d = () => {
        v.disconnect(), d = Qn;
      };
    },
    { immediate: a, flush: "post" }
  ) : Qn, h = () => {
    d(), f(), u.value = !1;
  };
  return Es(h), {
    isSupported: l,
    isActive: u,
    pause() {
      d(), u.value = !1;
    },
    resume() {
      u.value = !0;
    },
    stop: h
  };
}
function gO(t, e = {}) {
  const { window: n = On, scrollTarget: o, threshold: r = 0 } = e, i = O(!1);
  return mO(
    t,
    (s) => {
      let a = i.value, l = 0;
      for (const c of s)
        c.time >= l && (l = c.time, a = c.isIntersecting);
      i.value = a;
    },
    {
      root: o,
      window: n,
      threshold: r
    }
  ), i;
}
const vO = {
  multiple: !0,
  accept: "*",
  reset: !1,
  directory: !1
};
function yO(t = {}) {
  const {
    document: e = tO
  } = t, n = O(null), { on: o, trigger: r } = F9();
  let i;
  e && (i = e.createElement("input"), i.type = "file", i.onchange = (l) => {
    const c = l.target;
    n.value = c.files, r(n.value);
  });
  const s = () => {
    n.value = null, i && (i.value = "", r(null));
  }, a = (l) => {
    if (!i)
      return;
    const c = {
      ...vO,
      ...t,
      ...l
    };
    i.multiple = c.multiple, i.accept = c.accept, i.webkitdirectory = c.directory, W9(c, "capture") && (i.capture = c.capture), c.reset && s(), i.click();
  };
  return {
    files: Cs(n),
    open: a,
    reset: s,
    onChange: o
  };
}
function Ym(t, e = {}) {
  const { initialValue: n = !1, focusVisible: o = !1 } = e, r = O(!1), i = P(() => Vt(t));
  No(i, "focus", (a) => {
    var l, c;
    (!o || (c = (l = a.target).matches) != null && c.call(l, ":focus-visible")) && (r.value = !0);
  }), No(i, "blur", () => r.value = !1);
  const s = P({
    get: () => r.value,
    set(a) {
      var l, c;
      !a && r.value ? (l = i.value) == null || l.blur() : a && !r.value && ((c = i.value) == null || c.focus());
    }
  });
  return ce(
    i,
    () => {
      s.value = n;
    },
    { immediate: !0, flush: "post" }
  ), { focused: s };
}
function bO(t, e, n = {}) {
  const { window: o = On } = n;
  return wx(t, e, o == null ? void 0 : o.localStorage, n);
}
function wO(t, e, n, o = {}) {
  var r, i, s;
  const {
    clone: a = !1,
    passive: l = !1,
    eventName: c,
    deep: d = !1,
    defaultValue: u,
    shouldEmit: f
  } = o, h = In(), m = n || (h == null ? void 0 : h.emit) || ((r = h == null ? void 0 : h.$emit) == null ? void 0 : r.bind(h)) || ((s = (i = h == null ? void 0 : h.proxy) == null ? void 0 : i.$emit) == null ? void 0 : s.bind(h == null ? void 0 : h.proxy));
  let g = c;
  g = g || `update:${e.toString()}`;
  const v = (C) => a ? typeof a == "function" ? a(C) : iO(C) : C, y = () => V9(t[e]) ? v(t[e]) : u, x = (C) => {
    f ? f(C) && m(g, C) : m(g, C);
  };
  if (l) {
    const C = y(), b = O(C);
    let S = !1;
    return ce(
      () => t[e],
      (A) => {
        S || (S = !0, b.value = v(A), qe(() => S = !1));
      }
    ), ce(
      b,
      (A) => {
        !S && (A !== t[e] || d) && x(A);
      },
      { deep: d }
    ), b;
  } else
    return P({
      get() {
        return y();
      },
      set(C) {
        x(C);
      }
    });
}
const pn = H9(() => {
  const { state: t } = z9(), e = zn({
    extensions: t.extensions ?? [],
    defaultLang: N2,
    isFullscreen: !1,
    color: void 0,
    highlight: void 0,
    AIMenu: !1,
    showPreview: !1,
    spellCheck: !1,
    findAndReplace: !1,
    printer: !1
  }), n = P(() => e.isFullscreen);
  function o() {
    e.isFullscreen = !e.isFullscreen;
  }
  function r() {
    e.showPreview = !e.showPreview;
  }
  function i() {
    e.spellCheck = !e.spellCheck;
  }
  function s() {
    e.findAndReplace = !e.findAndReplace;
  }
  function a() {
    e.printer = !e.printer;
  }
  return Pe(() => {
    e.extensions = t.extensions, e.defaultLang = t.defaultLang;
  }), {
    state: e,
    isFullscreen: n,
    toggleFullscreen: o,
    togglePreview: r,
    toggleSpellCheck: i,
    toggleFindAndReplace: s,
    togglePrinter: a
  };
}), Rf = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function Pf(t, e, n, o) {
  t.addEventListener ? t.addEventListener(e, n, o) : t.attachEvent && t.attachEvent("on".concat(e), n);
}
function Js(t, e, n, o) {
  t.removeEventListener ? t.removeEventListener(e, n, o) : t.detachEvent && t.detachEvent("on".concat(e), n);
}
function kx(t, e) {
  const n = e.slice(0, e.length - 1);
  for (let o = 0; o < n.length; o++)
    n[o] = t[n[o].toLowerCase()];
  return n;
}
function Cx(t) {
  typeof t != "string" && (t = ""), t = t.replace(/\s/g, "");
  const e = t.split(",");
  let n = e.lastIndexOf("");
  for (; n >= 0; )
    e[n - 1] += ",", e.splice(n, 1), n = e.lastIndexOf("");
  return e;
}
function xO(t, e) {
  const n = t.length >= e.length ? t : e, o = t.length >= e.length ? e : t;
  let r = !0;
  for (let i = 0; i < n.length; i++)
    o.indexOf(n[i]) === -1 && (r = !1);
  return r;
}
const Wa = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": Rf ? 173 : 189,
  "=": Rf ? 61 : 187,
  ";": Rf ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, lo = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, ch = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, Tt = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, dt = {};
for (let t = 1; t < 20; t++)
  Wa["f".concat(t)] = 111 + t;
let nt = [], ga = null, Sx = "all";
const Eo = /* @__PURE__ */ new Map(), Al = (t) => Wa[t.toLowerCase()] || lo[t.toLowerCase()] || t.toUpperCase().charCodeAt(0), kO = (t) => Object.keys(Wa).find((e) => Wa[e] === t), CO = (t) => Object.keys(lo).find((e) => lo[e] === t);
function Ax(t) {
  Sx = t || "all";
}
function Ka() {
  return Sx || "all";
}
function SO() {
  return nt.slice(0);
}
function AO() {
  return nt.map((t) => kO(t) || CO(t) || String.fromCharCode(t));
}
function EO() {
  const t = [];
  return Object.keys(dt).forEach((e) => {
    dt[e].forEach((n) => {
      let {
        key: o,
        scope: r,
        mods: i,
        shortcut: s
      } = n;
      t.push({
        scope: r,
        shortcut: s,
        mods: i,
        keys: o.split("+").map((a) => Al(a))
      });
    });
  }), t;
}
function _O(t) {
  const e = t.target || t.srcElement, {
    tagName: n
  } = e;
  let o = !0;
  const r = n === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(e.type);
  return (e.isContentEditable || (r || n === "TEXTAREA" || n === "SELECT") && !e.readOnly) && (o = !1), o;
}
function MO(t) {
  return typeof t == "string" && (t = Al(t)), nt.indexOf(t) !== -1;
}
function TO(t, e) {
  let n, o;
  t || (t = Ka());
  for (const r in dt)
    if (Object.prototype.hasOwnProperty.call(dt, r))
      for (n = dt[r], o = 0; o < n.length; )
        n[o].scope === t ? n.splice(o, 1).forEach((s) => {
          let {
            element: a
          } = s;
          return Xm(a);
        }) : o++;
  Ka() === t && Ax(e || "all");
}
function OO(t) {
  let e = t.keyCode || t.which || t.charCode;
  const n = nt.indexOf(e);
  if (n >= 0 && nt.splice(n, 1), t.key && t.key.toLowerCase() === "meta" && nt.splice(0, nt.length), (e === 93 || e === 224) && (e = 91), e in Tt) {
    Tt[e] = !1;
    for (const o in lo)
      lo[o] === e && ($n[o] = !1);
  }
}
function Ex(t) {
  if (typeof t > "u")
    Object.keys(dt).forEach((r) => {
      Array.isArray(dt[r]) && dt[r].forEach((i) => Zl(i)), delete dt[r];
    }), Xm(null);
  else if (Array.isArray(t))
    t.forEach((r) => {
      r.key && Zl(r);
    });
  else if (typeof t == "object")
    t.key && Zl(t);
  else if (typeof t == "string") {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++)
      n[o - 1] = arguments[o];
    let [r, i] = n;
    typeof r == "function" && (i = r, r = ""), Zl({
      key: t,
      scope: r,
      method: i,
      splitKey: "+"
    });
  }
}
const Zl = (t) => {
  let {
    key: e,
    scope: n,
    method: o,
    splitKey: r = "+"
  } = t;
  Cx(e).forEach((s) => {
    const a = s.split(r), l = a.length, c = a[l - 1], d = c === "*" ? "*" : Al(c);
    if (!dt[d])
      return;
    n || (n = Ka());
    const u = l > 1 ? kx(lo, a) : [], f = [];
    dt[d] = dt[d].filter((h) => {
      const g = (o ? h.method === o : !0) && h.scope === n && xO(h.mods, u);
      return g && f.push(h.element), !g;
    }), f.forEach((h) => Xm(h));
  });
};
function yv(t, e, n, o) {
  if (e.element !== o)
    return;
  let r;
  if (e.scope === n || e.scope === "all") {
    r = e.mods.length > 0;
    for (const i in Tt)
      Object.prototype.hasOwnProperty.call(Tt, i) && (!Tt[i] && e.mods.indexOf(+i) > -1 || Tt[i] && e.mods.indexOf(+i) === -1) && (r = !1);
    (e.mods.length === 0 && !Tt[16] && !Tt[18] && !Tt[17] && !Tt[91] || r || e.shortcut === "*") && (e.keys = [], e.keys = e.keys.concat(nt), e.method(t, e) === !1 && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0)));
  }
}
function bv(t, e) {
  const n = dt["*"];
  let o = t.keyCode || t.which || t.charCode;
  if (!$n.filter.call(this, t))
    return;
  if ((o === 93 || o === 224) && (o = 91), nt.indexOf(o) === -1 && o !== 229 && nt.push(o), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach((a) => {
    const l = ch[a];
    t[a] && nt.indexOf(l) === -1 ? nt.push(l) : !t[a] && nt.indexOf(l) > -1 ? nt.splice(nt.indexOf(l), 1) : a === "metaKey" && t[a] && nt.length === 3 && (t.ctrlKey || t.shiftKey || t.altKey || (nt = nt.slice(nt.indexOf(l))));
  }), o in Tt) {
    Tt[o] = !0;
    for (const a in lo)
      lo[a] === o && ($n[a] = !0);
    if (!n)
      return;
  }
  for (const a in Tt)
    Object.prototype.hasOwnProperty.call(Tt, a) && (Tt[a] = t[ch[a]]);
  t.getModifierState && !(t.altKey && !t.ctrlKey) && t.getModifierState("AltGraph") && (nt.indexOf(17) === -1 && nt.push(17), nt.indexOf(18) === -1 && nt.push(18), Tt[17] = !0, Tt[18] = !0);
  const r = Ka();
  if (n)
    for (let a = 0; a < n.length; a++)
      n[a].scope === r && (t.type === "keydown" && n[a].keydown || t.type === "keyup" && n[a].keyup) && yv(t, n[a], r, e);
  if (!(o in dt))
    return;
  const i = dt[o], s = i.length;
  for (let a = 0; a < s; a++)
    if ((t.type === "keydown" && i[a].keydown || t.type === "keyup" && i[a].keyup) && i[a].key) {
      const l = i[a], {
        splitKey: c
      } = l, d = l.key.split(c), u = [];
      for (let f = 0; f < d.length; f++)
        u.push(Al(d[f]));
      u.sort().join("") === nt.sort().join("") && yv(t, l, r, e);
    }
}
function $n(t, e, n) {
  nt = [];
  const o = Cx(t);
  let r = [], i = "all", s = document, a = 0, l = !1, c = !0, d = "+", u = !1, f = !1;
  for (n === void 0 && typeof e == "function" && (n = e), Object.prototype.toString.call(e) === "[object Object]" && (e.scope && (i = e.scope), e.element && (s = e.element), e.keyup && (l = e.keyup), e.keydown !== void 0 && (c = e.keydown), e.capture !== void 0 && (u = e.capture), typeof e.splitKey == "string" && (d = e.splitKey), e.single === !0 && (f = !0)), typeof e == "string" && (i = e), f && Ex(t, i); a < o.length; a++)
    t = o[a].split(d), r = [], t.length > 1 && (r = kx(lo, t)), t = t[t.length - 1], t = t === "*" ? "*" : Al(t), t in dt || (dt[t] = []), dt[t].push({
      keyup: l,
      keydown: c,
      scope: i,
      mods: r,
      shortcut: o[a],
      method: n,
      key: o[a],
      splitKey: d,
      element: s
    });
  if (typeof s < "u" && window) {
    if (!Eo.has(s)) {
      const h = function() {
        let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return bv(g, s);
      }, m = function() {
        let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        bv(g, s), OO(g);
      };
      Eo.set(s, {
        keydownListener: h,
        keyupListenr: m,
        capture: u
      }), Pf(s, "keydown", h, u), Pf(s, "keyup", m, u);
    }
    if (!ga) {
      const h = () => {
        nt = [];
      };
      ga = {
        listener: h,
        capture: u
      }, Pf(window, "focus", h, u);
    }
  }
}
function IO(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(dt).forEach((n) => {
    dt[n].filter((r) => r.scope === e && r.shortcut === t).forEach((r) => {
      r && r.method && r.method();
    });
  });
}
function Xm(t) {
  const e = Object.values(dt).flat();
  if (e.findIndex((o) => {
    let {
      element: r
    } = o;
    return r === t;
  }) < 0) {
    const {
      keydownListener: o,
      keyupListenr: r,
      capture: i
    } = Eo.get(t) || {};
    o && r && (Js(t, "keyup", r, i), Js(t, "keydown", o, i), Eo.delete(t));
  }
  if ((e.length <= 0 || Eo.size <= 0) && (Object.keys(Eo).forEach((r) => {
    const {
      keydownListener: i,
      keyupListenr: s,
      capture: a
    } = Eo.get(r) || {};
    i && s && (Js(r, "keyup", s, a), Js(r, "keydown", i, a), Eo.delete(r));
  }), Eo.clear(), Object.keys(dt).forEach((r) => delete dt[r]), ga)) {
    const {
      listener: r,
      capture: i
    } = ga;
    Js(window, "focus", r, i), ga = null;
  }
}
const Lf = {
  getPressedKeyString: AO,
  setScope: Ax,
  getScope: Ka,
  deleteScope: TO,
  getPressedKeyCodes: SO,
  getAllKeyCodes: EO,
  isPressed: MO,
  filter: _O,
  trigger: IO,
  unbind: Ex,
  keyMap: Wa,
  modifier: lo,
  modifierMap: ch
};
for (const t in Lf)
  Object.prototype.hasOwnProperty.call(Lf, t) && ($n[t] = Lf[t]);
if (typeof window < "u") {
  const t = window.hotkeys;
  $n.noConflict = (e) => (e && window.hotkeys === $n && (window.hotkeys = t), $n), window.hotkeys = $n;
}
const _x = (t, e) => {
  $n.filter = () => !0;
  const n = () => {
    $n(t, (r) => (r.preventDefault(), e(), !1));
  }, o = () => {
    $n.unbind(t);
  };
  return jo(() => {
    o();
  }), { bind: n, unbind: o };
}, DO = ["top", "right", "bottom", "left"], Xn = Math.min, rn = Math.max, ad = Math.round, Ql = Math.floor, Or = (t) => ({
  x: t,
  y: t
}), RO = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, PO = {
  start: "end",
  end: "start"
};
function dh(t, e, n) {
  return rn(t, Xn(e, n));
}
function zo(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Fo(t) {
  return t.split("-")[0];
}
function _s(t) {
  return t.split("-")[1];
}
function Zm(t) {
  return t === "x" ? "y" : "x";
}
function Qm(t) {
  return t === "y" ? "height" : "width";
}
function Ms(t) {
  return ["top", "bottom"].includes(Fo(t)) ? "y" : "x";
}
function eg(t) {
  return Zm(Ms(t));
}
function LO(t, e, n) {
  n === void 0 && (n = !1);
  const o = _s(t), r = eg(t), i = Qm(r);
  let s = r === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (s = ld(s)), [s, ld(s)];
}
function NO(t) {
  const e = ld(t);
  return [uh(t), e, uh(e)];
}
function uh(t) {
  return t.replace(/start|end/g, (e) => PO[e]);
}
function BO(t, e, n) {
  const o = ["left", "right"], r = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? r : o : e ? o : r;
    case "left":
    case "right":
      return e ? i : s;
    default:
      return [];
  }
}
function $O(t, e, n, o) {
  const r = _s(t);
  let i = BO(Fo(t), n === "start", o);
  return r && (i = i.map((s) => s + "-" + r), e && (i = i.concat(i.map(uh)))), i;
}
function ld(t) {
  return t.replace(/left|right|bottom|top/g, (e) => RO[e]);
}
function zO(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Mx(t) {
  return typeof t != "number" ? zO(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function cd(t) {
  const {
    x: e,
    y: n,
    width: o,
    height: r
  } = t;
  return {
    width: o,
    height: r,
    top: n,
    left: e,
    right: e + o,
    bottom: n + r,
    x: e,
    y: n
  };
}
function wv(t, e, n) {
  let {
    reference: o,
    floating: r
  } = t;
  const i = Ms(e), s = eg(e), a = Qm(s), l = Fo(e), c = i === "y", d = o.x + o.width / 2 - r.width / 2, u = o.y + o.height / 2 - r.height / 2, f = o[a] / 2 - r[a] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: d,
        y: o.y - r.height
      };
      break;
    case "bottom":
      h = {
        x: d,
        y: o.y + o.height
      };
      break;
    case "right":
      h = {
        x: o.x + o.width,
        y: u
      };
      break;
    case "left":
      h = {
        x: o.x - r.width,
        y: u
      };
      break;
    default:
      h = {
        x: o.x,
        y: o.y
      };
  }
  switch (_s(e)) {
    case "start":
      h[s] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      h[s] += f * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const FO = async (t, e, n) => {
  const {
    placement: o = "bottom",
    strategy: r = "absolute",
    middleware: i = [],
    platform: s
  } = n, a = i.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let c = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: r
  }), {
    x: d,
    y: u
  } = wv(c, o, l), f = o, h = {}, m = 0;
  for (let g = 0; g < a.length; g++) {
    const {
      name: v,
      fn: y
    } = a[g], {
      x,
      y: C,
      data: b,
      reset: S
    } = await y({
      x: d,
      y: u,
      initialPlacement: o,
      placement: f,
      strategy: r,
      middlewareData: h,
      rects: c,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    d = x ?? d, u = C ?? u, h = {
      ...h,
      [v]: {
        ...h[v],
        ...b
      }
    }, S && m <= 50 && (m++, typeof S == "object" && (S.placement && (f = S.placement), S.rects && (c = S.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: r
    }) : S.rects), {
      x: d,
      y: u
    } = wv(c, f, l)), g = -1);
  }
  return {
    x: d,
    y: u,
    placement: f,
    strategy: r,
    middlewareData: h
  };
};
async function qa(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: o,
    y: r,
    platform: i,
    rects: s,
    elements: a,
    strategy: l
  } = t, {
    boundary: c = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: u = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = zo(e, t), m = Mx(h), v = a[f ? u === "floating" ? "reference" : "floating" : u], y = cd(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(v))) == null || n ? v : v.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: d,
    strategy: l
  })), x = u === "floating" ? {
    x: o,
    y: r,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, C = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), b = await (i.isElement == null ? void 0 : i.isElement(C)) ? await (i.getScale == null ? void 0 : i.getScale(C)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = cd(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: x,
    offsetParent: C,
    strategy: l
  }) : x);
  return {
    top: (y.top - S.top + m.top) / b.y,
    bottom: (S.bottom - y.bottom + m.bottom) / b.y,
    left: (y.left - S.left + m.left) / b.x,
    right: (S.right - y.right + m.right) / b.x
  };
}
const HO = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: o,
      placement: r,
      rects: i,
      platform: s,
      elements: a,
      middlewareData: l
    } = e, {
      element: c,
      padding: d = 0
    } = zo(t, e) || {};
    if (c == null)
      return {};
    const u = Mx(d), f = {
      x: n,
      y: o
    }, h = eg(r), m = Qm(h), g = await s.getDimensions(c), v = h === "y", y = v ? "top" : "left", x = v ? "bottom" : "right", C = v ? "clientHeight" : "clientWidth", b = i.reference[m] + i.reference[h] - f[h] - i.floating[m], S = f[h] - i.reference[h], A = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
    let I = A ? A[C] : 0;
    (!I || !await (s.isElement == null ? void 0 : s.isElement(A))) && (I = a.floating[C] || i.floating[m]);
    const z = b / 2 - S / 2, N = I / 2 - g[m] / 2 - 1, M = Xn(u[y], N), $ = Xn(u[x], N), L = M, Y = I - g[m] - $, J = I / 2 - g[m] / 2 + z, ne = dh(L, J, Y), F = !l.arrow && _s(r) != null && J !== ne && i.reference[m] / 2 - (J < L ? M : $) - g[m] / 2 < 0, R = F ? J < L ? J - L : J - Y : 0;
    return {
      [h]: f[h] + R,
      data: {
        [h]: ne,
        centerOffset: J - ne - R,
        ...F && {
          alignmentOffset: R
        }
      },
      reset: F
    };
  }
}), VO = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, o;
      const {
        placement: r,
        middlewareData: i,
        rects: s,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: d = !0,
        crossAxis: u = !0,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: g = !0,
        ...v
      } = zo(t, e);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const y = Fo(r), x = Fo(a) === a, C = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), b = f || (x || !g ? [ld(a)] : NO(a));
      !f && m !== "none" && b.push(...$O(a, g, m, C));
      const S = [a, ...b], A = await qa(e, v), I = [];
      let z = ((o = i.flip) == null ? void 0 : o.overflows) || [];
      if (d && I.push(A[y]), u) {
        const L = LO(r, s, C);
        I.push(A[L[0]], A[L[1]]);
      }
      if (z = [...z, {
        placement: r,
        overflows: I
      }], !I.every((L) => L <= 0)) {
        var N, M;
        const L = (((N = i.flip) == null ? void 0 : N.index) || 0) + 1, Y = S[L];
        if (Y)
          return {
            data: {
              index: L,
              overflows: z
            },
            reset: {
              placement: Y
            }
          };
        let J = (M = z.filter((ne) => ne.overflows[0] <= 0).sort((ne, F) => ne.overflows[1] - F.overflows[1])[0]) == null ? void 0 : M.placement;
        if (!J)
          switch (h) {
            case "bestFit": {
              var $;
              const ne = ($ = z.map((F) => [F.placement, F.overflows.filter((R) => R > 0).reduce((R, H) => R + H, 0)]).sort((F, R) => F[1] - R[1])[0]) == null ? void 0 : $[0];
              ne && (J = ne);
              break;
            }
            case "initialPlacement":
              J = a;
              break;
          }
        if (r !== J)
          return {
            reset: {
              placement: J
            }
          };
      }
      return {};
    }
  };
};
function xv(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function kv(t) {
  return DO.some((e) => t[e] >= 0);
}
const jO = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: o = "referenceHidden",
        ...r
      } = zo(t, e);
      switch (o) {
        case "referenceHidden": {
          const i = await qa(e, {
            ...r,
            elementContext: "reference"
          }), s = xv(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: kv(s)
            }
          };
        }
        case "escaped": {
          const i = await qa(e, {
            ...r,
            altBoundary: !0
          }), s = xv(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: kv(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function UO(t, e) {
  const {
    placement: n,
    platform: o,
    elements: r
  } = t, i = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)), s = Fo(n), a = _s(n), l = Ms(n) === "y", c = ["left", "top"].includes(s) ? -1 : 1, d = i && l ? -1 : 1, u = zo(e, t);
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: m
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...u
  };
  return a && typeof m == "number" && (h = a === "end" ? m * -1 : m), l ? {
    x: h * d,
    y: f * c
  } : {
    x: f * c,
    y: h * d
  };
}
const WO = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, o;
      const {
        x: r,
        y: i,
        placement: s,
        middlewareData: a
      } = e, l = await UO(e, t);
      return s === ((n = a.offset) == null ? void 0 : n.placement) && (o = a.arrow) != null && o.alignmentOffset ? {} : {
        x: r + l.x,
        y: i + l.y,
        data: {
          ...l,
          placement: s
        }
      };
    }
  };
}, KO = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: o,
        placement: r
      } = e, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (v) => {
            let {
              x: y,
              y: x
            } = v;
            return {
              x: y,
              y: x
            };
          }
        },
        ...l
      } = zo(t, e), c = {
        x: n,
        y: o
      }, d = await qa(e, l), u = Ms(Fo(r)), f = Zm(u);
      let h = c[f], m = c[u];
      if (i) {
        const v = f === "y" ? "top" : "left", y = f === "y" ? "bottom" : "right", x = h + d[v], C = h - d[y];
        h = dh(x, h, C);
      }
      if (s) {
        const v = u === "y" ? "top" : "left", y = u === "y" ? "bottom" : "right", x = m + d[v], C = m - d[y];
        m = dh(x, m, C);
      }
      const g = a.fn({
        ...e,
        [f]: h,
        [u]: m
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - o
        }
      };
    }
  };
}, qO = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: o,
        placement: r,
        rects: i,
        middlewareData: s
      } = e, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = zo(t, e), d = {
        x: n,
        y: o
      }, u = Ms(r), f = Zm(u);
      let h = d[f], m = d[u];
      const g = zo(a, e), v = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (l) {
        const C = f === "y" ? "height" : "width", b = i.reference[f] - i.floating[C] + v.mainAxis, S = i.reference[f] + i.reference[C] - v.mainAxis;
        h < b ? h = b : h > S && (h = S);
      }
      if (c) {
        var y, x;
        const C = f === "y" ? "width" : "height", b = ["top", "left"].includes(Fo(r)), S = i.reference[u] - i.floating[C] + (b && ((y = s.offset) == null ? void 0 : y[u]) || 0) + (b ? 0 : v.crossAxis), A = i.reference[u] + i.reference[C] + (b ? 0 : ((x = s.offset) == null ? void 0 : x[u]) || 0) - (b ? v.crossAxis : 0);
        m < S ? m = S : m > A && (m = A);
      }
      return {
        [f]: h,
        [u]: m
      };
    }
  };
}, GO = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      const {
        placement: n,
        rects: o,
        platform: r,
        elements: i
      } = e, {
        apply: s = () => {
        },
        ...a
      } = zo(t, e), l = await qa(e, a), c = Fo(n), d = _s(n), u = Ms(n) === "y", {
        width: f,
        height: h
      } = o.floating;
      let m, g;
      c === "top" || c === "bottom" ? (m = c, g = d === (await (r.isRTL == null ? void 0 : r.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (g = c, m = d === "end" ? "top" : "bottom");
      const v = h - l.top - l.bottom, y = f - l.left - l.right, x = Xn(h - l[m], v), C = Xn(f - l[g], y), b = !e.middlewareData.shift;
      let S = x, A = C;
      if (u ? A = d || b ? Xn(C, y) : y : S = d || b ? Xn(x, v) : v, b && !d) {
        const z = rn(l.left, 0), N = rn(l.right, 0), M = rn(l.top, 0), $ = rn(l.bottom, 0);
        u ? A = f - 2 * (z !== 0 || N !== 0 ? z + N : rn(l.left, l.right)) : S = h - 2 * (M !== 0 || $ !== 0 ? M + $ : rn(l.top, l.bottom));
      }
      await s({
        ...e,
        availableWidth: A,
        availableHeight: S
      });
      const I = await r.getDimensions(i.floating);
      return f !== I.width || h !== I.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Ai(t) {
  return tg(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function dn(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Ko(t) {
  var e;
  return (e = (tg(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function tg(t) {
  return t instanceof Node || t instanceof dn(t).Node;
}
function co(t) {
  return t instanceof Element || t instanceof dn(t).Element;
}
function uo(t) {
  return t instanceof HTMLElement || t instanceof dn(t).HTMLElement;
}
function Cv(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof dn(t).ShadowRoot;
}
function El(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: o,
    display: r
  } = Hn(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + o + n) && !["inline", "contents"].includes(r);
}
function JO(t) {
  return ["table", "td", "th"].includes(Ai(t));
}
function ng(t) {
  const e = og(), n = Hn(t);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((o) => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (n.contain || "").includes(o));
}
function YO(t) {
  let e = Ir(t);
  for (; uo(e) && !hs(e); ) {
    if (ng(e))
      return e;
    e = Ir(e);
  }
  return null;
}
function og() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function hs(t) {
  return ["html", "body", "#document"].includes(Ai(t));
}
function Hn(t) {
  return dn(t).getComputedStyle(t);
}
function Cu(t) {
  return co(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  };
}
function Ir(t) {
  if (Ai(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Cv(t) && t.host || // Fallback.
    Ko(t)
  );
  return Cv(e) ? e.host : e;
}
function Tx(t) {
  const e = Ir(t);
  return hs(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : uo(e) && El(e) ? e : Tx(e);
}
function Ga(t, e, n) {
  var o;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const r = Tx(t), i = r === ((o = t.ownerDocument) == null ? void 0 : o.body), s = dn(r);
  return i ? e.concat(s, s.visualViewport || [], El(r) ? r : [], s.frameElement && n ? Ga(s.frameElement) : []) : e.concat(r, Ga(r, [], n));
}
function Ox(t) {
  const e = Hn(t);
  let n = parseFloat(e.width) || 0, o = parseFloat(e.height) || 0;
  const r = uo(t), i = r ? t.offsetWidth : n, s = r ? t.offsetHeight : o, a = ad(n) !== i || ad(o) !== s;
  return a && (n = i, o = s), {
    width: n,
    height: o,
    $: a
  };
}
function rg(t) {
  return co(t) ? t : t.contextElement;
}
function ts(t) {
  const e = rg(t);
  if (!uo(e))
    return Or(1);
  const n = e.getBoundingClientRect(), {
    width: o,
    height: r,
    $: i
  } = Ox(e);
  let s = (i ? ad(n.width) : n.width) / o, a = (i ? ad(n.height) : n.height) / r;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const XO = /* @__PURE__ */ Or(0);
function Ix(t) {
  const e = dn(t);
  return !og() || !e.visualViewport ? XO : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function ZO(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== dn(t) ? !1 : e;
}
function yi(t, e, n, o) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(), i = rg(t);
  let s = Or(1);
  e && (o ? co(o) && (s = ts(o)) : s = ts(t));
  const a = ZO(i, n, o) ? Ix(i) : Or(0);
  let l = (r.left + a.x) / s.x, c = (r.top + a.y) / s.y, d = r.width / s.x, u = r.height / s.y;
  if (i) {
    const f = dn(i), h = o && co(o) ? dn(o) : o;
    let m = f, g = m.frameElement;
    for (; g && o && h !== m; ) {
      const v = ts(g), y = g.getBoundingClientRect(), x = Hn(g), C = y.left + (g.clientLeft + parseFloat(x.paddingLeft)) * v.x, b = y.top + (g.clientTop + parseFloat(x.paddingTop)) * v.y;
      l *= v.x, c *= v.y, d *= v.x, u *= v.y, l += C, c += b, m = dn(g), g = m.frameElement;
    }
  }
  return cd({
    width: d,
    height: u,
    x: l,
    y: c
  });
}
const QO = [":popover-open", ":modal"];
function ig(t) {
  return QO.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function eI(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: o,
    strategy: r
  } = t;
  const i = r === "fixed", s = Ko(o), a = e ? ig(e.floating) : !1;
  if (o === s || a && i)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = Or(1);
  const d = Or(0), u = uo(o);
  if ((u || !u && !i) && ((Ai(o) !== "body" || El(s)) && (l = Cu(o)), uo(o))) {
    const f = yi(o);
    c = ts(o), d.x = f.x + o.clientLeft, d.y = f.y + o.clientTop;
  }
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + d.x,
    y: n.y * c.y - l.scrollTop * c.y + d.y
  };
}
function tI(t) {
  return Array.from(t.getClientRects());
}
function Dx(t) {
  return yi(Ko(t)).left + Cu(t).scrollLeft;
}
function nI(t) {
  const e = Ko(t), n = Cu(t), o = t.ownerDocument.body, r = rn(e.scrollWidth, e.clientWidth, o.scrollWidth, o.clientWidth), i = rn(e.scrollHeight, e.clientHeight, o.scrollHeight, o.clientHeight);
  let s = -n.scrollLeft + Dx(t);
  const a = -n.scrollTop;
  return Hn(o).direction === "rtl" && (s += rn(e.clientWidth, o.clientWidth) - r), {
    width: r,
    height: i,
    x: s,
    y: a
  };
}
function oI(t, e) {
  const n = dn(t), o = Ko(t), r = n.visualViewport;
  let i = o.clientWidth, s = o.clientHeight, a = 0, l = 0;
  if (r) {
    i = r.width, s = r.height;
    const c = og();
    (!c || c && e === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: a,
    y: l
  };
}
function rI(t, e) {
  const n = yi(t, !0, e === "fixed"), o = n.top + t.clientTop, r = n.left + t.clientLeft, i = uo(t) ? ts(t) : Or(1), s = t.clientWidth * i.x, a = t.clientHeight * i.y, l = r * i.x, c = o * i.y;
  return {
    width: s,
    height: a,
    x: l,
    y: c
  };
}
function Sv(t, e, n) {
  let o;
  if (e === "viewport")
    o = oI(t, n);
  else if (e === "document")
    o = nI(Ko(t));
  else if (co(e))
    o = rI(e, n);
  else {
    const r = Ix(t);
    o = {
      ...e,
      x: e.x - r.x,
      y: e.y - r.y
    };
  }
  return cd(o);
}
function Rx(t, e) {
  const n = Ir(t);
  return n === e || !co(n) || hs(n) ? !1 : Hn(n).position === "fixed" || Rx(n, e);
}
function iI(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let o = Ga(t, [], !1).filter((a) => co(a) && Ai(a) !== "body"), r = null;
  const i = Hn(t).position === "fixed";
  let s = i ? Ir(t) : t;
  for (; co(s) && !hs(s); ) {
    const a = Hn(s), l = ng(s);
    !l && a.position === "fixed" && (r = null), (i ? !l && !r : !l && a.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || El(s) && !l && Rx(t, s)) ? o = o.filter((d) => d !== s) : r = a, s = Ir(s);
  }
  return e.set(t, o), o;
}
function sI(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: o,
    strategy: r
  } = t;
  const s = [...n === "clippingAncestors" ? ig(e) ? [] : iI(e, this._c) : [].concat(n), o], a = s[0], l = s.reduce((c, d) => {
    const u = Sv(e, d, r);
    return c.top = rn(u.top, c.top), c.right = Xn(u.right, c.right), c.bottom = Xn(u.bottom, c.bottom), c.left = rn(u.left, c.left), c;
  }, Sv(e, a, r));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function aI(t) {
  const {
    width: e,
    height: n
  } = Ox(t);
  return {
    width: e,
    height: n
  };
}
function lI(t, e, n) {
  const o = uo(e), r = Ko(e), i = n === "fixed", s = yi(t, !0, i, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Or(0);
  if (o || !o && !i)
    if ((Ai(e) !== "body" || El(r)) && (a = Cu(e)), o) {
      const u = yi(e, !0, i, e);
      l.x = u.x + e.clientLeft, l.y = u.y + e.clientTop;
    } else
      r && (l.x = Dx(r));
  const c = s.left + a.scrollLeft - l.x, d = s.top + a.scrollTop - l.y;
  return {
    x: c,
    y: d,
    width: s.width,
    height: s.height
  };
}
function Nf(t) {
  return Hn(t).position === "static";
}
function Av(t, e) {
  return !uo(t) || Hn(t).position === "fixed" ? null : e ? e(t) : t.offsetParent;
}
function Px(t, e) {
  const n = dn(t);
  if (ig(t))
    return n;
  if (!uo(t)) {
    let r = Ir(t);
    for (; r && !hs(r); ) {
      if (co(r) && !Nf(r))
        return r;
      r = Ir(r);
    }
    return n;
  }
  let o = Av(t, e);
  for (; o && JO(o) && Nf(o); )
    o = Av(o, e);
  return o && hs(o) && Nf(o) && !ng(o) ? n : o || YO(t) || n;
}
const cI = async function(t) {
  const e = this.getOffsetParent || Px, n = this.getDimensions, o = await n(t.floating);
  return {
    reference: lI(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function dI(t) {
  return Hn(t).direction === "rtl";
}
const uI = {
  convertOffsetParentRelativeRectToViewportRelativeRect: eI,
  getDocumentElement: Ko,
  getClippingRect: sI,
  getOffsetParent: Px,
  getElementRects: cI,
  getClientRects: tI,
  getDimensions: aI,
  getScale: ts,
  isElement: co,
  isRTL: dI
};
function fI(t, e) {
  let n = null, o;
  const r = Ko(t);
  function i() {
    var a;
    clearTimeout(o), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), i();
    const {
      left: c,
      top: d,
      width: u,
      height: f
    } = t.getBoundingClientRect();
    if (a || e(), !u || !f)
      return;
    const h = Ql(d), m = Ql(r.clientWidth - (c + u)), g = Ql(r.clientHeight - (d + f)), v = Ql(c), x = {
      rootMargin: -h + "px " + -m + "px " + -g + "px " + -v + "px",
      threshold: rn(0, Xn(1, l)) || 1
    };
    let C = !0;
    function b(S) {
      const A = S[0].intersectionRatio;
      if (A !== l) {
        if (!C)
          return s();
        A ? s(!1, A) : o = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      C = !1;
    }
    try {
      n = new IntersectionObserver(b, {
        ...x,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(b, x);
    }
    n.observe(t);
  }
  return s(!0), i;
}
function pI(t, e, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = o, c = rg(t), d = r || i ? [...c ? Ga(c) : [], ...Ga(e)] : [];
  d.forEach((y) => {
    r && y.addEventListener("scroll", n, {
      passive: !0
    }), i && y.addEventListener("resize", n);
  });
  const u = c && a ? fI(c, n) : null;
  let f = -1, h = null;
  s && (h = new ResizeObserver((y) => {
    let [x] = y;
    x && x.target === c && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var C;
      (C = h) == null || C.observe(e);
    })), n();
  }), c && !l && h.observe(c), h.observe(e));
  let m, g = l ? yi(t) : null;
  l && v();
  function v() {
    const y = yi(t);
    g && (y.x !== g.x || y.y !== g.y || y.width !== g.width || y.height !== g.height) && n(), g = y, m = requestAnimationFrame(v);
  }
  return n(), () => {
    var y;
    d.forEach((x) => {
      r && x.removeEventListener("scroll", n), i && x.removeEventListener("resize", n);
    }), u == null || u(), (y = h) == null || y.disconnect(), h = null, l && cancelAnimationFrame(m);
  };
}
const hI = WO, mI = KO, Ev = VO, gI = GO, vI = jO, yI = HO, bI = qO, wI = (t, e, n) => {
  const o = /* @__PURE__ */ new Map(), r = {
    platform: uI,
    ...n
  }, i = {
    ...r.platform,
    _c: o
  };
  return FO(t, e, {
    ...r,
    platform: i
  });
};
function xI(t) {
  return t != null && typeof t == "object" && "$el" in t;
}
function fh(t) {
  if (xI(t)) {
    const e = t.$el;
    return tg(e) && Ai(e) === "#comment" ? null : e;
  }
  return t;
}
function kI(t) {
  return {
    name: "arrow",
    options: t,
    fn(e) {
      const n = fh(p(t.element));
      return n == null ? {} : yI({
        element: n,
        padding: t.padding
      }).fn(e);
    }
  };
}
function Lx(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _v(t, e) {
  const n = Lx(t);
  return Math.round(e * n) / n;
}
function CI(t, e, n) {
  n === void 0 && (n = {});
  const o = n.whileElementsMounted, r = P(() => {
    var I;
    return (I = p(n.open)) != null ? I : !0;
  }), i = P(() => p(n.middleware)), s = P(() => {
    var I;
    return (I = p(n.placement)) != null ? I : "bottom";
  }), a = P(() => {
    var I;
    return (I = p(n.strategy)) != null ? I : "absolute";
  }), l = P(() => {
    var I;
    return (I = p(n.transform)) != null ? I : !0;
  }), c = P(() => fh(t.value)), d = P(() => fh(e.value)), u = O(0), f = O(0), h = O(a.value), m = O(s.value), g = Xd({}), v = O(!1), y = P(() => {
    const I = {
      position: h.value,
      left: "0",
      top: "0"
    };
    if (!d.value)
      return I;
    const z = _v(d.value, u.value), N = _v(d.value, f.value);
    return l.value ? {
      ...I,
      transform: "translate(" + z + "px, " + N + "px)",
      ...Lx(d.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: h.value,
      left: z + "px",
      top: N + "px"
    };
  });
  let x;
  function C() {
    c.value == null || d.value == null || wI(c.value, d.value, {
      middleware: i.value,
      placement: s.value,
      strategy: a.value
    }).then((I) => {
      u.value = I.x, f.value = I.y, h.value = I.strategy, m.value = I.placement, g.value = I.middlewareData, v.value = !0;
    });
  }
  function b() {
    typeof x == "function" && (x(), x = void 0);
  }
  function S() {
    if (b(), o === void 0) {
      C();
      return;
    }
    if (c.value != null && d.value != null) {
      x = o(c.value, d.value, C);
      return;
    }
  }
  function A() {
    r.value || (v.value = !1);
  }
  return ce([i, s, a], C, {
    flush: "sync"
  }), ce([c, d], S, {
    flush: "sync"
  }), ce(r, A, {
    flush: "sync"
  }), om() && rm(b), {
    x: Li(u),
    y: Li(f),
    strategy: Li(h),
    placement: Li(m),
    middlewareData: Li(g),
    isPositioned: Li(v),
    floatingStyles: y,
    update: C
  };
}
function Ve(t, e) {
  const n = typeof t == "string" && !e ? `${t}Context` : e, o = Symbol(n);
  return [(r) => {
    const i = im(o, r);
    if (i || i === null)
      return i;
    throw new Error(
      `Injection \`${o.toString()}\` not found. Component must be used within ${Array.isArray(t) ? `one of the following components: ${t.join(
        ", "
      )}` : `\`${t}\``}`
    );
  }, (r) => (Ma(o, r), r)];
}
function Nx(t, e, n) {
  const o = n.originalEvent.target, r = new CustomEvent(t, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  e && o.addEventListener(t, e, { once: !0 }), o.dispatchEvent(r);
}
function ph(t, e = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(Math.max(t, e), n);
}
function SI(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
const _l = typeof document < "u";
function AI(t) {
  return t == null;
}
function EI(t, e) {
  var n;
  const o = Xd();
  return Pe(() => {
    o.value = t();
  }, {
    ...e,
    flush: (n = void 0) != null ? n : "sync"
  }), Cs(o);
}
function Ei(t) {
  return om() ? (rm(t), !0) : !1;
}
function _I() {
  const t = /* @__PURE__ */ new Set(), e = (n) => {
    t.delete(n);
  };
  return {
    on: (n) => {
      t.add(n);
      const o = () => e(n);
      return Ei(o), {
        off: o
      };
    },
    off: e,
    trigger: (...n) => Promise.all(Array.from(t).map((o) => o(...n)))
  };
}
function MI(t) {
  let e = !1, n;
  const o = nm(!0);
  return (...r) => (e || (n = o.run(() => t(...r)), e = !0), n);
}
function TI(t) {
  let e = 0, n, o;
  const r = () => {
    e -= 1, o && e <= 0 && (o.stop(), n = void 0, o = void 0);
  };
  return (...i) => (e += 1, n || (o = nm(!0), n = o.run(() => t(...i))), Ei(r), n);
}
function eo(t) {
  return typeof t == "function" ? t() : p(t);
}
const po = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const OI = (t) => typeof t < "u", II = Object.prototype.toString, DI = (t) => II.call(t) === "[object Object]", dd = () => {
}, Mv = /* @__PURE__ */ RI();
function RI() {
  var t, e;
  return po && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function PI(t, e) {
  function n(...o) {
    return new Promise((r, i) => {
      Promise.resolve(t(() => e.apply(this, o), { fn: e, thisArg: this, args: o })).then(r).catch(i);
    });
  }
  return n;
}
function LI(t, e = {}) {
  let n, o, r = dd;
  const i = (s) => {
    clearTimeout(s), r(), r = dd;
  };
  return (s) => {
    const a = eo(t), l = eo(e.maxWait);
    return n && i(n), a <= 0 || l !== void 0 && l <= 0 ? (o && (i(o), o = null), Promise.resolve(s())) : new Promise((c, d) => {
      r = e.rejectOnCancel ? d : c, l && !o && (o = setTimeout(() => {
        n && i(n), o = null, c(s());
      }, l)), n = setTimeout(() => {
        o && i(o), o = null, c(s());
      }, a);
    });
  };
}
function NI(t) {
  return In();
}
function Bx(t, e = 1e4) {
  return tm((n, o) => {
    let r = eo(t), i;
    const s = () => setTimeout(() => {
      r = eo(t), o();
    }, eo(e));
    return Ei(() => {
      clearTimeout(i);
    }), {
      get() {
        return n(), r;
      },
      set(a) {
        r = a, o(), clearTimeout(i), i = s();
      }
    };
  });
}
function $x(t, e = 200, n = {}) {
  return PI(
    LI(e, n),
    t
  );
}
function BI(t, e) {
  NI() && jo(t, e);
}
function sg(t, e, n = {}) {
  const {
    immediate: o = !0
  } = n, r = O(!1);
  let i = null;
  function s() {
    i && (clearTimeout(i), i = null);
  }
  function a() {
    r.value = !1, s();
  }
  function l(...c) {
    s(), r.value = !0, i = setTimeout(() => {
      r.value = !1, i = null, t(...c);
    }, eo(e));
  }
  return o && (r.value = !0, po && l()), Ei(a), {
    isPending: Cs(r),
    start: l,
    stop: a
  };
}
function $I(t = 1e3, e = {}) {
  const {
    controls: n = !1,
    callback: o
  } = e, r = sg(
    o ?? dd,
    t,
    e
  ), i = P(() => !r.isPending.value);
  return n ? {
    ready: i,
    ...r
  } : i;
}
function zI(t, e, n) {
  const o = ce(t, (...r) => (qe(() => o()), e(...r)), n);
  return o;
}
function fn(t) {
  var e;
  const n = eo(t);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const Su = po ? window : void 0;
function ud(...t) {
  let e, n, o, r;
  if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, o, r] = t, e = Su) : [e, n, o, r] = t, !e)
    return dd;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const i = [], s = () => {
    i.forEach((d) => d()), i.length = 0;
  }, a = (d, u, f, h) => (d.addEventListener(u, f, h), () => d.removeEventListener(u, f, h)), l = ce(
    () => [fn(e), eo(r)],
    ([d, u]) => {
      if (s(), !d)
        return;
      const f = DI(u) ? { ...u } : u;
      i.push(
        ...n.flatMap((h) => o.map((m) => a(d, h, m, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    l(), s();
  };
  return Ei(c), c;
}
function FI(t) {
  return typeof t == "function" ? t : typeof t == "string" ? (e) => e.key === t : Array.isArray(t) ? (e) => t.includes(e.key) : () => !0;
}
function ag(...t) {
  let e, n, o = {};
  t.length === 3 ? (e = t[0], n = t[1], o = t[2]) : t.length === 2 ? typeof t[1] == "object" ? (e = !0, n = t[0], o = t[1]) : (e = t[0], n = t[1]) : (e = !0, n = t[0]);
  const {
    target: r = Su,
    eventName: i = "keydown",
    passive: s = !1,
    dedupe: a = !1
  } = o, l = FI(e);
  return ud(r, i, (c) => {
    c.repeat && eo(a) || l(c) && n(c);
  }, s);
}
function zx() {
  const t = O(!1), e = In();
  return e && _e(() => {
    t.value = !0;
  }, e), t;
}
function HI(t) {
  const e = zx();
  return P(() => (e.value, !!t()));
}
function Fx(t, e = {}) {
  const {
    immediate: n = !0,
    fpsLimit: o = void 0,
    window: r = Su
  } = e, i = O(!1), s = o ? 1e3 / o : null;
  let a = 0, l = null;
  function c(f) {
    if (!i.value || !r)
      return;
    a || (a = f);
    const h = f - a;
    if (s && h < s) {
      l = r.requestAnimationFrame(c);
      return;
    }
    a = f, t({ delta: h, timestamp: f }), l = r.requestAnimationFrame(c);
  }
  function d() {
    !i.value && r && (i.value = !0, a = 0, l = r.requestAnimationFrame(c));
  }
  function u() {
    i.value = !1, l != null && r && (r.cancelAnimationFrame(l), l = null);
  }
  return n && d(), Ei(u), {
    isActive: Cs(i),
    pause: u,
    resume: d
  };
}
function VI(t) {
  return JSON.parse(JSON.stringify(t));
}
function ms(t, e, n = {}) {
  const { window: o = Su, ...r } = n;
  let i;
  const s = HI(() => o && "ResizeObserver" in o), a = () => {
    i && (i.disconnect(), i = void 0);
  }, l = P(() => Array.isArray(t) ? t.map((u) => fn(u)) : [fn(t)]), c = ce(
    l,
    (u) => {
      if (a(), s.value && o) {
        i = new ResizeObserver(e);
        for (const f of u)
          f && i.observe(f, r);
      }
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    a(), c();
  };
  return Ei(d), {
    isSupported: s,
    stop: d
  };
}
function Rt(t, e, n, o = {}) {
  var r, i, s;
  const {
    clone: a = !1,
    passive: l = !1,
    eventName: c,
    deep: d = !1,
    defaultValue: u,
    shouldEmit: f
  } = o, h = In(), m = n || (h == null ? void 0 : h.emit) || ((r = h == null ? void 0 : h.$emit) == null ? void 0 : r.bind(h)) || ((s = (i = h == null ? void 0 : h.proxy) == null ? void 0 : i.$emit) == null ? void 0 : s.bind(h == null ? void 0 : h.proxy));
  let g = c;
  e || (e = "modelValue"), g = g || `update:${e.toString()}`;
  const v = (C) => a ? typeof a == "function" ? a(C) : VI(C) : C, y = () => OI(t[e]) ? v(t[e]) : u, x = (C) => {
    f ? f(C) && m(g, C) : m(g, C);
  };
  if (l) {
    const C = y(), b = O(C);
    let S = !1;
    return ce(
      () => t[e],
      (A) => {
        S || (S = !0, b.value = v(A), qe(() => S = !1));
      }
    ), ce(
      b,
      (A) => {
        !S && (A !== t[e] || d) && x(A);
      },
      { deep: d }
    ), b;
  } else
    return P({
      get() {
        return y();
      },
      set(C) {
        x(C);
      }
    });
}
function Au(t) {
  return t ? t.flatMap((e) => e.type === ve ? Au(e.children) : [e]) : [];
}
const jI = ["INPUT", "TEXTAREA"];
function UI(t, e, n, o = {}) {
  if (!e || o.enableIgnoredElement && jI.includes(e.nodeName))
    return null;
  const {
    arrowKeyOptions: r = "both",
    attributeName: i = "[data-radix-vue-collection-item]",
    itemsArray: s = [],
    loop: a = !0,
    dir: l = "ltr",
    preventScroll: c = !0,
    focus: d = !1
  } = o, [u, f, h, m, g, v] = [
    t.key === "ArrowRight",
    t.key === "ArrowLeft",
    t.key === "ArrowUp",
    t.key === "ArrowDown",
    t.key === "Home",
    t.key === "End"
  ], y = h || m, x = u || f;
  if (!g && !v && (!y && !x || r === "vertical" && x || r === "horizontal" && y))
    return null;
  const C = n ? Array.from(n.querySelectorAll(i)) : s;
  if (!C.length)
    return null;
  c && t.preventDefault();
  let b = null;
  return x || y ? b = Hx(C, e, {
    goForward: y ? m : l === "ltr" ? u : f,
    loop: a
  }) : g ? b = C.at(0) || null : v && (b = C.at(-1) || null), d && (b == null || b.focus()), b;
}
function Hx(t, e, n, o = t.length) {
  if (--o === 0)
    return null;
  const r = t.indexOf(e), i = n.goForward ? r + 1 : r - 1;
  if (!n.loop && (i < 0 || i >= t.length))
    return null;
  const s = (i + t.length) % t.length, a = t[s];
  return a ? a.hasAttribute("disabled") && a.getAttribute("disabled") !== "false" ? Hx(
    t,
    a,
    n,
    o
  ) : a : null;
}
function Bf(t) {
  if (t === null || typeof t != "object")
    return !1;
  const e = Object.getPrototypeOf(t);
  return e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null || Symbol.iterator in t ? !1 : Symbol.toStringTag in t ? Object.prototype.toString.call(t) === "[object Module]" : !0;
}
function hh(t, e, n = ".", o) {
  if (!Bf(e))
    return hh(t, {}, n);
  const r = Object.assign({}, e);
  for (const i in t) {
    if (i === "__proto__" || i === "constructor")
      continue;
    const s = t[i];
    s != null && (Array.isArray(s) && Array.isArray(r[i]) ? r[i] = [...s, ...r[i]] : Bf(s) && Bf(r[i]) ? r[i] = hh(
      s,
      r[i],
      (n ? `${n}.` : "") + i.toString()
    ) : r[i] = s);
  }
  return r;
}
function WI(t) {
  return (...e) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    e.reduce((n, o) => hh(n, o, ""), {})
  );
}
const KI = WI(), [lg, rJ] = Ve("ConfigProvider");
let qI = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", GI = (t = 21) => {
  let e = "", n = t;
  for (; n--; )
    e += qI[Math.random() * 64 | 0];
  return e;
};
const JI = TI(() => {
  const t = O(/* @__PURE__ */ new Map()), e = O(), n = P(() => {
    for (const s of t.value.values())
      if (s)
        return !0;
    return !1;
  }), o = lg({
    scrollBody: O(!0)
  });
  let r = null;
  const i = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = e.value ?? "", Mv && (r == null || r()), e.value = void 0;
  };
  return ce(n, (s, a) => {
    var l;
    if (!po)
      return;
    if (!s) {
      a && i();
      return;
    }
    e.value === void 0 && (e.value = document.body.style.overflow);
    const c = window.innerWidth - document.documentElement.clientWidth, d = { padding: c, margin: 0 }, u = (l = o.scrollBody) != null && l.value ? typeof o.scrollBody.value == "object" ? KI({
      padding: o.scrollBody.value.padding === !0 ? c : o.scrollBody.value.padding,
      margin: o.scrollBody.value.margin === !0 ? c : o.scrollBody.value.margin
    }, d) : d : { padding: 0, margin: 0 };
    c > 0 && (document.body.style.paddingRight = `${u.padding}px`, document.body.style.marginRight = `${u.margin}px`, document.body.style.setProperty("--scrollbar-width", `${c}px`), document.body.style.overflow = "hidden"), Mv && (r = ud(
      document,
      "touchmove",
      (f) => {
        var h;
        f.target === document.documentElement && (f.touches.length > 1 || (h = f.preventDefault) == null || h.call(f));
      },
      { passive: !1 }
    )), qe(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, { immediate: !0, flush: "sync" }), t;
});
function Eu(t) {
  const e = GI(6), n = JI();
  n.value.set(e, t ?? !1);
  const o = P({
    get: () => n.value.get(e) ?? !1,
    set: (r) => n.value.set(e, r)
  });
  return BI(() => {
    n.value.delete(e);
  }), o;
}
const YI = "data-radix-vue-collection-item";
function ho(t, e = YI) {
  const n = t ?? Symbol();
  return { createCollection: (o) => {
    const r = O([]);
    function i() {
      const s = fn(o);
      return s ? r.value = Array.from(
        s.querySelectorAll(`[${e}]:not([data-disabled])`)
      ) : r.value = [];
    }
    return n8(() => {
      r.value = [];
    }), _e(i), o8(i), ce(() => o == null ? void 0 : o.value, i, { immediate: !0 }), Ma(n, r), r;
  }, injectCollection: () => im(n, O([])) };
}
function qo(t) {
  const e = lg({
    dir: O("ltr")
  });
  return P(() => {
    var n;
    return (t == null ? void 0 : t.value) || ((n = e.dir) == null ? void 0 : n.value) || "ltr";
  });
}
function Vr(t) {
  const e = In(), n = e == null ? void 0 : e.type.emits, o = {};
  return n != null && n.length || console.warn(
    `No emitted event found. Please check component: ${e == null ? void 0 : e.type.__name}`
  ), n == null || n.forEach((r) => {
    o[t8(Mb(r))] = (...i) => t(r, ...i);
  }), o;
}
let $f = 0;
function cg() {
  Pe((t) => {
    if (!po)
      return;
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      e[0] ?? Tv()
    ), document.body.insertAdjacentElement(
      "beforeend",
      e[1] ?? Tv()
    ), $f++, t(() => {
      $f === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((n) => n.remove()), $f--;
    });
  });
}
function Tv() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", t;
}
function Vx(t) {
  return P(() => {
    var e;
    return eo(t) ? !!((e = fn(t)) != null && e.closest("form")) : !0;
  });
}
function _t(t) {
  const e = In(), n = Object.keys((e == null ? void 0 : e.type.props) ?? {}).reduce((r, i) => {
    const s = (e == null ? void 0 : e.type.props[i]).default;
    return s !== void 0 && (r[i] = s), r;
  }, {}), o = _b(t);
  return P(() => {
    const r = {}, i = (e == null ? void 0 : e.vnode.props) ?? {};
    return Object.keys(i).forEach((s) => {
      r[Mb(s)] = i[s];
    }), Object.keys({ ...n, ...r }).reduce((s, a) => (o.value[a] !== void 0 && (s[a] = o.value[a]), s), {});
  });
}
function De(t, e) {
  const n = _t(t), o = e ? Vr(e) : {};
  return P(() => ({
    ...n.value,
    ...o
  }));
}
function X() {
  const t = In(), e = O(), n = P(() => {
    var s, a;
    return ["#text", "#comment"].includes((s = e.value) == null ? void 0 : s.$el.nodeName) ? (a = e.value) == null ? void 0 : a.$el.nextElementSibling : fn(e);
  }), o = Object.assign({}, t.exposed), r = {};
  for (const s in t.props)
    Object.defineProperty(r, s, {
      enumerable: !0,
      configurable: !0,
      get: () => t.props[s]
    });
  if (Object.keys(o).length > 0)
    for (const s in o)
      Object.defineProperty(r, s, {
        enumerable: !0,
        configurable: !0,
        get: () => o[s]
      });
  Object.defineProperty(r, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => t.vnode.el
  }), t.exposed = r;
  function i(s) {
    e.value = s, !(s instanceof Element || !s) && (Object.defineProperty(r, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => s.$el
    }), t.exposed = r);
  }
  return { forwardRef: i, currentRef: e, currentElement: n };
}
function XI(t, e) {
  const n = Bx(!1, 300), o = O(null), r = _I();
  function i() {
    o.value = null, n.value = !1;
  }
  function s(a, l) {
    const c = a.currentTarget, d = { x: a.clientX, y: a.clientY }, u = ZI(d, c.getBoundingClientRect()), f = QI(d, u), h = eD(l.getBoundingClientRect()), m = nD([...f, ...h]);
    o.value = m, n.value = !0;
  }
  return Pe((a) => {
    if (t.value && e.value) {
      const l = (d) => s(d, e.value), c = (d) => s(d, t.value);
      t.value.addEventListener("pointerleave", l), e.value.addEventListener("pointerleave", c), a(() => {
        var d, u;
        (d = t.value) == null || d.removeEventListener("pointerleave", l), (u = e.value) == null || u.removeEventListener("pointerleave", c);
      });
    }
  }), Pe((a) => {
    if (o.value) {
      const l = (c) => {
        var d, u;
        if (!o.value)
          return;
        const f = c.target, h = { x: c.clientX, y: c.clientY }, m = ((d = t.value) == null ? void 0 : d.contains(f)) || ((u = e.value) == null ? void 0 : u.contains(f)), g = !tD(h, o.value);
        m ? i() : g && (i(), r.trigger());
      };
      document.addEventListener("pointermove", l), a(() => document.removeEventListener("pointermove", l));
    }
  }), {
    isPointerInTransit: n,
    onPointerExit: r.on
  };
}
function ZI(t, e) {
  const n = Math.abs(e.top - t.y), o = Math.abs(e.bottom - t.y), r = Math.abs(e.right - t.x), i = Math.abs(e.left - t.x);
  switch (Math.min(n, o, r, i)) {
    case i:
      return "left";
    case r:
      return "right";
    case n:
      return "top";
    case o:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function QI(t, e, n = 5) {
  const o = [];
  switch (e) {
    case "top":
      o.push(
        { x: t.x - n, y: t.y + n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "bottom":
      o.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x + n, y: t.y - n }
      );
      break;
    case "left":
      o.push(
        { x: t.x + n, y: t.y - n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "right":
      o.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x - n, y: t.y + n }
      );
      break;
  }
  return o;
}
function eD(t) {
  const { top: e, right: n, bottom: o, left: r } = t;
  return [
    { x: r, y: e },
    { x: n, y: e },
    { x: n, y: o },
    { x: r, y: o }
  ];
}
function tD(t, e) {
  const { x: n, y: o } = t;
  let r = !1;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const a = e[i].x, l = e[i].y, c = e[s].x, d = e[s].y;
    l > o != d > o && n < (c - a) * (o - l) / (d - l) + a && (r = !r);
  }
  return r;
}
function nD(t) {
  const e = t.slice();
  return e.sort((n, o) => n.x < o.x ? -1 : n.x > o.x ? 1 : n.y < o.y ? -1 : n.y > o.y ? 1 : 0), oD(e);
}
function oD(t) {
  if (t.length <= 1)
    return t.slice();
  const e = [];
  for (let o = 0; o < t.length; o++) {
    const r = t[o];
    for (; e.length >= 2; ) {
      const i = e[e.length - 1], s = e[e.length - 2];
      if ((i.x - s.x) * (r.y - s.y) >= (i.y - s.y) * (r.x - s.x))
        e.pop();
      else
        break;
    }
    e.push(r);
  }
  e.pop();
  const n = [];
  for (let o = t.length - 1; o >= 0; o--) {
    const r = t[o];
    for (; n.length >= 2; ) {
      const i = n[n.length - 1], s = n[n.length - 2];
      if ((i.x - s.x) * (r.y - s.y) >= (i.y - s.y) * (r.x - s.x))
        n.pop();
      else
        break;
    }
    n.push(r);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
var rD = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, Fi = /* @__PURE__ */ new WeakMap(), ec = /* @__PURE__ */ new WeakMap(), tc = {}, zf = 0, jx = function(t) {
  return t && (t.host || jx(t.parentNode));
}, iD = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var o = jx(n);
    return o && t.contains(o) ? o : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, sD = function(t, e, n, o) {
  var r = iD(e, Array.isArray(t) ? t : [t]);
  tc[n] || (tc[n] = /* @__PURE__ */ new WeakMap());
  var i = tc[n], s = [], a = /* @__PURE__ */ new Set(), l = new Set(r), c = function(u) {
    !u || a.has(u) || (a.add(u), c(u.parentNode));
  };
  r.forEach(c);
  var d = function(u) {
    !u || l.has(u) || Array.prototype.forEach.call(u.children, function(f) {
      if (a.has(f))
        d(f);
      else {
        var h = f.getAttribute(o), m = h !== null && h !== "false", g = (Fi.get(f) || 0) + 1, v = (i.get(f) || 0) + 1;
        Fi.set(f, g), i.set(f, v), s.push(f), g === 1 && m && ec.set(f, !0), v === 1 && f.setAttribute(n, "true"), m || f.setAttribute(o, "true");
      }
    });
  };
  return d(e), a.clear(), zf++, function() {
    s.forEach(function(u) {
      var f = Fi.get(u) - 1, h = i.get(u) - 1;
      Fi.set(u, f), i.set(u, h), f || (ec.has(u) || u.removeAttribute(o), ec.delete(u)), h || u.removeAttribute(n);
    }), zf--, zf || (Fi = /* @__PURE__ */ new WeakMap(), Fi = /* @__PURE__ */ new WeakMap(), ec = /* @__PURE__ */ new WeakMap(), tc = {});
  };
}, aD = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var o = Array.from(Array.isArray(t) ? t : [t]), r = rD(t);
  return r ? (o.push.apply(o, Array.from(r.querySelectorAll("[aria-live]"))), sD(o, r, n, "aria-hidden")) : function() {
    return null;
  };
};
function _u(t) {
  let e;
  ce(() => fn(t), (n) => {
    n ? e = aD(n) : e && e();
  }), en(() => {
    e && e();
  });
}
let lD = 0;
function At(t, e = "radix") {
  if (t)
    return t;
  const { useId: n } = lg({ useId: void 0 });
  return n && typeof n == "function" ? `${e}-${n()}` : `${e}-${++lD}`;
}
function cD(t) {
  const e = O(), n = P(() => {
    var r;
    return ((r = e.value) == null ? void 0 : r.width) ?? 0;
  }), o = P(() => {
    var r;
    return ((r = e.value) == null ? void 0 : r.height) ?? 0;
  });
  return _e(() => {
    const r = fn(t);
    if (r) {
      e.value = { width: r.offsetWidth, height: r.offsetHeight };
      const i = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length)
          return;
        const a = s[0];
        let l, c;
        if ("borderBoxSize" in a) {
          const d = a.borderBoxSize, u = Array.isArray(d) ? d[0] : d;
          l = u.inlineSize, c = u.blockSize;
        } else
          l = r.offsetWidth, c = r.offsetHeight;
        e.value = { width: l, height: c };
      });
      return i.observe(r, { box: "border-box" }), () => i.unobserve(r);
    } else
      e.value = void 0;
  }), {
    width: n,
    height: o
  };
}
function Ux(t, e) {
  const n = O(t);
  function o(r) {
    return e[n.value][r] ?? n.value;
  }
  return {
    state: n,
    dispatch: (r) => {
      n.value = o(r);
    }
  };
}
function dg(t) {
  const e = Bx("", 1e3);
  return {
    search: e,
    handleTypeaheadSearch: (n, o) => {
      var r, i;
      if (!(t != null && t.value) && !o)
        return;
      e.value = e.value + n;
      const s = (t == null ? void 0 : t.value) ?? o, a = document.activeElement, l = ((i = (r = s.find((f) => f === a)) == null ? void 0 : r.textContent) == null ? void 0 : i.trim()) ?? "", c = s.map((f) => {
        var h;
        return ((h = f.textContent) == null ? void 0 : h.trim()) ?? "";
      }), d = dD(c, e.value, l), u = s.find(
        (f) => {
          var h;
          return ((h = f.textContent) == null ? void 0 : h.trim()) === d;
        }
      );
      return u && u.focus(), u;
    },
    resetTypeahead: () => {
      e.value = "";
    }
  };
}
function Wx(t, e) {
  return t.map((n, o) => t[(e + o) % t.length]);
}
function dD(t, e, n) {
  const o = e.length > 1 && Array.from(e).every((a) => a === e[0]) ? e[0] : e, r = n ? t.indexOf(n) : -1;
  let i = Wx(t, Math.max(r, 0));
  o.length === 1 && (i = i.filter((a) => a !== n));
  const s = i.find(
    (a) => a.toLowerCase().startsWith(o.toLowerCase())
  );
  return s !== n ? s : void 0;
}
const ug = T({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(t, { attrs: e, slots: n }) {
    return () => {
      var o, r;
      if (!n.default)
        return null;
      const i = Au(n.default()), s = i.findIndex((d) => d.type !== Z6);
      if (s === -1)
        return i;
      const a = i[s];
      (o = a.props) == null || delete o.ref;
      const l = a.props ? j(e, a.props) : e;
      e.class && (r = a.props) != null && r.class && delete a.props.class;
      const c = Q6(a, l);
      for (const d in l)
        d.startsWith("on") && (c.props || (c.props = {}), c.props[d] = l[d]);
      return i.length === 1 ? c : (i[s] = c, i);
    };
  }
}), se = T({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(t, { attrs: e, slots: n }) {
    const o = t.asChild ? "template" : t.as;
    return typeof o == "string" && ["area", "img", "input"].includes(o) ? () => jt(o, e) : o !== "template" ? () => jt(t.as, e, { default: n.default }) : () => jt(ug, e, { default: n.default });
  }
});
function Kx() {
  const t = O(), e = P(() => {
    var n, o;
    return ["#text", "#comment"].includes((n = t.value) == null ? void 0 : n.$el.nodeName) ? (o = t.value) == null ? void 0 : o.$el.nextElementSibling : fn(t);
  });
  return {
    primitiveElement: t,
    currentElement: e
  };
}
function uD(t, e) {
  const n = O({}), o = O("none"), r = t.value ? "mounted" : "unmounted", { state: i, dispatch: s } = Ux(r, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  }), a = (f) => {
    var h;
    if (po) {
      const m = new CustomEvent(f, { bubbles: !1, cancelable: !1 });
      (h = e.value) == null || h.dispatchEvent(m);
    }
  };
  ce(
    t,
    async (f, h) => {
      var m;
      const g = h !== f;
      if (await qe(), g) {
        const v = o.value, y = nc(e.value);
        f ? (s("MOUNT"), a("enter"), y === "none" && a("after-enter")) : y === "none" || ((m = n.value) == null ? void 0 : m.display) === "none" ? (s("UNMOUNT"), a("leave"), a("after-leave")) : h && v !== y ? (s("ANIMATION_OUT"), a("leave")) : (s("UNMOUNT"), a("after-leave"));
      }
    },
    { immediate: !0 }
  );
  const l = (f) => {
    const h = nc(e.value), m = h.includes(
      f.animationName
    ), g = i.value === "mounted" ? "enter" : "leave";
    f.target === e.value && m && (a(`after-${g}`), s("ANIMATION_END")), f.target === e.value && h === "none" && s("ANIMATION_END");
  }, c = (f) => {
    f.target === e.value && (o.value = nc(e.value));
  }, d = ce(
    e,
    (f, h) => {
      f ? (n.value = getComputedStyle(f), f.addEventListener("animationstart", c), f.addEventListener("animationcancel", l), f.addEventListener("animationend", l)) : (s("ANIMATION_END"), h == null || h.removeEventListener("animationstart", c), h == null || h.removeEventListener("animationcancel", l), h == null || h.removeEventListener("animationend", l));
    },
    { immediate: !0 }
  ), u = ce(i, () => {
    const f = nc(e.value);
    o.value = i.value === "mounted" ? f : "none";
  });
  return en(() => {
    d(), u();
  }), {
    isPresent: P(
      () => ["mounted", "unmountSuspended"].includes(i.value)
    )
  };
}
function nc(t) {
  return t && getComputedStyle(t).animationName || "none";
}
const hn = T({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(t, { slots: e, expose: n }) {
    var o;
    const { present: r, forceMount: i } = mt(t), s = O(), { isPresent: a } = uD(r, s);
    n({ present: a });
    let l = e.default({ present: a });
    l = Au(l || []);
    const c = In();
    if (l && (l == null ? void 0 : l.length) > 1) {
      const d = (o = c == null ? void 0 : c.parent) != null && o.type.name ? `<${c.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${d}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((u) => `  - ${u}`).join(`
`)
        ].join(`
`)
      );
    }
    return () => i.value || r.value || a.value ? jt(e.default({ present: a })[0], {
      ref: (d) => {
        const u = fn(d);
        return typeof (u == null ? void 0 : u.hasAttribute) > "u" || (u != null && u.hasAttribute("data-radix-popper-content-wrapper") ? s.value = u.firstElementChild : s.value = u), u;
      }
    }) : null;
  }
});
function qx({ type: t, defaultValue: e, modelValue: n }) {
  const o = n || e;
  if (!t && !n && !e)
    throw new Error("Either the `type` or the `value` or `default-value` prop must be defined.");
  if (n !== void 0 && e !== void 0 && typeof n != typeof e)
    throw new Error(
      `Invalid prop \`value\` of value \`${n}\` supplied, should be the same type as the \`defaultValue\` prop, which is \`${e}\`. The \`value\` prop must be:
  ${t === "single" ? "- a string" : t === "multiple" ? "- an array of strings" : `- a string
- an array of strings`}
  - \`undefined\``
    );
  const r = n !== void 0 || e !== void 0;
  if (t && r) {
    const i = Array.isArray(n) || Array.isArray(e), s = n !== void 0 ? "modelValue" : "defaultValue", a = s === "modelValue" ? typeof n : typeof e;
    if (t === "single" && i)
      return console.error(`Invalid prop \`${s}\` of type ${a} supplied with type \`single\`. The \`modelValue\` prop must be a string or \`undefined\`.
You can remove the \`type\` prop to let the component infer the type from the ${s} prop.`), "multiple";
    if (t === "multiple" && !i)
      return console.error(`Invalid prop \`${s}\` of type ${a} supplied with type \`multiple\`. The \`modelValue\` prop must be an array of strings or \`undefined\`.
    You can remove the \`type\` prop to let the component infer the type from the ${s} prop.`), "single";
  }
  return r ? Array.isArray(o) ? "multiple" : "single" : t;
}
function fD({ type: t, defaultValue: e, modelValue: n }) {
  return t || qx({ type: t, defaultValue: e, modelValue: n });
}
function pD({ type: t, defaultValue: e }) {
  return e !== void 0 ? e : t === "single" ? void 0 : [];
}
function hD(t, e) {
  const n = O(fD(t)), o = Rt(t, "modelValue", e, {
    defaultValue: pD(t),
    passive: t.modelValue === void 0
  });
  ce(
    () => [t.type, t.modelValue, t.defaultValue],
    () => {
      const s = qx(t);
      n.value !== s && (n.value = s);
    },
    { immediate: !0 }
  );
  function r(s) {
    if (n.value === "single")
      o.value = s === o.value ? void 0 : s;
    else {
      const a = o.value || [];
      if (a.includes(s)) {
        const l = a.findIndex((c) => c === s);
        a.splice(l, 1);
      } else
        a.push(s);
      o.value = a, e("update:modelValue", o.value);
    }
  }
  const i = P(() => n.value === "single");
  return {
    modelValue: o,
    type: n,
    changeModelValue: r,
    isSingle: i
  };
}
const [Go, mD] = Ve("DialogRoot"), gD = /* @__PURE__ */ T({
  __name: "DialogRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: !1 },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = Rt(n, "open", e, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), r = O(), i = O(), { modal: s } = mt(n);
    return mD({
      open: o,
      modal: s,
      openModal: () => {
        o.value = !0;
      },
      onOpenChange: (a) => {
        o.value = a;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: r,
      contentElement: i
    }), (a, l) => D(a.$slots, "default", { open: p(o) });
  }
}), Ml = /* @__PURE__ */ T({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = zx();
    return (n, o) => p(e) || n.forceMount ? (k(), _(gl, {
      key: 0,
      to: n.to,
      disabled: n.disabled
    }, [
      D(n.$slots, "default")
    ], 8, ["to", "disabled"])) : ae("", !0);
  }
}), vD = /* @__PURE__ */ T({
  __name: "DialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(Ml), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yD = "dismissableLayer.pointerDownOutside", bD = "dismissableLayer.focusOutside";
function Gx(t, e) {
  const n = e.closest(
    "[data-dismissable-layer]"
  ), o = t.querySelector(
    "[data-dismissable-layer]"
  ), r = Array.from(
    t.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  return !!(n && o === n || r.indexOf(o) < r.indexOf(n));
}
function wD(t, e) {
  var n;
  const o = ((n = e == null ? void 0 : e.value) == null ? void 0 : n.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), r = O(!1), i = O(() => {
  });
  return Pe((s) => {
    if (!po)
      return;
    const a = async (c) => {
      const d = c.target;
      if (e != null && e.value) {
        if (Gx(e.value, d)) {
          r.value = !1;
          return;
        }
        if (c.target && !r.value) {
          let u = function() {
            Nx(
              yD,
              t,
              f
            );
          };
          const f = { originalEvent: c };
          c.pointerType === "touch" ? (o.removeEventListener("click", i.value), i.value = u, o.addEventListener("click", i.value, {
            once: !0
          })) : u();
        } else
          o.removeEventListener("click", i.value);
        r.value = !1;
      }
    }, l = window.setTimeout(() => {
      o.addEventListener("pointerdown", a);
    }, 0);
    s(() => {
      window.clearTimeout(l), o.removeEventListener("pointerdown", a), o.removeEventListener("click", i.value);
    });
  }), {
    onPointerDownCapture: () => r.value = !0
  };
}
function xD(t, e) {
  var n;
  const o = ((n = e == null ? void 0 : e.value) == null ? void 0 : n.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), r = O(!1);
  return Pe((i) => {
    if (!po)
      return;
    const s = async (a) => {
      e != null && e.value && (await qe(), !(!e.value || Gx(e.value, a.target)) && a.target && !r.value && Nx(
        bD,
        t,
        { originalEvent: a }
      ));
    };
    o.addEventListener("focusin", s), i(() => o.removeEventListener("focusin", s));
  }), {
    onFocusCapture: () => r.value = !0,
    onBlurCapture: () => r.value = !1
  };
}
const Nn = zn({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Tl = /* @__PURE__ */ T({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = X(), s = P(
      () => {
        var m;
        return ((m = i.value) == null ? void 0 : m.ownerDocument) ?? globalThis.document;
      }
    ), a = P(() => Nn.layersRoot), l = P(() => i.value ? Array.from(a.value).indexOf(i.value) : -1), c = P(() => Nn.layersWithOutsidePointerEventsDisabled.size > 0), d = P(() => {
      const m = Array.from(a.value), [g] = [...Nn.layersWithOutsidePointerEventsDisabled].slice(-1), v = m.indexOf(g);
      return l.value >= v;
    }), u = wD(async (m) => {
      const g = [...Nn.branches].some(
        (v) => v.contains(m.target)
      );
      !d.value || g || (o("pointerDownOutside", m), o("interactOutside", m), await qe(), m.defaultPrevented || o("dismiss"));
    }, i), f = xD((m) => {
      [...Nn.branches].some(
        (g) => g.contains(m.target)
      ) || (o("focusOutside", m), o("interactOutside", m), m.defaultPrevented || o("dismiss"));
    }, i);
    ag("Escape", (m) => {
      l.value === a.value.size - 1 && (o("escapeKeyDown", m), m.defaultPrevented || o("dismiss"));
    });
    let h;
    return Pe((m) => {
      i.value && (n.disableOutsidePointerEvents && (Nn.layersWithOutsidePointerEventsDisabled.size === 0 && (h = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), Nn.layersWithOutsidePointerEventsDisabled.add(i.value)), a.value.add(i.value), m(() => {
        n.disableOutsidePointerEvents && Nn.layersWithOutsidePointerEventsDisabled.size === 1 && (s.value.body.style.pointerEvents = h);
      }));
    }), Pe((m) => {
      m(() => {
        i.value && (a.value.delete(i.value), Nn.layersWithOutsidePointerEventsDisabled.delete(i.value));
      });
    }), (m, g) => (k(), _(p(se), {
      ref: p(r),
      "as-child": m.asChild,
      as: m.as,
      "data-dismissable-layer": "",
      style: ct({
        pointerEvents: c.value ? d.value ? "auto" : "none" : void 0
      }),
      onFocusCapture: p(f).onFocusCapture,
      onBlurCapture: p(f).onBlurCapture,
      onPointerdownCapture: p(u).onPointerDownCapture
    }, {
      default: w(() => [
        D(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]));
  }
}), kD = /* @__PURE__ */ T({
  __name: "DismissableLayerBranch",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { forwardRef: n, currentElement: o } = X();
    return _e(() => {
      Nn.branches.add(o.value);
    }), en(() => {
      Nn.branches.delete(o.value);
    }), (r, i) => (k(), _(p(se), j({ ref: p(n) }, e), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ff = "focusScope.autoFocusOnMount", Hf = "focusScope.autoFocusOnUnmount", Ov = { bubbles: !1, cancelable: !0 };
function Oc(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const o of t)
    if (ir(o, { select: e }), document.activeElement !== n)
      return !0;
}
function CD(t) {
  const e = fg(t), n = Iv(e, t), o = Iv(e.reverse(), t);
  return [n, o];
}
function fg(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const r = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || r ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    e.push(n.currentNode);
  return e;
}
function Iv(t, e) {
  for (const n of t)
    if (!SD(n, { upTo: e }))
      return n;
}
function SD(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  for (; t; ) {
    if (e !== void 0 && t === e)
      return !1;
    if (getComputedStyle(t).display === "none")
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function AD(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function ir(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && AD(t) && e && t.select();
  }
}
const ED = MI(() => O([]));
function _D() {
  const t = ED();
  return {
    add(e) {
      const n = t.value[0];
      e !== n && (n == null || n.pause()), t.value = Dv(t.value, e), t.value.unshift(e);
    },
    remove(e) {
      var n;
      t.value = Dv(t.value, e), (n = t.value[0]) == null || n.resume();
    }
  };
}
function Dv(t, e) {
  const n = [...t], o = n.indexOf(e);
  return o !== -1 && n.splice(o, 1), n;
}
function MD(t) {
  return t.filter((e) => e.tagName !== "A");
}
const Mu = /* @__PURE__ */ T({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: !1 },
    trapped: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, { currentRef: r, currentElement: i } = X(), s = O(null), a = _D(), l = zn({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Pe((d) => {
      if (!po)
        return;
      const u = i.value;
      if (!n.trapped)
        return;
      function f(v) {
        if (l.paused || !u)
          return;
        const y = v.target;
        u.contains(y) ? s.value = y : ir(s.value, { select: !0 });
      }
      function h(v) {
        if (l.paused || !u)
          return;
        const y = v.relatedTarget;
        y !== null && (u.contains(y) || ir(s.value, { select: !0 }));
      }
      function m(v) {
        u.contains(s.value) || ir(u);
      }
      document.addEventListener("focusin", f), document.addEventListener("focusout", h);
      const g = new MutationObserver(m);
      u && g.observe(u, { childList: !0, subtree: !0 }), d(() => {
        document.removeEventListener("focusin", f), document.removeEventListener("focusout", h), g.disconnect();
      });
    }), Pe(async (d) => {
      const u = i.value;
      if (await qe(), !u)
        return;
      a.add(l);
      const f = document.activeElement;
      if (!u.contains(f)) {
        const h = new CustomEvent(Ff, Ov);
        u.addEventListener(Ff, (m) => o("mountAutoFocus", m)), u.dispatchEvent(h), h.defaultPrevented || (Oc(MD(fg(u)), {
          select: !0
        }), document.activeElement === f && ir(u));
      }
      d(() => {
        u.removeEventListener(Ff, (g) => o("mountAutoFocus", g));
        const h = new CustomEvent(Hf, Ov), m = (g) => {
          o("unmountAutoFocus", g);
        };
        u.addEventListener(Hf, m), u.dispatchEvent(h), setTimeout(() => {
          h.defaultPrevented || ir(f ?? document.body, { select: !0 }), u.removeEventListener(Hf, m), a.remove(l);
        }, 0);
      });
    });
    function c(d) {
      if (!n.loop && !n.trapped || l.paused)
        return;
      const u = d.key === "Tab" && !d.altKey && !d.ctrlKey && !d.metaKey, f = document.activeElement;
      if (u && f) {
        const h = d.currentTarget, [m, g] = CD(h);
        m && g ? !d.shiftKey && f === g ? (d.preventDefault(), n.loop && ir(m, { select: !0 })) : d.shiftKey && f === m && (d.preventDefault(), n.loop && ir(g, { select: !0 })) : f === h && d.preventDefault();
      }
    }
    return (d, u) => (k(), _(p(se), {
      ref_key: "currentRef",
      ref: r,
      tabindex: "-1",
      "as-child": d.asChild,
      as: d.as,
      onKeydown: c
    }, {
      default: w(() => [
        D(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), TD = "menu.itemSelect", mh = ["Enter", " "], OD = ["ArrowDown", "PageUp", "Home"], Jx = ["ArrowUp", "PageDown", "End"], ID = [...OD, ...Jx], DD = {
  ltr: [...mh, "ArrowRight"],
  rtl: [...mh, "ArrowLeft"]
}, RD = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function pg(t) {
  return t ? "open" : "closed";
}
function fd(t) {
  return t === "indeterminate";
}
function Yx(t) {
  return fd(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function gh(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e))
      return;
}
function PD(t, e) {
  const { x: n, y: o } = t;
  let r = !1;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const a = e[i].x, l = e[i].y, c = e[s].x, d = e[s].y;
    l > o != d > o && n < (c - a) * (o - l) / (d - l) + a && (r = !r);
  }
  return r;
}
function LD(t, e) {
  if (!e)
    return !1;
  const n = { x: t.clientX, y: t.clientY };
  return PD(n, e);
}
function Ja(t) {
  return t.pointerType === "mouse";
}
function ND() {
  const t = "DialogContent", e = "DialogTitle", n = Go(), o = `Warning: \`${t}\` requires a \`${e}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.radix-vue.com/components/dialog.html#title;`, r = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${t}.`;
  _e(() => {
    var i;
    document.getElementById(n.titleId) || console.warn(o);
    const s = (i = n.contentElement.value) == null ? void 0 : i.getAttribute("aria-describedby");
    n.descriptionId && s && (document.getElementById(n.descriptionId) || console.warn(r));
  });
}
const Xx = /* @__PURE__ */ T({
  __name: "DialogContentImpl",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Go(), { forwardRef: i, currentElement: s } = X();
    return r.titleId || (r.titleId = At(void 0, "radix-vue-dialog-title")), r.descriptionId || (r.descriptionId = At(void 0, "radix-vue-dialog-description")), _e(() => {
      r.contentElement = s, document.activeElement !== document.body && (r.triggerElement.value = document.activeElement);
    }), process.env.NODE_ENV !== "production" && ND(), (a, l) => (k(), _(p(Mu), {
      "as-child": "",
      loop: "",
      trapped: n.trapFocus,
      onMountAutoFocus: l[5] || (l[5] = (c) => o("openAutoFocus", c)),
      onUnmountAutoFocus: l[6] || (l[6] = (c) => o("closeAutoFocus", c))
    }, {
      default: w(() => [
        E(p(Tl), j({
          id: p(r).contentId,
          ref: p(i),
          as: a.as,
          "as-child": a.asChild,
          "disable-outside-pointer-events": a.disableOutsidePointerEvents,
          role: "dialog",
          "aria-describedby": p(r).descriptionId,
          "aria-labelledby": p(r).titleId,
          "data-state": p(pg)(p(r).open.value)
        }, a.$attrs, {
          onDismiss: l[0] || (l[0] = (c) => p(r).onOpenChange(!1)),
          onEscapeKeyDown: l[1] || (l[1] = (c) => o("escapeKeyDown", c)),
          onFocusOutside: l[2] || (l[2] = (c) => o("focusOutside", c)),
          onInteractOutside: l[3] || (l[3] = (c) => o("interactOutside", c)),
          onPointerDownOutside: l[4] || (l[4] = (c) => o("pointerDownOutside", c))
        }), {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), BD = /* @__PURE__ */ T({
  __name: "DialogContentModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Go(), i = Vr(o), { forwardRef: s, currentElement: a } = X();
    return _u(a), (l, c) => (k(), _(Xx, j({ ...n, ...p(i) }, {
      ref: p(s),
      "trap-focus": p(r).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: c[0] || (c[0] = (d) => {
        var u;
        o("closeAutoFocus", d), d.defaultPrevented || (d.preventDefault(), (u = p(r).triggerElement.value) == null || u.focus());
      }),
      onPointerDownOutside: c[1] || (c[1] = (d) => {
        const u = d.detail.originalEvent, f = u.button === 0 && u.ctrlKey === !0;
        (u.button === 2 || f) && d.preventDefault();
      }),
      onFocusOutside: c[2] || (c[2] = (d) => {
        d.preventDefault();
      }),
      onOpenAutoFocus: c[3] || (c[3] = (d) => o("openAutoFocus", d))
    }), {
      default: w(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), $D = /* @__PURE__ */ T({
  __name: "DialogContentNonModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Vr(o);
    X();
    const i = Go(), s = O(!1), a = O(!1);
    return (l, c) => (k(), _(Xx, j({ ...n, ...p(r) }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: c[0] || (c[0] = (d) => {
        var u;
        o("closeAutoFocus", d), d.defaultPrevented || (s.value || (u = p(i).triggerElement.value) == null || u.focus(), d.preventDefault()), s.value = !1, a.value = !1;
      }),
      onInteractOutside: c[1] || (c[1] = (d) => {
        var u;
        d.defaultPrevented || (s.value = !0, d.detail.originalEvent.type === "pointerdown" && (a.value = !0));
        const f = d.target;
        (u = p(i).triggerElement.value) != null && u.contains(f) && d.preventDefault(), d.detail.originalEvent.type === "focusin" && a.value && d.preventDefault();
      })
    }), {
      default: w(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zD = /* @__PURE__ */ T({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Go(), i = Vr(o), { forwardRef: s } = X();
    return (a, l) => (k(), _(p(hn), {
      present: a.forceMount || p(r).open.value
    }, {
      default: w(() => [
        p(r).modal.value ? (k(), _(BD, j({
          key: 0,
          ref: p(s)
        }, { ...n, ...p(i), ...a.$attrs }, {
          onOpenAutoFocus: l[0] || (l[0] = (c) => o("openAutoFocus", c))
        }), {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16)) : (k(), _($D, j({
          key: 1,
          ref: p(s)
        }, { ...n, ...p(i), ...a.$attrs }), {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), FD = /* @__PURE__ */ T({
  __name: "DialogOverlayImpl",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = Go();
    return Eu(!0), X(), (n, o) => (k(), _(p(se), {
      as: n.as,
      "as-child": n.asChild,
      "data-state": p(e).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state"]));
  }
}), HD = /* @__PURE__ */ T({
  __name: "DialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = Go(), { forwardRef: n } = X();
    return (o, r) => {
      var i;
      return (i = p(e)) != null && i.modal.value ? (k(), _(p(hn), {
        key: 0,
        present: o.forceMount || p(e).open.value
      }, {
        default: w(() => [
          E(FD, j(o.$attrs, {
            ref: p(n),
            as: o.as,
            "as-child": o.asChild
          }), {
            default: w(() => [
              D(o.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child"])
        ]),
        _: 3
      }, 8, ["present"])) : ae("", !0);
    };
  }
}), VD = /* @__PURE__ */ T({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t;
    X();
    const n = Go();
    return (o, r) => (k(), _(p(se), j(e, {
      type: o.as === "button" ? "button" : void 0,
      onClick: r[0] || (r[0] = (i) => p(n).onOpenChange(!1))
    }), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
}), jD = /* @__PURE__ */ T({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(t) {
    const e = t, n = Go();
    return X(), (o, r) => (k(), _(p(se), j(e, {
      id: p(n).titleId
    }), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
});
function pd(t) {
  return t === "indeterminate";
}
function Zx(t) {
  return pd(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
const UD = ["value", "checked", "name", "disabled", "required"], [WD, KD] = Ve("CheckboxRoot"), qD = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: [Boolean, String], default: void 0 },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    value: { default: "on" },
    id: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(t, { emit: e }) {
    const n = t, o = e, { disabled: r } = mt(n), i = Rt(n, "checked", o, {
      defaultValue: n.defaultChecked,
      passive: n.checked === void 0
    }), { forwardRef: s, currentElement: a } = X(), l = Vx(a), c = P(() => {
      var d;
      return n.id && a.value ? (d = document.querySelector(`[for="${n.id}"]`)) == null ? void 0 : d.innerText : void 0;
    });
    return KD({
      disabled: r,
      state: i
    }), (d, u) => (k(), U(ve, null, [
      E(p(se), j(d.$attrs, {
        id: d.id,
        ref: p(s),
        role: "checkbox",
        "as-child": n.asChild,
        as: d.as,
        type: d.as === "button" ? "button" : void 0,
        "aria-checked": p(pd)(p(i)) ? "mixed" : p(i),
        "aria-required": !1,
        "aria-label": d.$attrs["aria-label"] || c.value,
        "data-state": p(Zx)(p(i)),
        "data-disabled": p(r) ? "" : void 0,
        disabled: p(r),
        onKeydown: Sr(yt(() => {
        }, ["prevent"]), ["enter"]),
        onClick: u[0] || (u[0] = (f) => i.value = p(pd)(p(i)) ? !0 : !p(i))
      }), {
        default: w(() => [
          D(d.$slots, "default", { checked: p(i) })
        ]),
        _: 3
      }, 16, ["id", "as-child", "as", "type", "aria-checked", "aria-label", "data-state", "data-disabled", "disabled", "onKeydown"]),
      p(l) ? (k(), U("input", {
        key: 0,
        type: "checkbox",
        tabindex: "-1",
        "aria-hidden": "",
        value: d.value,
        checked: !!p(i),
        name: n.name,
        disabled: n.disabled,
        required: n.required,
        style: ct({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      }, null, 12, UD)) : ae("", !0)
    ], 64));
  }
}), GD = /* @__PURE__ */ T({
  __name: "CheckboxIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const { forwardRef: e } = X(), n = WD();
    return (o, r) => (k(), _(p(hn), {
      present: o.forceMount || p(pd)(p(n).state.value) || p(n).state.value === !0
    }, {
      default: w(() => [
        E(p(se), j({
          ref: p(e),
          "data-state": p(Zx)(p(n).state.value),
          "data-disabled": p(n).disabled.value ? "" : void 0,
          style: { pointerEvents: "none" },
          "as-child": o.asChild,
          as: o.as
        }, o.$attrs), {
          default: w(() => [
            D(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "data-disabled", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [Qx, JD] = Ve("PopperRoot"), Ol = /* @__PURE__ */ T({
  __name: "PopperRoot",
  setup(t) {
    const e = O();
    return JD({
      anchor: e,
      onAnchorChange: (n) => e.value = n
    }), (n, o) => D(n.$slots, "default");
  }
}), Tu = /* @__PURE__ */ T({
  __name: "PopperAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { forwardRef: n, currentElement: o } = X(), r = Qx();
    return ce(o, () => {
      r.onAnchorChange(e.element ?? o.value);
    }), (i, s) => (k(), _(p(se), {
      ref: p(n),
      as: i.as,
      "as-child": i.asChild
    }, {
      default: w(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function YD(t) {
  return t !== null;
}
function XD(t) {
  return {
    name: "transformOrigin",
    options: t,
    fn(e) {
      var n, o, r;
      const { placement: i, rects: s, middlewareData: a } = e, l = ((n = a.arrow) == null ? void 0 : n.centerOffset) !== 0, c = l ? 0 : t.arrowWidth, d = l ? 0 : t.arrowHeight, [u, f] = vh(i), h = { start: "0%", center: "50%", end: "100%" }[f], m = (((o = a.arrow) == null ? void 0 : o.x) ?? 0) + c / 2, g = (((r = a.arrow) == null ? void 0 : r.y) ?? 0) + d / 2;
      let v = "", y = "";
      return u === "bottom" ? (v = l ? h : `${m}px`, y = `${-d}px`) : u === "top" ? (v = l ? h : `${m}px`, y = `${s.floating.height + d}px`) : u === "right" ? (v = `${-d}px`, y = l ? h : `${g}px`) : u === "left" && (v = `${s.floating.width + d}px`, y = l ? h : `${g}px`), { data: { x: v, y } };
    }
  };
}
function vh(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
const e4 = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [iJ, ZD] = Ve("PopperContent"), Ou = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ Ob({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...e4
  }),
  emits: ["placed"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Qx(), { forwardRef: i, currentElement: s } = X(), a = O(), l = O(), { width: c, height: d } = cD(l), u = P(
      () => n.side + (n.align !== "center" ? `-${n.align}` : "")
    ), f = P(() => typeof n.collisionPadding == "number" ? n.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...n.collisionPadding }), h = P(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]), m = P(() => ({
      padding: f.value,
      boundary: h.value.filter(YD),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: h.value.length > 0
    })), g = EI(() => [
      hI({
        mainAxis: n.sideOffset + d.value,
        alignmentAxis: n.alignOffset
      }),
      n.prioritizePosition && n.avoidCollisions && Ev({
        ...m.value
      }),
      n.avoidCollisions && mI({
        mainAxis: !0,
        crossAxis: !!n.prioritizePosition,
        limiter: n.sticky === "partial" ? bI() : void 0,
        ...m.value
      }),
      !n.prioritizePosition && n.avoidCollisions && Ev({
        ...m.value
      }),
      gI({
        ...m.value,
        apply: ({ elements: M, rects: $, availableWidth: L, availableHeight: Y }) => {
          const { width: J, height: ne } = $.reference, F = M.floating.style;
          Object.assign(M.floating.style, {
            maxWidth: `${L}px`,
            maxHeight: `${Y}px`
          }), F.setProperty(
            "--radix-popper-available-width",
            `${L}px`
          ), F.setProperty(
            "--radix-popper-available-height",
            `${Y}px`
          ), F.setProperty(
            "--radix-popper-anchor-width",
            `${J}px`
          ), F.setProperty(
            "--radix-popper-anchor-height",
            `${ne}px`
          );
        }
      }),
      l.value && kI({ element: l.value, padding: n.arrowPadding }),
      XD({
        arrowWidth: c.value,
        arrowHeight: d.value
      }),
      n.hideWhenDetached && vI({ strategy: "referenceHidden", ...m.value })
    ]), { floatingStyles: v, placement: y, isPositioned: x, middlewareData: C } = CI(
      r.anchor,
      a,
      {
        strategy: "fixed",
        placement: u,
        whileElementsMounted: (...M) => pI(...M, {
          animationFrame: n.updatePositionStrategy === "always"
        }),
        middleware: g
      }
    ), b = P(
      () => vh(y.value)[0]
    ), S = P(
      () => vh(y.value)[1]
    );
    Pe(() => {
      x.value && o("placed");
    });
    const A = P(
      () => {
        var M;
        return ((M = C.value.arrow) == null ? void 0 : M.centerOffset) !== 0;
      }
    ), I = O("");
    Pe(() => {
      s.value && (I.value = window.getComputedStyle(s.value).zIndex);
    });
    const z = P(() => {
      var M;
      return ((M = C.value.arrow) == null ? void 0 : M.x) ?? 0;
    }), N = P(() => {
      var M;
      return ((M = C.value.arrow) == null ? void 0 : M.y) ?? 0;
    });
    return ZD({
      placedSide: b,
      onArrowChange: (M) => l.value = M,
      arrowX: z,
      arrowY: N,
      shouldHideArrow: A
    }), (M, $) => {
      var L, Y, J;
      return k(), U("div", {
        ref_key: "floatingRef",
        ref: a,
        "data-radix-popper-content-wrapper": "",
        style: ct({
          ...p(v),
          transform: p(x) ? p(v).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: I.value,
          "--radix-popper-transform-origin": [
            (L = p(C).transformOrigin) == null ? void 0 : L.x,
            (Y = p(C).transformOrigin) == null ? void 0 : Y.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((J = p(C).hide) == null ? void 0 : J.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [
        E(p(se), j({ ref: p(i) }, M.$attrs, {
          "as-child": n.asChild,
          as: M.as,
          "data-side": b.value,
          "data-align": S.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: p(x) ? void 0 : "none"
          }
        }), {
          default: w(() => [
            D(M.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
}), Iu = /* @__PURE__ */ T({
  __name: "VisuallyHidden",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    return X(), (e, n) => (k(), _(p(se), {
      as: e.as,
      "as-child": e.asChild,
      style: ct({
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: "1px",
        display: "inline-block",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      })
    }, {
      default: w(() => [
        D(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "style"]));
  }
}), [t4, sJ] = Ve("CollectionProvider");
T({
  name: "CollectionSlot",
  setup(t, { slots: e }) {
    const n = t4(), { primitiveElement: o, currentElement: r } = Kx();
    return ce(r, () => {
      n.collectionRef.value = r.value;
    }), () => jt(ug, { ref: o }, e);
  }
});
T({
  name: "CollectionItem",
  setup(t, { slots: e, attrs: n }) {
    const o = t4(), { primitiveElement: r, currentElement: i } = Kx(), s = In();
    return Pe((a) => {
      var l;
      if (i.value) {
        const c = Vc(i.value);
        o.itemMap.value.set(c, { ref: i.value, ...Vc(((l = s == null ? void 0 : s.parent) == null ? void 0 : l.props) ?? {}) }), a(() => o.itemMap.value.delete(c));
      }
    }), () => jt(ug, { ...n, [o.attrName]: "", ref: r }, e);
  }
});
const hg = /* @__PURE__ */ T({
  __name: "MenuAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(Tu), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [_i, n4] = Ve(["MenuRoot", "MenuSub"], "MenuContext"), [Il, QD] = Ve("MenuRoot"), o4 = /* @__PURE__ */ T({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: !1 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, { modal: r, dir: i } = mt(n), s = qo(i), a = Rt(n, "open", o), l = O(), c = O(!1);
    return Pe((d) => {
      if (!po)
        return;
      const u = () => {
        c.value = !0, document.addEventListener("pointerdown", f, {
          capture: !0,
          once: !0
        }), document.addEventListener("pointermove", f, {
          capture: !0,
          once: !0
        });
      }, f = () => c.value = !1;
      document.addEventListener("keydown", u, { capture: !0 }), d(() => {
        document.removeEventListener("keydown", u, { capture: !0 }), document.removeEventListener("pointerdown", f, {
          capture: !0
        }), document.removeEventListener("pointermove", f, {
          capture: !0
        });
      });
    }), n4({
      open: a,
      onOpenChange: (d) => {
        a.value = d;
      },
      content: l,
      onContentChange: (d) => {
        l.value = d;
      }
    }), QD({
      onClose: () => {
        a.value = !1;
      },
      isUsingKeyboardRef: c,
      dir: s,
      modal: r
    }), (d, u) => (k(), _(p(Ol), null, {
      default: w(() => [
        D(d.$slots, "default")
      ]),
      _: 3
    }));
  }
}), eR = "rovingFocusGroup.onEntryFocus", tR = { bubbles: !1, cancelable: !0 }, nR = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function oR(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function rR(t, e, n) {
  const o = oR(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(o)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(o)))
    return nR[o];
}
function r4(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e))
      return;
}
function iR(t, e) {
  return t.map((n, o) => t[(e + o) % t.length]);
}
const [sR, aR] = Ve("RovingFocusGroup"), Du = /* @__PURE__ */ T({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: !1 },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(t, { emit: e }) {
    const n = t, o = e, { loop: r, orientation: i, dir: s } = mt(n), a = qo(s), l = Rt(n, "currentTabStopId", o, {
      defaultValue: n.defaultCurrentTabStopId,
      passive: n.currentTabStopId === void 0
    }), c = O(!1), d = O(!1), u = O(0), { forwardRef: f, currentElement: h } = X(), { createCollection: m } = ho("rovingFocus"), g = m(h);
    function v(y) {
      const x = !d.value;
      if (y.currentTarget && y.target === y.currentTarget && x && !c.value) {
        const C = new CustomEvent(eR, tR);
        if (y.currentTarget.dispatchEvent(C), o("entryFocus", C), !C.defaultPrevented) {
          const b = g.value, S = b.find((z) => z.getAttribute("data-active") === "true"), A = b.find(
            (z) => z.id === l.value
          ), I = [S, A, ...b].filter(
            Boolean
          );
          r4(I);
        }
      }
      d.value = !1;
    }
    return aR({
      loop: r,
      dir: a,
      orientation: i,
      currentTabStopId: l,
      onItemFocus: (y) => {
        l.value = y;
      },
      onItemShiftTab: () => {
        c.value = !0;
      },
      onFocusableItemAdd: () => {
        u.value++;
      },
      onFocusableItemRemove: () => {
        u.value--;
      }
    }), (y, x) => (k(), _(p(se), {
      ref: p(f),
      tabindex: c.value || u.value === 0 ? -1 : 0,
      "data-orientation": p(i),
      as: y.as,
      "as-child": y.asChild,
      dir: p(a),
      style: { outline: "none" },
      onMousedown: x[0] || (x[0] = (C) => d.value = !0),
      onFocus: v,
      onBlur: x[1] || (x[1] = (C) => c.value = !1)
    }, {
      default: w(() => [
        D(y.$slots, "default")
      ]),
      _: 3
    }, 8, ["tabindex", "data-orientation", "as", "as-child", "dir"]));
  }
}), mg = /* @__PURE__ */ T({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: !0 },
    active: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const e = t, n = sR(), o = P(() => e.tabStopId || At()), r = P(
      () => n.currentTabStopId.value === o.value
    ), { injectCollection: i } = ho("rovingFocus"), s = i();
    _e(() => {
      e.focusable && n.onFocusableItemAdd();
    }), en(() => {
      e.focusable && n.onFocusableItemRemove();
    });
    function a(l) {
      if (l.key === "Tab" && l.shiftKey) {
        n.onItemShiftTab();
        return;
      }
      if (l.target !== l.currentTarget)
        return;
      const c = rR(
        l,
        n.orientation.value,
        n.dir.value
      );
      if (c !== void 0) {
        if (l.metaKey || l.ctrlKey || l.altKey || l.shiftKey)
          return;
        l.preventDefault();
        let d = [...s.value];
        if (c === "last")
          d.reverse();
        else if (c === "prev" || c === "next") {
          c === "prev" && d.reverse();
          const u = d.indexOf(
            l.currentTarget
          );
          d = n.loop.value ? iR(d, u + 1) : d.slice(u + 1);
        }
        qe(() => r4(d));
      }
    }
    return (l, c) => (k(), _(p(se), {
      "data-radix-vue-collection-item": "",
      tabindex: r.value ? 0 : -1,
      "data-orientation": p(n).orientation.value,
      "data-active": l.active,
      "data-disabled": !l.focusable || void 0,
      as: l.as,
      "as-child": l.asChild,
      onMousedown: c[0] || (c[0] = (d) => {
        l.focusable ? p(n).onItemFocus(o.value) : d.preventDefault();
      }),
      onFocus: c[1] || (c[1] = (d) => p(n).onItemFocus(o.value)),
      onKeydown: a
    }, {
      default: w(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"]));
  }
}), [gg, lR] = Ve("MenuContent"), vg = /* @__PURE__ */ T({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ Ob({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...e4
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus", "dismiss"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = _i(), i = Il(), { trapFocus: s, disableOutsidePointerEvents: a, loop: l } = mt(n);
    cg(), Eu(a.value);
    const c = O(""), d = O(0), u = O(0), f = O(null), h = O("right"), m = O(0), g = O(null), { createCollection: v } = ho(), { forwardRef: y, currentElement: x } = X(), C = v(x);
    ce(x, (M) => {
      r.onContentChange(M);
    });
    const { handleTypeaheadSearch: b } = dg(C);
    en(() => {
      window.clearTimeout(d.value);
    });
    function S(M) {
      var $, L;
      return h.value === (($ = f.value) == null ? void 0 : $.side) && LD(M, (L = f.value) == null ? void 0 : L.area);
    }
    async function A(M) {
      var $;
      o("openAutoFocus", M), !M.defaultPrevented && (M.preventDefault(), ($ = x.value) == null || $.focus());
    }
    function I(M) {
      if (M.defaultPrevented)
        return;
      const $ = M.target.closest("[data-radix-menu-content]") === M.currentTarget, L = M.ctrlKey || M.altKey || M.metaKey, Y = M.key.length === 1, J = UI(
        M,
        document.activeElement,
        x.value,
        {
          loop: l.value,
          arrowKeyOptions: "vertical",
          dir: i == null ? void 0 : i.dir.value,
          focus: !0,
          attributeName: "[data-radix-vue-collection-item]:not([data-disabled])"
        }
      );
      if (J)
        return J == null ? void 0 : J.focus();
      if (M.code === "Space" || ($ && (M.key === "Tab" && M.preventDefault(), !L && Y && b(M.key)), M.target !== x.value) || !ID.includes(M.key))
        return;
      M.preventDefault();
      const ne = C.value;
      Jx.includes(M.key) && ne.reverse(), gh(ne);
    }
    function z(M) {
      var $, L;
      (L = ($ = M == null ? void 0 : M.currentTarget) == null ? void 0 : $.contains) != null && L.call($, M.target) || (window.clearTimeout(d.value), c.value = "");
    }
    function N(M) {
      var $;
      if (!Ja(M))
        return;
      const L = M.target, Y = m.value !== M.clientX;
      if (($ = M == null ? void 0 : M.currentTarget) != null && $.contains(L) && Y) {
        const J = M.clientX > m.value ? "right" : "left";
        h.value = J, m.value = M.clientX;
      }
    }
    return lR({
      onItemEnter: (M) => !!S(M),
      onItemLeave: (M) => {
        var $;
        S(M) || (($ = x.value) == null || $.focus(), g.value = null);
      },
      onTriggerLeave: (M) => !!S(M),
      searchRef: c,
      pointerGraceTimerRef: u,
      onPointerGraceIntentChange: (M) => {
        f.value = M;
      }
    }), (M, $) => (k(), _(p(Mu), {
      "as-child": "",
      trapped: p(s),
      onMountAutoFocus: A,
      onUnmountAutoFocus: $[7] || ($[7] = (L) => o("closeAutoFocus", L))
    }, {
      default: w(() => [
        E(p(Tl), {
          "as-child": "",
          "disable-outside-pointer-events": p(a),
          onEscapeKeyDown: $[2] || ($[2] = (L) => o("escapeKeyDown", L)),
          onPointerDownOutside: $[3] || ($[3] = (L) => o("pointerDownOutside", L)),
          onFocusOutside: $[4] || ($[4] = (L) => o("focusOutside", L)),
          onInteractOutside: $[5] || ($[5] = (L) => o("interactOutside", L)),
          onDismiss: $[6] || ($[6] = (L) => o("dismiss"))
        }, {
          default: w(() => [
            E(p(Du), {
              "current-tab-stop-id": g.value,
              "onUpdate:currentTabStopId": $[0] || ($[0] = (L) => g.value = L),
              "as-child": "",
              orientation: "vertical",
              dir: p(i).dir.value,
              loop: p(l),
              onEntryFocus: $[1] || ($[1] = (L) => {
                o("entryFocus", L), p(i).isUsingKeyboardRef.value || L.preventDefault();
              })
            }, {
              default: w(() => [
                E(p(Ou), {
                  ref: p(y),
                  role: "menu",
                  as: M.as,
                  "as-child": M.asChild,
                  "aria-orientation": "vertical",
                  "data-radix-menu-content": "",
                  "data-state": p(pg)(p(r).open.value),
                  dir: p(i).dir.value,
                  side: M.side,
                  "side-offset": M.sideOffset,
                  align: M.align,
                  "align-offset": M.alignOffset,
                  "avoid-collisions": M.avoidCollisions,
                  "collision-boundary": M.collisionBoundary,
                  "collision-padding": M.collisionPadding,
                  "arrow-padding": M.arrowPadding,
                  "prioritize-position": M.prioritizePosition,
                  sticky: M.sticky,
                  "hide-when-detached": M.hideWhenDetached,
                  onKeydown: I,
                  onBlur: z,
                  onPointermove: N
                }, {
                  default: w(() => [
                    D(M.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "prioritize-position", "sticky", "hide-when-detached"])
              ]),
              _: 3
            }, 8, ["current-tab-stop-id", "dir", "loop"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), i4 = /* @__PURE__ */ T({
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = gg(), o = O(!1);
    async function r(s) {
      if (!s.defaultPrevented && Ja(s)) {
        if (e.disabled)
          n.onItemLeave(s);
        else if (!n.onItemEnter(s)) {
          const a = s.currentTarget;
          a == null || a.focus();
        }
      }
    }
    async function i(s) {
      await qe(), !s.defaultPrevented && Ja(s) && n.onItemLeave(s);
    }
    return (s, a) => (k(), _(p(se), {
      role: "menuitem",
      tabindex: "-1",
      as: s.as,
      "as-child": s.asChild,
      "data-radix-vue-collection-item": "",
      "aria-disabled": s.disabled || void 0,
      "data-disabled": s.disabled ? "" : void 0,
      "data-highlighted": o.value ? "" : void 0,
      onPointermove: r,
      onPointerleave: i,
      onFocus: a[0] || (a[0] = async (l) => {
        await qe(), !(l.defaultPrevented || s.disabled) && (o.value = !0);
      }),
      onBlur: a[1] || (a[1] = async (l) => {
        await qe(), !l.defaultPrevented && (o.value = !1);
      })
    }, {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-disabled", "data-disabled", "data-highlighted"]));
  }
}), yg = /* @__PURE__ */ T({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = X(), s = Il(), a = gg(), l = O(!1);
    async function c() {
      const d = i.value;
      if (!n.disabled && d) {
        const u = new CustomEvent(TD, {
          bubbles: !0,
          cancelable: !0
        });
        o("select", u), await qe(), u.defaultPrevented ? l.value = !1 : s.onClose();
      }
    }
    return (d, u) => (k(), _(i4, j(n, {
      ref: p(r),
      onClick: c,
      onPointerdown: u[0] || (u[0] = () => {
        l.value = !0;
      }),
      onPointerup: u[1] || (u[1] = async (f) => {
        var h;
        await qe(), !f.defaultPrevented && (l.value || (h = f.currentTarget) == null || h.click());
      }),
      onKeydown: u[2] || (u[2] = async (f) => {
        const h = p(a).searchRef.value !== "";
        d.disabled || h && f.key === " " || p(mh).includes(f.key) && (f.currentTarget.click(), f.preventDefault());
      })
    }), {
      default: w(() => [
        D(d.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [cR, dR] = Ve(
  ["MenuCheckboxItem", "MenuRadioItem"],
  "MenuItemIndicatorContext"
), s4 = /* @__PURE__ */ T({
  __name: "MenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const e = cR({
      checked: O(!1)
    });
    return (n, o) => (k(), _(p(hn), {
      present: n.forceMount || p(fd)(p(e).checked.value) || p(e).checked.value === !0
    }, {
      default: w(() => [
        E(p(se), {
          as: n.as,
          "as-child": n.asChild,
          "data-state": p(Yx)(p(e).checked.value)
        }, {
          default: w(() => [
            D(n.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), a4 = /* @__PURE__ */ T({
  __name: "MenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String], default: !1 },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Rt(n, "checked", o);
    return dR({ checked: r }), (i, s) => (k(), _(yg, j({ role: "menuitemcheckbox" }, n, {
      "aria-checked": p(fd)(p(r)) ? "mixed" : p(r),
      "data-state": p(Yx)(p(r)),
      onSelect: s[0] || (s[0] = async (a) => {
        o("select", a), p(fd)(p(r)) ? r.value = !0 : r.value = !p(r);
      })
    }), {
      default: w(() => [
        D(i.$slots, "default", { checked: p(r) })
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), uR = /* @__PURE__ */ T({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = De(n, o), i = _i(), { forwardRef: s, currentElement: a } = X();
    return _u(a), (l, c) => (k(), _(vg, j(p(r), {
      ref: p(s),
      "trap-focus": p(i).open.value,
      "disable-outside-pointer-events": p(i).open.value,
      "disable-outside-scroll": !0,
      onDismiss: c[0] || (c[0] = (d) => p(i).onOpenChange(!1)),
      onFocusOutside: c[1] || (c[1] = yt((d) => o("focusOutside", d), ["prevent"]))
    }), {
      default: w(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), fR = /* @__PURE__ */ T({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = De(t, e), o = _i();
    return (r, i) => (k(), _(vg, j(p(n), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: i[0] || (i[0] = (s) => p(o).onOpenChange(!1))
    }), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), l4 = /* @__PURE__ */ T({
  __name: "MenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = De(t, e), o = _i(), r = Il();
    return (i, s) => (k(), _(p(hn), {
      present: i.forceMount || p(o).open.value
    }, {
      default: w(() => [
        p(r).modal.value ? (k(), _(uR, Oe(j({ key: 0 }, { ...i.$attrs, ...p(n) })), {
          default: w(() => [
            D(i.$slots, "default")
          ]),
          _: 3
        }, 16)) : (k(), _(fR, Oe(j({ key: 1 }, { ...i.$attrs, ...p(n) })), {
          default: w(() => [
            D(i.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), c4 = /* @__PURE__ */ T({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(Ml), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), d4 = /* @__PURE__ */ T({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(se), j(e, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [u4, pR] = Ve("MenuSub"), hR = /* @__PURE__ */ T({
  __name: "MenuSub",
  props: {
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = Rt(n, "open", e, {
      defaultValue: !1,
      passive: n.open === void 0
    }), r = _i(), i = O(), s = O();
    return Pe((a) => {
      (r == null ? void 0 : r.open.value) === !1 && (o.value = !1), a(() => o.value = !1);
    }), n4({
      open: o,
      onOpenChange: (a) => {
        o.value = a;
      },
      content: s,
      onContentChange: (a) => {
        s.value = a;
      }
    }), pR({
      triggerId: "",
      contentId: "",
      trigger: i,
      onTriggerChange: (a) => {
        i.value = a;
      }
    }), (a, l) => (k(), _(p(Ol), null, {
      default: w(() => [
        D(a.$slots, "default")
      ]),
      _: 3
    }));
  }
}), mR = /* @__PURE__ */ T({
  __name: "MenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = De(t, e), o = _i(), r = Il(), i = u4(), { forwardRef: s, currentElement: a } = X();
    return i.contentId || (i.contentId = At(void 0, "radix-vue-menu-sub-content")), (l, c) => (k(), _(p(hn), {
      present: l.forceMount || p(o).open.value
    }, {
      default: w(() => [
        E(vg, j(p(n), {
          id: p(i).contentId,
          ref: p(s),
          "aria-labelledby": p(i).triggerId,
          align: "start",
          side: p(r).dir.value === "rtl" ? "left" : "right",
          "disable-outside-pointer-events": !1,
          "disable-outside-scroll": !1,
          "trap-focus": !1,
          onOpenAutoFocus: c[0] || (c[0] = yt((d) => {
            var u;
            p(r).isUsingKeyboardRef.value && ((u = p(a)) == null || u.focus());
          }, ["prevent"])),
          onCloseAutoFocus: c[1] || (c[1] = yt(() => {
          }, ["prevent"])),
          onFocusOutside: c[2] || (c[2] = (d) => {
            d.defaultPrevented || d.target !== p(i).trigger.value && p(o).onOpenChange(!1);
          }),
          onEscapeKeyDown: c[3] || (c[3] = (d) => {
            p(r).onClose(), d.preventDefault();
          }),
          onKeydown: c[4] || (c[4] = (d) => {
            var u, f;
            const h = (u = d.currentTarget) == null ? void 0 : u.contains(d.target), m = p(RD)[p(r).dir.value].includes(d.key);
            h && m && (p(o).onOpenChange(!1), (f = p(i).trigger.value) == null || f.focus(), d.preventDefault());
          })
        }), {
          default: w(() => [
            D(l.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-labelledby", "side"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), gR = /* @__PURE__ */ T({
  __name: "MenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = _i(), o = Il(), r = u4(), i = gg(), s = O(null);
    r.triggerId || (r.triggerId = At(void 0, "radix-vue-menu-sub-trigger"));
    function a() {
      s.value && window.clearTimeout(s.value), s.value = null;
    }
    en(() => {
      a();
    });
    function l(u) {
      !Ja(u) || i.onItemEnter(u) || !e.disabled && !n.open.value && !s.value && (i.onPointerGraceIntentChange(null), s.value = window.setTimeout(() => {
        n.onOpenChange(!0), a();
      }, 100));
    }
    async function c(u) {
      var f, h;
      if (!Ja(u))
        return;
      a();
      const m = (f = n.content.value) == null ? void 0 : f.getBoundingClientRect();
      if (m != null && m.width) {
        const g = (h = n.content.value) == null ? void 0 : h.dataset.side, v = g === "right", y = v ? -5 : 5, x = m[v ? "left" : "right"], C = m[v ? "right" : "left"];
        i.onPointerGraceIntentChange({
          area: [
            // Apply a bleed on clientX to ensure that our exit point is
            // consistently within polygon bounds
            { x: u.clientX + y, y: u.clientY },
            { x, y: m.top },
            { x: C, y: m.top },
            { x: C, y: m.bottom },
            { x, y: m.bottom }
          ],
          side: g
        }), window.clearTimeout(i.pointerGraceTimerRef.value), i.pointerGraceTimerRef.value = window.setTimeout(
          () => i.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (i.onTriggerLeave(u))
          return;
        i.onPointerGraceIntentChange(null);
      }
    }
    async function d(u) {
      var f;
      const h = i.searchRef.value !== "";
      e.disabled || h && u.key === " " || DD[o.dir.value].includes(u.key) && (n.onOpenChange(!0), await qe(), (f = n.content.value) == null || f.focus(), u.preventDefault());
    }
    return (u, f) => (k(), _(hg, { "as-child": "" }, {
      default: w(() => [
        E(i4, j(e, {
          id: p(r).triggerId,
          ref: (h) => {
            var m;
            (m = p(r)) == null || m.onTriggerChange(h == null ? void 0 : h.$el);
          },
          "aria-haspopup": "menu",
          "aria-expanded": p(n).open.value,
          "aria-controls": p(r).contentId,
          "data-state": p(pg)(p(n).open.value),
          onClick: f[0] || (f[0] = async (h) => {
            e.disabled || h.defaultPrevented || (h.currentTarget.focus(), p(n).open.value || p(n).onOpenChange(!0));
          }),
          onPointermove: l,
          onPointerleave: c,
          onKeydown: d
        }), {
          default: w(() => [
            D(u.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-expanded", "aria-controls", "data-state"])
      ]),
      _: 3
    }));
  }
}), [f4, vR] = Ve("DropdownMenuRoot"), yR = /* @__PURE__ */ T({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e;
    X();
    const r = Rt(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), i = O(), { modal: s, dir: a } = mt(n), l = qo(a);
    return vR({
      open: r,
      onOpenChange: (c) => {
        r.value = c;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      triggerId: "",
      triggerElement: i,
      contentId: "",
      modal: s,
      dir: l
    }), (c, d) => (k(), _(p(o4), {
      open: p(r),
      "onUpdate:open": d[0] || (d[0] = (u) => ri(r) ? r.value = u : null),
      dir: p(l),
      modal: p(s)
    }, {
      default: w(() => [
        D(c.$slots, "default", { open: p(r) })
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
}), bR = /* @__PURE__ */ T({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = f4(), { forwardRef: o, currentElement: r } = X();
    return _e(() => {
      n.triggerElement = r;
    }), n.triggerId || (n.triggerId = At(void 0, "radix-vue-dropdown-menu-trigger")), (i, s) => (k(), _(p(hg), { "as-child": "" }, {
      default: w(() => [
        E(p(se), {
          id: p(n).triggerId,
          ref: p(o),
          type: i.as === "button" ? "button" : void 0,
          "as-child": e.asChild,
          as: i.as,
          "aria-haspopup": "menu",
          "aria-expanded": p(n).open.value,
          "aria-controls": p(n).open.value ? p(n).contentId : void 0,
          "data-disabled": i.disabled ? "" : void 0,
          disabled: i.disabled,
          "data-state": p(n).open.value ? "open" : "closed",
          onClick: s[0] || (s[0] = async (a) => {
            var l;
            !i.disabled && a.button === 0 && a.ctrlKey === !1 && ((l = p(n)) == null || l.onOpenToggle(), await qe(), p(n).open.value && a.preventDefault());
          }),
          onKeydown: s[1] || (s[1] = Sr(
            (a) => {
              i.disabled || (["Enter", " "].includes(a.key) && p(n).onOpenToggle(), a.key === "ArrowDown" && p(n).onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
            },
            ["enter", "space", "arrow-down"]
          ))
        }, {
          default: w(() => [
            D(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
      ]),
      _: 3
    }));
  }
}), yh = /* @__PURE__ */ T({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(c4), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wR = /* @__PURE__ */ T({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = De(t, e);
    X();
    const o = f4(), r = O(!1);
    function i(s) {
      s.defaultPrevented || (r.value || setTimeout(() => {
        var a;
        (a = o.triggerElement.value) == null || a.focus();
      }, 0), r.value = !1, s.preventDefault());
    }
    return o.contentId || (o.contentId = At(void 0, "radix-vue-dropdown-menu-content")), (s, a) => {
      var l;
      return k(), _(p(l4), j(p(n), {
        id: p(o).contentId,
        "aria-labelledby": (l = p(o)) == null ? void 0 : l.triggerId,
        style: {
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        },
        onCloseAutoFocus: i,
        onInteractOutside: a[0] || (a[0] = (c) => {
          var d;
          if (c.defaultPrevented)
            return;
          const u = c.detail.originalEvent, f = u.button === 0 && u.ctrlKey === !0, h = u.button === 2 || f;
          (!p(o).modal.value || h) && (r.value = !0), (d = p(o).triggerElement.value) != null && d.contains(c.target) && c.preventDefault();
        })
      }), {
        default: w(() => [
          D(s.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby", "style"]);
    };
  }
}), xR = /* @__PURE__ */ T({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, o = Vr(e);
    return X(), (r, i) => (k(), _(p(yg), Oe(Le({ ...n, ...p(o) })), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), kR = /* @__PURE__ */ T({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return X(), (n, o) => (k(), _(p(d4), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), CR = /* @__PURE__ */ T({
  __name: "DropdownMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(t, { emit: e }) {
    const n = t, o = Vr(e);
    return X(), (r, i) => (k(), _(p(a4), Oe(Le({ ...n, ...p(o) })), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), SR = /* @__PURE__ */ T({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return X(), (n, o) => (k(), _(p(s4), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), AR = /* @__PURE__ */ T({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = Rt(n, "open", e, {
      passive: n.open === void 0,
      defaultValue: n.defaultOpen ?? !1
    });
    return X(), (r, i) => (k(), _(p(hR), {
      open: p(o),
      "onUpdate:open": i[0] || (i[0] = (s) => ri(o) ? o.value = s : null)
    }, {
      default: w(() => [
        D(r.$slots, "default", { open: p(o) })
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), ER = /* @__PURE__ */ T({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = De(t, e);
    return X(), (o, r) => (k(), _(p(mR), j(p(n), { style: {
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), _R = /* @__PURE__ */ T({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return X(), (n, o) => (k(), _(p(gR), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), MR = /* @__PURE__ */ T({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(t) {
    const e = t;
    return X(), (n, o) => (k(), _(p(se), j(e, {
      onMousedown: o[0] || (o[0] = (r) => {
        !r.defaultPrevented && r.detail > 1 && r.preventDefault();
      })
    }), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [bg, TR] = Ve("MenubarRoot"), OR = /* @__PURE__ */ T({
  __name: "MenubarRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = X(), { createCollection: s } = ho("menubar");
    s(i);
    const a = Rt(n, "modelValue", o, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), l = O(null), { dir: c, loop: d } = mt(n), u = qo(c);
    return TR({
      modelValue: a,
      dir: u,
      loop: d,
      onMenuOpen: (f) => {
        a.value = f, l.value = f;
      },
      onMenuClose: () => {
        a.value = "";
      },
      onMenuToggle: (f) => {
        a.value = a.value ? "" : f, l.value = f;
      }
    }), (f, h) => (k(), _(p(Du), {
      "current-tab-stop-id": l.value,
      "onUpdate:currentTabStopId": h[0] || (h[0] = (m) => l.value = m),
      orientation: "horizontal",
      loop: p(d),
      dir: p(u),
      "as-child": ""
    }, {
      default: w(() => [
        E(p(se), {
          ref: p(r),
          role: "menubar"
        }, {
          default: w(() => [
            D(f.$slots, "default", { modelValue: p(a) })
          ]),
          _: 3
        }, 512)
      ]),
      _: 3
    }, 8, ["current-tab-stop-id", "loop", "dir"]));
  }
}), [p4, IR] = Ve("MenubarMenu"), DR = /* @__PURE__ */ T({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(t) {
    const e = At(t.value), n = bg();
    X();
    const o = O(), r = O(!1), i = P(() => n.modelValue.value === e);
    return ce(i, () => {
      i.value || (r.value = !1);
    }), IR({
      value: e,
      triggerElement: o,
      triggerId: e,
      contentId: "",
      wasKeyboardTriggerOpenRef: r
    }), (s, a) => (k(), _(p(o4), {
      open: i.value,
      modal: !1,
      dir: p(n).dir.value,
      "onUpdate:open": a[0] || (a[0] = (l) => {
        l || p(n).onMenuClose();
      })
    }, {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir"]));
  }
}), RR = /* @__PURE__ */ T({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = bg(), n = p4(), { forwardRef: o, currentElement: r } = X(), i = O(!1), s = P(() => e.modelValue.value === n.value);
    return _e(() => {
      n.triggerElement = r;
    }), (a, l) => (k(), _(p(mg), {
      "as-child": "",
      focusable: !a.disabled,
      "tab-stop-id": p(n).value
    }, {
      default: w(() => [
        E(p(hg), { "as-child": "" }, {
          default: w(() => [
            E(p(se), {
              id: p(n).triggerId,
              ref: p(o),
              as: a.as,
              type: a.as === "button" ? "button" : void 0,
              role: "menuitem",
              "aria-haspopup": "menu",
              "aria-expanded": s.value,
              "aria-controls": s.value ? p(n).contentId : void 0,
              "data-highlighted": i.value ? "" : void 0,
              "data-state": s.value ? "open" : "closed",
              "data-disabled": a.disabled ? "" : void 0,
              disabled: a.disabled,
              "data-value": p(n).value,
              "data-radix-vue-collection-item": "",
              onPointerdown: l[0] || (l[0] = (c) => {
                !a.disabled && c.button === 0 && c.ctrlKey === !1 && (p(e).onMenuOpen(p(n).value), s.value || c.preventDefault());
              }),
              onPointerenter: l[1] || (l[1] = () => {
                var c;
                p(e).modelValue.value && !s.value && (p(e).onMenuOpen(p(n).value), (c = p(r)) == null || c.focus());
              }),
              onKeydown: l[2] || (l[2] = Sr((c) => {
                a.disabled || (["Enter", " "].includes(c.key) && p(e).onMenuToggle(p(n).value), c.key === "ArrowDown" && p(e).onMenuOpen(p(n).value), ["Enter", " ", "ArrowDown"].includes(c.key) && (p(n).wasKeyboardTriggerOpenRef.value = !0, c.preventDefault()));
              }, ["enter", "space", "arrow-down"])),
              onFocus: l[3] || (l[3] = (c) => i.value = !0),
              onBlur: l[4] || (l[4] = (c) => i.value = !1)
            }, {
              default: w(() => [
                D(a.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "as", "type", "aria-expanded", "aria-controls", "data-highlighted", "data-state", "data-disabled", "disabled", "data-value"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
}), PR = /* @__PURE__ */ T({
  __name: "MenubarPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(c4), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), LR = /* @__PURE__ */ T({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = De(t, e);
    X();
    const o = bg(), r = p4();
    r.contentId || (r.contentId = At(void 0, "radix-vue-menubar-content"));
    const { injectCollection: i } = ho("menubar"), s = i(), a = O(!1);
    function l(c) {
      const d = c.target.hasAttribute(
        "data-radix-menubar-subtrigger"
      ), u = (o.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === c.key;
      if (!u && d)
        return;
      let f = s.value.map((g) => g.dataset.value);
      u && f.reverse();
      const h = f.indexOf(r.value);
      f = o.loop.value ? Wx(f, h + 1) : f.slice(h + 1);
      const [m] = f;
      m && o.onMenuOpen(m);
    }
    return (c, d) => (k(), _(p(l4), j(p(n), {
      id: p(r).contentId,
      "data-radix-menubar-content": "",
      "aria-labelledby": p(r).triggerId,
      style: {
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onCloseAutoFocus: d[0] || (d[0] = (u) => {
        var f;
        !p(o).modelValue.value && !a.value && ((f = p(r).triggerElement.value) == null || f.focus()), a.value = !1, u.preventDefault();
      }),
      onFocusOutside: d[1] || (d[1] = (u) => {
        const f = u.target;
        p(s).some((h) => h.contains(f)) && u.preventDefault();
      }),
      onInteractOutside: d[2] || (d[2] = (u) => {
        a.value = !0;
      }),
      onEntryFocus: d[3] || (d[3] = (u) => {
        p(r).wasKeyboardTriggerOpenRef.value || u.preventDefault();
      }),
      onKeydown: Sr(l, ["arrow-right", "arrow-left"])
    }), {
      default: w(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "aria-labelledby", "style"]));
  }
}), NR = /* @__PURE__ */ T({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, o = Vr(e);
    return X(), (r, i) => (k(), _(p(yg), Oe(Le({ ...n, ...p(o) })), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), BR = /* @__PURE__ */ T({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return X(), (n, o) => (k(), _(p(d4), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), $R = /* @__PURE__ */ T({
  __name: "MenubarCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(t, { emit: e }) {
    const n = t, o = Vr(e);
    return X(), (r, i) => (k(), _(p(a4), Oe(Le({ ...n, ...p(o) })), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zR = /* @__PURE__ */ T({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return X(), (n, o) => (k(), _(p(s4), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Dl, FR] = Ve("PopoverRoot"), HR = /* @__PURE__ */ T({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, { modal: r } = mt(n), i = Rt(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = O(), a = O(!1);
    return FR({
      contentId: "",
      modal: r,
      open: i,
      onOpenChange: (l) => {
        i.value = l;
      },
      onOpenToggle: () => {
        i.value = !i.value;
      },
      triggerElement: s,
      hasCustomAnchor: a
    }), (l, c) => (k(), _(p(Ol), null, {
      default: w(() => [
        D(l.$slots, "default", { open: p(i) })
      ]),
      _: 3
    }));
  }
}), VR = /* @__PURE__ */ T({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = Dl(), { forwardRef: o, currentElement: r } = X();
    return _e(() => {
      n.triggerElement.value = r.value;
    }), (i, s) => (k(), _(_n(p(n).hasCustomAnchor.value ? p(se) : p(Tu)), { "as-child": "" }, {
      default: w(() => [
        E(p(se), {
          ref: p(o),
          type: i.as === "button" ? "button" : void 0,
          "aria-haspopup": "dialog",
          "aria-expanded": p(n).open.value,
          "aria-controls": p(n).contentId,
          "data-state": p(n).open.value ? "open" : "closed",
          as: i.as,
          "as-child": e.asChild,
          onClick: p(n).onOpenToggle
        }, {
          default: w(() => [
            D(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
      ]),
      _: 3
    }));
  }
}), jR = /* @__PURE__ */ T({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(Ml), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), h4 = /* @__PURE__ */ T({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = _t(n), { forwardRef: i } = X(), s = Dl();
    return cg(), (a, l) => (k(), _(p(Mu), {
      "as-child": "",
      loop: "",
      trapped: a.trapFocus,
      onMountAutoFocus: l[5] || (l[5] = (c) => o("openAutoFocus", c)),
      onUnmountAutoFocus: l[6] || (l[6] = (c) => o("closeAutoFocus", c))
    }, {
      default: w(() => [
        E(p(Tl), {
          "as-child": "",
          "disable-outside-pointer-events": a.disableOutsidePointerEvents,
          onPointerDownOutside: l[0] || (l[0] = (c) => o("pointerDownOutside", c)),
          onInteractOutside: l[1] || (l[1] = (c) => o("interactOutside", c)),
          onEscapeKeyDown: l[2] || (l[2] = (c) => o("escapeKeyDown", c)),
          onFocusOutside: l[3] || (l[3] = (c) => o("focusOutside", c)),
          onDismiss: l[4] || (l[4] = (c) => p(s).onOpenChange(!1))
        }, {
          default: w(() => [
            E(p(Ou), j(p(r), {
              id: p(s).contentId,
              ref: p(i),
              "data-state": p(s).open.value ? "open" : "closed",
              role: "dialog",
              style: {
                "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
              }
            }), {
              default: w(() => [
                D(a.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "style"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), UR = /* @__PURE__ */ T({
  __name: "PopoverContentModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Dl(), i = O(!1);
    Eu(!0);
    const s = De(n, o), { forwardRef: a, currentElement: l } = X();
    return _u(l), (c, d) => (k(), _(h4, j(p(s), {
      ref: p(a),
      "trap-focus": p(r).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: d[0] || (d[0] = yt(
        (u) => {
          var f;
          o("closeAutoFocus", u), i.value || (f = p(r).triggerElement.value) == null || f.focus();
        },
        ["prevent"]
      )),
      onPointerDownOutside: d[1] || (d[1] = (u) => {
        o("pointerDownOutside", u);
        const f = u.detail.originalEvent, h = f.button === 0 && f.ctrlKey === !0, m = f.button === 2 || h;
        i.value = m;
      }),
      onFocusOutside: d[2] || (d[2] = yt(() => {
      }, ["prevent"]))
    }), {
      default: w(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), WR = /* @__PURE__ */ T({
  __name: "PopoverContentNonModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Dl(), i = O(!1), s = O(!1), a = De(n, o);
    return (l, c) => (k(), _(h4, j(p(a), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: c[0] || (c[0] = (d) => {
        var u;
        o("closeAutoFocus", d), d.defaultPrevented || (i.value || (u = p(r).triggerElement.value) == null || u.focus(), d.preventDefault()), i.value = !1, s.value = !1;
      }),
      onInteractOutside: c[1] || (c[1] = async (d) => {
        var u;
        o("interactOutside", d), d.defaultPrevented || (i.value = !0, d.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const f = d.target;
        (u = p(r).triggerElement.value) != null && u.contains(f) && d.preventDefault(), d.detail.originalEvent.type === "focusin" && s.value && d.preventDefault();
      })
    }), {
      default: w(() => [
        D(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), KR = /* @__PURE__ */ T({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Dl(), i = De(n, o), { forwardRef: s } = X();
    return r.contentId || (r.contentId = At(void 0, "radix-vue-popover-content")), (a, l) => (k(), _(p(hn), {
      present: a.forceMount || p(r).open.value
    }, {
      default: w(() => [
        p(r).modal.value ? (k(), _(UR, j({ key: 0 }, p(i), { ref: p(s) }), {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16)) : (k(), _(WR, j({ key: 1 }, p(i), { ref: p(s) }), {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [Dn, qR] = Ve("ScrollAreaRoot"), GR = /* @__PURE__ */ T({
  __name: "ScrollAreaRoot",
  props: {
    type: { default: "hover" },
    dir: {},
    scrollHideDelay: { default: 600 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { forwardRef: n, currentElement: o } = X(), r = O(0), i = O(0), s = O(), a = O(), l = O(), c = O(), d = O(!1), u = O(!1), { type: f, dir: h, scrollHideDelay: m } = mt(e), g = qo(h);
    return qR({
      type: f,
      dir: g,
      scrollHideDelay: m,
      scrollArea: o,
      viewport: s,
      onViewportChange: (v) => {
        s.value = v || void 0;
      },
      content: a,
      onContentChange: (v) => {
        a.value = v;
      },
      scrollbarX: l,
      scrollbarXEnabled: d,
      scrollbarY: c,
      scrollbarYEnabled: u,
      onScrollbarXChange: (v) => {
        l.value = v || void 0;
      },
      onScrollbarYChange: (v) => {
        c.value = v || void 0;
      },
      onScrollbarXEnabledChange: (v) => {
        d.value = v;
      },
      onScrollbarYEnabledChange: (v) => {
        u.value = v;
      },
      onCornerWidthChange: (v) => {
        r.value = v;
      },
      onCornerHeightChange: (v) => {
        i.value = v;
      }
    }), (v, y) => (k(), _(p(se), {
      ref: p(n),
      "as-child": e.asChild,
      as: v.as,
      dir: p(g),
      style: ct({
        position: "relative",
        // Pass corner sizes as CSS vars to reduce re-renders of context consumers
        "--radix-scroll-area-corner-width": `${r.value}px`,
        "--radix-scroll-area-corner-height": `${i.value}px`
      })
    }, {
      default: w(() => [
        D(v.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "dir", "style"]));
  }
}), JR = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t, { expose: e }) {
    const n = t, o = Dn(), r = O();
    _e(() => {
      o.onViewportChange(r.value), o.onContentChange(s.value);
    }), e({
      viewportElement: r
    });
    const { forwardRef: i, currentElement: s } = X();
    return (a, l) => (k(), U(ve, null, [
      B("div", j({
        ref_key: "viewportElement",
        ref: r,
        "data-radix-scroll-area-viewport": "",
        style: {
          /**
           * We don't support `visible` because the intention is to have at least one scrollbar
           * if this component is used and `visible` will behave like `auto` in that case
           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
           *
           * We don't handle `auto` because the intention is for the native implementation
           * to be hidden if using this component. We just want to ensure the node is scrollable
           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
           * the browser from having to work out whether to render native scrollbars or not,
           * we tell it to with the intention of hiding them in CSS.
           */
          overflowX: p(o).scrollbarXEnabled.value ? "scroll" : "hidden",
          overflowY: p(o).scrollbarYEnabled.value ? "scroll" : "hidden"
        }
      }, a.$attrs, { tabindex: 0 }), [
        E(p(se), {
          ref: p(i),
          style: { minWidth: "100%", display: "table" },
          "as-child": n.asChild,
          as: a.as
        }, {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ], 16),
      E(p(se), {
        as: "style",
        nonce: a.nonce
      }, {
        default: w(() => [
          he(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")
        ]),
        _: 1
      }, 8, ["nonce"])
    ], 64));
  }
});
function m4(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1])
      return e[0];
    const o = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + o * (n - t[0]);
  };
}
function Ru(t) {
  const e = g4(t.viewport, t.content), n = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = (t.scrollbar.size - n) * e;
  return Math.max(o, 18);
}
function g4(t, e) {
  const n = t / e;
  return Number.isNaN(n) ? 0 : n;
}
function YR(t, e = () => {
}) {
  let n = { left: t.scrollLeft, top: t.scrollTop }, o = 0;
  return function r() {
    const i = { left: t.scrollLeft, top: t.scrollTop }, s = n.left !== i.left, a = n.top !== i.top;
    (s || a) && e(), n = i, o = window.requestAnimationFrame(r);
  }(), () => window.cancelAnimationFrame(o);
}
function Rv(t, e, n = "ltr") {
  const o = Ru(e), r = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, i = e.scrollbar.size - r, s = e.content - e.viewport, a = i - o, l = n === "ltr" ? [0, s] : [s * -1, 0], c = ph(
    t,
    l[0],
    l[1]
  );
  return m4([0, s], [0, a])(c);
}
function oc(t) {
  return t ? Number.parseInt(t, 10) : 0;
}
function XR(t, e, n, o = "ltr") {
  const r = Ru(n), i = r / 2, s = e || i, a = r - s, l = n.scrollbar.paddingStart + s, c = n.scrollbar.size - n.scrollbar.paddingEnd - a, d = n.content - n.viewport, u = o === "ltr" ? [0, d] : [d * -1, 0];
  return m4(
    [l, c],
    u
  )(t);
}
function Pv(t, e) {
  return t > 0 && t < e;
}
const v4 = /* @__PURE__ */ T({
  __name: "ScrollAreaScrollbarImpl",
  props: {
    isHorizontal: { type: Boolean }
  },
  emits: ["onDragScroll", "onWheelScroll", "onThumbPointerDown"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Dn(), i = Pu(), s = Lu(), { forwardRef: a, currentElement: l } = X(), c = O(""), d = O();
    function u(y) {
      var x, C;
      if (d.value) {
        const b = y.clientX - ((x = d.value) == null ? void 0 : x.left), S = y.clientY - ((C = d.value) == null ? void 0 : C.top);
        o("onDragScroll", { x: b, y: S });
      }
    }
    function f(y) {
      y.button === 0 && (y.target.setPointerCapture(y.pointerId), d.value = l.value.getBoundingClientRect(), c.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", r.viewport && (r.viewport.value.style.scrollBehavior = "auto"), u(y));
    }
    function h(y) {
      u(y);
    }
    function m(y) {
      const x = y.target;
      x.hasPointerCapture(y.pointerId) && x.releasePointerCapture(y.pointerId), document.body.style.webkitUserSelect = c.value, r.viewport && (r.viewport.value.style.scrollBehavior = ""), d.value = void 0;
    }
    function g(y) {
      var x;
      const C = y.target, b = (x = l.value) == null ? void 0 : x.contains(C), S = i.sizes.value.content - i.sizes.value.viewport;
      b && i.handleWheelScroll(y, S);
    }
    _e(() => {
      document.addEventListener("wheel", g, { passive: !1 });
    }), en(() => {
      document.removeEventListener("wheel", g);
    });
    function v() {
      var y, x, C, b, S;
      l.value && (n.isHorizontal ? i.handleSizeChange({
        content: ((y = r.viewport.value) == null ? void 0 : y.scrollWidth) ?? 0,
        viewport: ((x = r.viewport.value) == null ? void 0 : x.offsetWidth) ?? 0,
        scrollbar: {
          size: l.value.clientWidth ?? 0,
          paddingStart: oc(getComputedStyle(l.value).paddingLeft),
          paddingEnd: oc(getComputedStyle(l.value).paddingRight)
        }
      }) : i.handleSizeChange({
        content: ((C = r.viewport.value) == null ? void 0 : C.scrollHeight) ?? 0,
        viewport: ((b = r.viewport.value) == null ? void 0 : b.offsetHeight) ?? 0,
        scrollbar: {
          size: ((S = l.value) == null ? void 0 : S.clientHeight) ?? 0,
          paddingStart: oc(getComputedStyle(l.value).paddingLeft),
          paddingEnd: oc(getComputedStyle(l.value).paddingRight)
        }
      }));
    }
    return ms(l, v), ms(r.content, v), (y, x) => (k(), _(p(se), {
      ref: p(a),
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: p(s).as.value,
      "as-child": p(s).asChild.value,
      onPointerdown: f,
      onPointermove: h,
      onPointerup: m
    }, {
      default: w(() => [
        D(y.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), ZR = /* @__PURE__ */ T({
  __name: "ScrollAreaScrollbarX",
  setup(t) {
    const e = Dn(), n = Pu(), { forwardRef: o, currentElement: r } = X();
    _e(() => {
      r.value && e.onScrollbarXChange(r.value);
    });
    const i = P(() => n.sizes.value);
    return (s, a) => (k(), _(v4, {
      ref: p(o),
      "is-horizontal": !0,
      "data-orientation": "horizontal",
      style: ct({
        bottom: 0,
        left: p(e).dir.value === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: p(e).dir.value === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": i.value ? `${p(Ru)(i.value)}px` : void 0
      }),
      onOnDragScroll: a[0] || (a[0] = (l) => p(n).onDragScroll(l.x))
    }, {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), QR = /* @__PURE__ */ T({
  __name: "ScrollAreaScrollbarY",
  setup(t) {
    const e = Dn(), n = Pu(), { forwardRef: o, currentElement: r } = X();
    _e(() => {
      r.value && e.onScrollbarYChange(r.value);
    });
    const i = P(() => n.sizes.value);
    return (s, a) => (k(), _(v4, {
      ref: p(o),
      "is-horizontal": !1,
      "data-orientation": "vertical",
      style: ct({
        top: 0,
        right: p(e).dir.value === "ltr" ? 0 : void 0,
        left: p(e).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": i.value ? `${p(Ru)(i.value)}px` : void 0
      }),
      onOnDragScroll: a[0] || (a[0] = (l) => p(n).onDragScroll(l.y))
    }, {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), [Pu, eP] = Ve("ScrollAreaScrollbarVisible"), wg = /* @__PURE__ */ T({
  __name: "ScrollAreaScrollbarVisible",
  setup(t) {
    const e = Dn(), n = Lu(), { forwardRef: o } = X(), r = O({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    }), i = P(() => {
      const y = g4(r.value.viewport, r.value.content);
      return y > 0 && y < 1;
    }), s = O(), a = O(0);
    function l(y, x) {
      if (h.value) {
        const C = e.viewport.value.scrollLeft + y.deltaY;
        e.viewport.value.scrollLeft = C, Pv(C, x) && y.preventDefault();
      } else {
        const C = e.viewport.value.scrollTop + y.deltaY;
        e.viewport.value.scrollTop = C, Pv(C, x) && y.preventDefault();
      }
    }
    function c(y, x) {
      h.value ? a.value = x.x : a.value = x.y;
    }
    function d(y) {
      a.value = 0;
    }
    function u(y) {
      r.value = y;
    }
    function f(y, x) {
      return XR(
        y,
        a.value,
        r.value,
        x
      );
    }
    const h = P(
      () => n.isHorizontal.value
    );
    function m(y) {
      h.value ? e.viewport.value.scrollLeft = f(
        y,
        e.dir.value
      ) : e.viewport.value.scrollTop = f(y);
    }
    function g() {
      if (h.value) {
        if (e.viewport.value && s.value) {
          const y = e.viewport.value.scrollLeft, x = Rv(
            y,
            r.value,
            e.dir.value
          );
          s.value.style.transform = `translate3d(${x}px, 0, 0)`;
        }
      } else if (e.viewport.value && s.value) {
        const y = e.viewport.value.scrollTop, x = Rv(y, r.value);
        s.value.style.transform = `translate3d(0, ${x}px, 0)`;
      }
    }
    function v(y) {
      s.value = y;
    }
    return eP({
      sizes: r,
      hasThumb: i,
      handleWheelScroll: l,
      handleThumbDown: c,
      handleThumbUp: d,
      handleSizeChange: u,
      onThumbPositionChange: g,
      onThumbChange: v,
      onDragScroll: m
    }), (y, x) => h.value ? (k(), _(ZR, j({ key: 0 }, y.$attrs, { ref: p(o) }), {
      default: w(() => [
        D(y.$slots, "default")
      ]),
      _: 3
    }, 16)) : (k(), _(QR, j({ key: 1 }, y.$attrs, { ref: p(o) }), {
      default: w(() => [
        D(y.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), y4 = /* @__PURE__ */ T({
  __name: "ScrollAreaScrollbarAuto",
  props: {
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = Dn(), n = Lu(), { forwardRef: o } = X(), r = O(!1), i = $x(() => {
      if (e.viewport.value) {
        const s = e.viewport.value.offsetWidth < e.viewport.value.scrollWidth, a = e.viewport.value.offsetHeight < e.viewport.value.scrollHeight;
        r.value = n.isHorizontal.value ? s : a;
      }
    }, 10);
    return _e(() => i()), ms(e.viewport, i), ms(e.content, i), (s, a) => (k(), _(p(hn), {
      present: s.forceMount || r.value
    }, {
      default: w(() => [
        E(wg, j(s.$attrs, {
          ref: p(o),
          "data-state": r.value ? "visible" : "hidden"
        }), {
          default: w(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), tP = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarHover",
  props: {
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = Dn(), { forwardRef: n } = X();
    let o;
    const r = O(!1);
    function i() {
      window.clearTimeout(o), r.value = !0;
    }
    function s() {
      o = window.setTimeout(() => {
        r.value = !1;
      }, e.scrollHideDelay.value);
    }
    return _e(() => {
      const a = e.scrollArea.value;
      a && (a.addEventListener("pointerenter", i), a.addEventListener("pointerleave", s));
    }), en(() => {
      const a = e.scrollArea.value;
      a && (window.clearTimeout(o), a.removeEventListener("pointerenter", i), a.removeEventListener("pointerleave", s));
    }), (a, l) => (k(), _(p(hn), {
      present: a.forceMount || r.value
    }, {
      default: w(() => [
        E(y4, j(a.$attrs, {
          ref: p(n),
          "data-state": r.value ? "visible" : "hidden"
        }), {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), nP = /* @__PURE__ */ T({
  __name: "ScrollAreaScrollbarScroll",
  props: {
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = Dn(), n = Lu(), { forwardRef: o } = X(), { state: r, dispatch: i } = Ux("hidden", {
      hidden: {
        SCROLL: "scrolling"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    Pe((a) => {
      if (r.value === "idle") {
        const l = window.setTimeout(
          () => i("HIDE"),
          e.scrollHideDelay.value
        );
        a(() => {
          window.clearTimeout(l);
        });
      }
    });
    const s = $x(() => i("SCROLL_END"), 100);
    return Pe((a) => {
      const l = e.viewport.value, c = n.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (l) {
        let d = l[c];
        const u = () => {
          const f = l[c];
          d !== f && (i("SCROLL"), s()), d = f;
        };
        l.addEventListener("scroll", u), a(() => {
          l.removeEventListener("scroll", u);
        });
      }
    }), (a, l) => (k(), _(p(hn), {
      present: a.forceMount || p(r) !== "hidden"
    }, {
      default: w(() => [
        E(wg, j(a.$attrs, { ref: p(o) }), {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [Lu, oP] = Ve("ScrollAreaScrollbar"), rP = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(t) {
    const e = t, { forwardRef: n } = X(), o = Dn(), r = P(() => e.orientation === "horizontal");
    ce(
      r,
      () => {
        r.value ? o.onScrollbarXEnabledChange(!0) : o.onScrollbarYEnabledChange(!0);
      },
      { immediate: !0 }
    ), en(() => {
      o.onScrollbarXEnabledChange(!1), o.onScrollbarYEnabledChange(!1);
    });
    const { orientation: i, forceMount: s, asChild: a, as: l } = mt(e);
    return oP({
      orientation: i,
      forceMount: s,
      isHorizontal: r,
      as: l,
      asChild: a
    }), (c, d) => p(o).type.value === "hover" ? (k(), _(tP, j({ key: 0 }, c.$attrs, {
      ref: p(n),
      "force-mount": p(s)
    }), {
      default: w(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : p(o).type.value === "scroll" ? (k(), _(nP, j({ key: 1 }, c.$attrs, {
      ref: p(n),
      "force-mount": p(s)
    }), {
      default: w(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : p(o).type.value === "auto" ? (k(), _(y4, j({ key: 2 }, c.$attrs, {
      ref: p(n),
      "force-mount": p(s)
    }), {
      default: w(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : p(o).type.value === "always" ? (k(), _(wg, j({ key: 3 }, c.$attrs, {
      ref: p(n),
      "data-state": "visible"
    }), {
      default: w(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16)) : ae("", !0);
  }
}), iP = /* @__PURE__ */ T({
  __name: "ScrollAreaThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = Dn(), o = Pu();
    function r(f) {
      const h = f.target.getBoundingClientRect(), m = f.clientX - h.left, g = f.clientY - h.top;
      o.handleThumbDown(f, { x: m, y: g });
    }
    function i(f) {
      o.handleThumbUp(f);
    }
    const { forwardRef: s, currentElement: a } = X(), l = O(), c = P(() => n.viewport.value);
    function d() {
      if (!l.value) {
        const f = YR(
          c.value,
          o.onThumbPositionChange
        );
        l.value = f, o.onThumbPositionChange();
      }
    }
    const u = P(() => o.sizes.value);
    return zI(u, () => {
      o.onThumbChange(a.value), c.value && (o.onThumbPositionChange(), c.value.addEventListener("scroll", d));
    }), en(() => {
      var f;
      c.value.removeEventListener("scroll", d), (f = n.viewport.value) == null || f.removeEventListener("scroll", d);
    }), (f, h) => (k(), _(p(se), {
      ref: p(s),
      "data-state": p(o).hasThumb ? "visible" : "hidden",
      style: ct({
        width: "var(--radix-scroll-area-thumb-width)",
        height: "var(--radix-scroll-area-thumb-height)"
      }),
      "as-child": e.asChild,
      as: f.as,
      onPointerdown: r,
      onPointerup: i
    }, {
      default: w(() => [
        D(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-state", "style", "as-child", "as"]));
  }
}), sP = /* @__PURE__ */ T({
  __name: "ScrollAreaCornerImpl",
  setup(t) {
    const e = Dn(), n = O(0), o = O(0), r = P(() => !!n.value && !!o.value);
    function i() {
      var a;
      const l = ((a = e.scrollbarX.value) == null ? void 0 : a.offsetHeight) || 0;
      e.onCornerHeightChange(l), o.value = l;
    }
    function s() {
      var a;
      const l = ((a = e.scrollbarY.value) == null ? void 0 : a.offsetWidth) || 0;
      e.onCornerWidthChange(l), n.value = l;
    }
    return ms(e.scrollbarX.value, i), ms(e.scrollbarY.value, s), ce(() => e.scrollbarX.value, i), ce(() => e.scrollbarY.value, s), (a, l) => {
      var c;
      return r.value ? (k(), _(p(se), j({
        key: 0,
        style: {
          width: `${n.value}px`,
          height: `${o.value}px`,
          position: "absolute",
          right: p(e).dir.value === "ltr" ? 0 : void 0,
          left: p(e).dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      }, (c = a.$parent) == null ? void 0 : c.$props), {
        default: w(() => [
          D(a.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])) : ae("", !0);
    };
  }
}), aP = /* @__PURE__ */ T({
  __name: "ScrollAreaCorner",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { forwardRef: n } = X(), o = Dn(), r = P(
      () => !!o.scrollbarX.value && !!o.scrollbarY.value
    ), i = P(
      () => o.type.value !== "scroll" && r.value
    );
    return (s, a) => i.value ? (k(), _(sP, j({ key: 0 }, e, { ref: p(n) }), {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16)) : ae("", !0);
  }
}), lP = ["default-value"], cP = /* @__PURE__ */ T({
  __name: "BubbleSelect",
  props: {
    autocomplete: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    form: {},
    multiple: { type: Boolean },
    name: {},
    required: { type: Boolean },
    size: {},
    value: {}
  },
  setup(t) {
    const e = t, { value: n } = mt(e), o = O();
    return (r, i) => (k(), _(p(Iu), { "as-child": "" }, {
      default: w(() => [
        Sn(B("select", j({
          ref_key: "selectElement",
          ref: o
        }, e, {
          "onUpdate:modelValue": i[0] || (i[0] = (s) => ri(n) ? n.value = s : null),
          "default-value": p(n)
        }), [
          D(r.$slots, "default")
        ], 16, lP), [
          [i8, p(n)]
        ])
      ]),
      _: 3
    }));
  }
}), dP = {
  key: 0,
  value: ""
}, [Mi, b4] = Ve("SelectRoot"), [uP, fP] = Ve("SelectRoot"), pP = /* @__PURE__ */ T({
  __name: "SelectRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    defaultValue: { default: "" },
    modelValue: { default: void 0 },
    dir: {},
    name: {},
    autocomplete: {},
    disabled: { type: Boolean },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Rt(n, "modelValue", o, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), i = Rt(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = O(), a = O(), l = O({
      x: 0,
      y: 0
    }), c = O(!1), { required: d, disabled: u, dir: f } = mt(n), h = qo(f);
    b4({
      triggerElement: s,
      onTriggerChange: (y) => {
        s.value = y;
      },
      valueElement: a,
      onValueElementChange: (y) => {
        a.value = y;
      },
      valueElementHasChildren: c,
      onValueElementHasChildrenChange: (y) => {
        c.value = y;
      },
      contentId: "",
      modelValue: r,
      onValueChange: (y) => {
        r.value = y;
      },
      open: i,
      required: d,
      onOpenChange: (y) => {
        i.value = y;
      },
      dir: h,
      triggerPointerDownPosRef: l,
      disabled: u
    });
    const m = Vx(s), g = O(/* @__PURE__ */ new Set()), v = P(() => Array.from(g.value).map((y) => {
      var x;
      return (x = y.props) == null ? void 0 : x.value;
    }).join(";"));
    return fP({
      onNativeOptionAdd: (y) => {
        g.value.add(y);
      },
      onNativeOptionRemove: (y) => {
        g.value.delete(y);
      }
    }), (y, x) => (k(), _(p(Ol), null, {
      default: w(() => [
        D(y.$slots, "default", {
          modelValue: p(r),
          open: p(i)
        }),
        p(m) ? (k(), _(cP, j({ key: v.value }, y.$attrs, {
          "aria-hidden": "",
          tabindex: "-1",
          required: p(d),
          name: y.name,
          autocomplete: y.autocomplete,
          disabled: p(u),
          value: p(r),
          onChange: x[0] || (x[0] = (C) => r.value = C.target.value)
        }), {
          default: w(() => [
            p(r) === void 0 ? (k(), U("option", dP)) : ae("", !0),
            (k(!0), U(ve, null, Fe(Array.from(g.value), (C) => (k(), _(_n(C), j(C.props, {
              key: C.key ?? ""
            }), null, 16))), 128))
          ]),
          _: 1
        }, 16, ["required", "name", "autocomplete", "disabled", "value"])) : ae("", !0)
      ]),
      _: 3
    }));
  }
}), hP = [" ", "Enter", "ArrowUp", "ArrowDown"], mP = [" ", "Enter"], _o = 10;
function w4(t) {
  return t === "" || AI(t);
}
const gP = /* @__PURE__ */ T({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = Mi(), o = P(() => {
      var h;
      return ((h = n.disabled) == null ? void 0 : h.value) || e.disabled;
    }), { forwardRef: r, currentElement: i } = X();
    n.contentId || (n.contentId = At(void 0, "radix-vue-select-content")), _e(() => {
      n.triggerElement = i;
    });
    const { injectCollection: s } = ho(), a = s(), { search: l, handleTypeaheadSearch: c, resetTypeahead: d } = dg(a);
    function u() {
      o.value || (n.onOpenChange(!0), d());
    }
    function f(h) {
      u(), n.triggerPointerDownPosRef.value = {
        x: Math.round(h.pageX),
        y: Math.round(h.pageY)
      };
    }
    return (h, m) => (k(), _(p(Tu), { "as-child": "" }, {
      default: w(() => {
        var g, v, y, x;
        return [
          E(p(se), {
            ref: p(r),
            role: "combobox",
            type: h.as === "button" ? "button" : void 0,
            "aria-controls": p(n).contentId,
            "aria-expanded": p(n).open.value || !1,
            "aria-required": (g = p(n).required) == null ? void 0 : g.value,
            "aria-autocomplete": "none",
            disabled: o.value,
            dir: (v = p(n)) == null ? void 0 : v.dir.value,
            "data-state": (y = p(n)) != null && y.open.value ? "open" : "closed",
            "data-disabled": o.value ? "" : void 0,
            "data-placeholder": p(w4)((x = p(n).modelValue) == null ? void 0 : x.value) ? "" : void 0,
            "as-child": h.asChild,
            as: h.as,
            onClick: m[0] || (m[0] = (C) => {
              var b;
              (b = C == null ? void 0 : C.currentTarget) == null || b.focus();
            }),
            onPointerdown: m[1] || (m[1] = (C) => {
              if (C.pointerType === "touch")
                return C.preventDefault();
              const b = C.target;
              b.hasPointerCapture(C.pointerId) && b.releasePointerCapture(C.pointerId), C.button === 0 && C.ctrlKey === !1 && (f(C), C.preventDefault());
            }),
            onPointerup: m[2] || (m[2] = yt(
              (C) => {
                C.pointerType === "touch" && f(C);
              },
              ["prevent"]
            )),
            onKeydown: m[3] || (m[3] = (C) => {
              const b = p(l) !== "";
              !(C.ctrlKey || C.altKey || C.metaKey) && C.key.length === 1 && b && C.key === " " || (p(c)(C.key), p(hP).includes(C.key) && (u(), C.preventDefault()));
            })
          }, {
            default: w(() => [
              D(h.$slots, "default")
            ]),
            _: 3
          }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "disabled", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])
        ];
      }),
      _: 3
    }));
  }
}), vP = /* @__PURE__ */ T({
  __name: "SelectPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(Ml), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [xg, yP] = Ve("SelectItemAlignedPosition"), bP = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["placed"],
  setup(t, { emit: e }) {
    const n = t, o = e, { injectCollection: r } = ho(), i = Mi(), s = Ti(), a = r(), l = O(!1), c = O(!0), d = O(), { forwardRef: u, currentElement: f } = X(), { viewport: h, selectedItem: m, selectedItemText: g, focusSelectedItem: v } = s;
    function y() {
      if (i.triggerElement.value && i.valueElement.value && d.value && f.value && h != null && h.value && m != null && m.value && g != null && g.value) {
        const b = i.triggerElement.value.getBoundingClientRect(), S = f.value.getBoundingClientRect(), A = i.valueElement.value.getBoundingClientRect(), I = g.value.getBoundingClientRect();
        if (i.dir.value !== "rtl") {
          const Ie = I.left - S.left, Ge = A.left - Ie, gt = b.left - Ge, We = b.width + gt, Ft = Math.max(We, S.width), mn = window.innerWidth - _o, Rn = ph(Ge, _o, mn - Ft);
          d.value.style.minWidth = `${We}px`, d.value.style.left = `${Rn}px`;
        } else {
          const Ie = S.right - I.right, Ge = window.innerWidth - A.right - Ie, gt = window.innerWidth - b.right - Ge, We = b.width + gt, Ft = Math.max(We, S.width), mn = window.innerWidth - _o, Rn = ph(
            Ge,
            _o,
            mn - Ft
          );
          d.value.style.minWidth = `${We}px`, d.value.style.right = `${Rn}px`;
        }
        const z = a.value, N = window.innerHeight - _o * 2, M = h.value.scrollHeight, $ = window.getComputedStyle(f.value), L = Number.parseInt(
          $.borderTopWidth,
          10
        ), Y = Number.parseInt($.paddingTop, 10), J = Number.parseInt(
          $.borderBottomWidth,
          10
        ), ne = Number.parseInt(
          $.paddingBottom,
          10
        ), F = L + Y + M + ne + J, R = Math.min(
          m.value.offsetHeight * 5,
          F
        ), H = window.getComputedStyle(h.value), K = Number.parseInt(H.paddingTop, 10), Q = Number.parseInt(
          H.paddingBottom,
          10
        ), Z = b.top + b.height / 2 - _o, ue = N - Z, Se = m.value.offsetHeight / 2, be = m.value.offsetTop + Se, we = L + Y + be, Re = F - we;
        if (we <= Z) {
          const Ie = m.value === z[z.length - 1];
          d.value.style.bottom = "0px";
          const Ge = f.value.clientHeight - h.value.offsetTop - h.value.offsetHeight, gt = Math.max(
            ue,
            Se + (Ie ? Q : 0) + Ge + J
          ), We = we + gt;
          d.value.style.height = `${We}px`;
        } else {
          const Ie = m.value === z[0];
          d.value.style.top = "0px";
          const Ge = Math.max(
            Z,
            L + h.value.offsetTop + (Ie ? K : 0) + Se
          ) + Re;
          d.value.style.height = `${Ge}px`, h.value.scrollTop = we - Z + h.value.offsetTop;
        }
        d.value.style.margin = `${_o}px 0`, d.value.style.minHeight = `${R}px`, d.value.style.maxHeight = `${N}px`, o("placed"), requestAnimationFrame(() => l.value = !0);
      }
    }
    const x = O("");
    _e(async () => {
      await qe(), y(), f.value && (x.value = window.getComputedStyle(f.value).zIndex);
    });
    function C(b) {
      b && c.value === !0 && (y(), v == null || v(), c.value = !1);
    }
    return yP({
      contentWrapper: d,
      shouldExpandOnScrollRef: l,
      onScrollButtonChange: C
    }), (b, S) => (k(), U("div", {
      ref_key: "contentWrapperElement",
      ref: d,
      style: ct({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: x.value
      })
    }, [
      E(p(se), j({
        ref: p(u),
        style: {
          // When we get the height of the content, it includes borders. If we were to set
          // the height without having `boxSizing: 'border-box'` it would be too big.
          boxSizing: "border-box",
          // We need to ensure the content doesn't get taller than the wrapper
          maxHeight: "100%"
        }
      }, { ...b.$attrs, ...n }), {
        default: w(() => [
          D(b.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])
    ], 4));
  }
}), wP = /* @__PURE__ */ T({
  __name: "SelectPopperPosition",
  props: {
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: { default: _o },
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = _t(t);
    return (n, o) => (k(), _(p(Ou), j(p(e), { style: {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-select-content-available-width": "var(--radix-popper-available-width)",
      "--radix-select-content-available-height": "var(--radix-popper-available-height)",
      "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), Ts = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, [Ti, xP] = Ve("SelectContent"), kP = /* @__PURE__ */ T({
  __name: "SelectContentImpl",
  props: {
    position: { default: "item-aligned" },
    bodyLock: { type: Boolean, default: !0 },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Mi();
    cg(), Eu(n.bodyLock);
    const { createCollection: i } = ho(), s = O();
    _u(s);
    const a = i(s), { search: l, handleTypeaheadSearch: c } = dg(a), d = O(), u = O(), f = O(), h = O(!1), m = O(!1);
    function g() {
      u.value && s.value && gh([u.value, s.value]);
    }
    ce(h, () => {
      g();
    });
    const { onOpenChange: v, triggerPointerDownPosRef: y } = r;
    Pe((S) => {
      if (!s.value)
        return;
      let A = { x: 0, y: 0 };
      const I = (N) => {
        var M, $;
        A = {
          x: Math.abs(
            Math.round(N.pageX) - (((M = y.value) == null ? void 0 : M.x) ?? 0)
          ),
          y: Math.abs(
            Math.round(N.pageY) - ((($ = y.value) == null ? void 0 : $.y) ?? 0)
          )
        };
      }, z = (N) => {
        var M;
        N.pointerType !== "touch" && (A.x <= 10 && A.y <= 10 ? N.preventDefault() : (M = s.value) != null && M.contains(N.target) || v(!1), document.removeEventListener("pointermove", I), y.value = null);
      };
      y.value !== null && (document.addEventListener("pointermove", I), document.addEventListener("pointerup", z, {
        capture: !0,
        once: !0
      })), S(() => {
        document.removeEventListener("pointermove", I), document.removeEventListener("pointerup", z, {
          capture: !0
        });
      });
    });
    function x(S) {
      const A = S.ctrlKey || S.altKey || S.metaKey;
      if (S.key === "Tab" && S.preventDefault(), !A && S.key.length === 1 && c(S.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(S.key)) {
        let I = a.value;
        if (["ArrowUp", "End"].includes(S.key) && (I = I.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(S.key)) {
          const z = S.target, N = I.indexOf(z);
          I = I.slice(N + 1);
        }
        setTimeout(() => gh(I)), S.preventDefault();
      }
    }
    const C = P(() => n.position === "popper" ? n : {}), b = _t(C.value);
    return xP({
      content: s,
      viewport: d,
      onViewportChange: (S) => {
        d.value = S;
      },
      itemRefCallback: (S, A, I) => {
        var z, N;
        const M = !m.value && !I;
        (((z = r.modelValue) == null ? void 0 : z.value) !== void 0 && ((N = r.modelValue) == null ? void 0 : N.value) === A || M) && (u.value = S, M && (m.value = !0));
      },
      selectedItem: u,
      selectedItemText: f,
      onItemLeave: () => {
        var S;
        (S = s.value) == null || S.focus();
      },
      itemTextRefCallback: (S, A, I) => {
        var z, N;
        const M = !m.value && !I;
        (((z = r.modelValue) == null ? void 0 : z.value) !== void 0 && ((N = r.modelValue) == null ? void 0 : N.value) === A || M) && (f.value = S);
      },
      focusSelectedItem: g,
      position: n.position,
      isPositioned: h,
      searchRef: l
    }), (S, A) => (k(), _(p(Mu), {
      "as-child": "",
      onMountAutoFocus: A[6] || (A[6] = yt(() => {
      }, ["prevent"])),
      onUnmountAutoFocus: A[7] || (A[7] = (I) => {
        var z;
        o("closeAutoFocus", I), !I.defaultPrevented && ((z = p(r).triggerElement.value) == null || z.focus({ preventScroll: !0 }), I.preventDefault());
      })
    }, {
      default: w(() => [
        E(p(Tl), {
          "as-child": "",
          "disable-outside-pointer-events": "",
          onFocusOutside: A[2] || (A[2] = yt(() => {
          }, ["prevent"])),
          onDismiss: A[3] || (A[3] = (I) => p(r).onOpenChange(!1)),
          onEscapeKeyDown: A[4] || (A[4] = (I) => o("escapeKeyDown", I)),
          onPointerDownOutside: A[5] || (A[5] = (I) => o("pointerDownOutside", I))
        }, {
          default: w(() => [
            (k(), _(_n(
              S.position === "popper" ? wP : bP
            ), j({ ...S.$attrs, ...p(b) }, {
              id: p(r).contentId,
              ref: (I) => {
                s.value = p(fn)(I);
              },
              role: "listbox",
              "data-state": p(r).open.value ? "open" : "closed",
              dir: p(r).dir.value,
              style: {
                // flex layout so we can place the scroll buttons properly
                display: "flex",
                flexDirection: "column",
                // reset the outline by default as the content MAY get focused
                outline: "none"
              },
              onContextmenu: A[0] || (A[0] = yt(() => {
              }, ["prevent"])),
              onPlaced: A[1] || (A[1] = (I) => h.value = !0),
              onKeydown: x
            }), {
              default: w(() => [
                D(S.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "dir", "onKeydown"]))
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), CP = /* @__PURE__ */ T({
  __name: "SelectProvider",
  props: {
    context: {}
  },
  setup(t) {
    return b4(t.context), (e, n) => D(e.$slots, "default");
  }
}), SP = { key: 1 }, AP = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = De(n, e), r = Mi(), i = O();
    _e(() => {
      i.value = new DocumentFragment();
    });
    const s = O(), a = P(() => n.forceMount || r.open.value);
    return (l, c) => {
      var d;
      return a.value ? (k(), _(p(hn), {
        key: 0,
        ref_key: "presenceRef",
        ref: s,
        present: !0
      }, {
        default: w(() => [
          E(kP, Oe(Le({ ...p(o), ...l.$attrs })), {
            default: w(() => [
              D(l.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 512)) : !((d = s.value) != null && d.present) && i.value ? (k(), U("div", SP, [
        (k(), _(gl, { to: i.value }, [
          E(CP, { context: p(r) }, {
            default: w(() => [
              D(l.$slots, "default")
            ]),
            _: 3
          }, 8, ["context"])
        ], 8, ["to"]))
      ])) : ae("", !0);
    };
  }
}), EP = /* @__PURE__ */ T({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(se), j({ "aria-hidden": "" }, e), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [x4, _P] = Ve("SelectItem"), MP = /* @__PURE__ */ T({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { disabled: n } = mt(e), o = Mi(), r = Ti(Ts), { forwardRef: i, currentElement: s } = X(), a = P(() => {
      var g;
      return ((g = o.modelValue) == null ? void 0 : g.value) === e.value;
    }), l = O(!1), c = O(e.textValue ?? ""), d = At(void 0, "radix-vue-select-item-text");
    async function u(g) {
      await qe(), !(g != null && g.defaultPrevented) && (n.value || (o.onValueChange(e.value), o.onOpenChange(!1)));
    }
    async function f(g) {
      var v;
      await qe(), !g.defaultPrevented && (n.value ? (v = r.onItemLeave) == null || v.call(r) : g.currentTarget.focus({ preventScroll: !0 }));
    }
    async function h(g) {
      var v;
      await qe(), !g.defaultPrevented && g.currentTarget === document.activeElement && ((v = r.onItemLeave) == null || v.call(r));
    }
    async function m(g) {
      var v;
      await qe(), !(g.defaultPrevented || ((v = r.searchRef) == null ? void 0 : v.value) !== "" && g.key === " ") && (mP.includes(g.key) && u(), g.key === " " && g.preventDefault());
    }
    if (e.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return _e(() => {
      s.value && r.itemRefCallback(
        s.value,
        e.value,
        e.disabled
      );
    }), _P({
      value: e.value,
      disabled: n,
      textId: d,
      isSelected: a,
      onItemTextChange: (g) => {
        c.value = ((c.value || (g == null ? void 0 : g.textContent)) ?? "").trim();
      }
    }), (g, v) => (k(), _(p(se), {
      ref: p(i),
      role: "option",
      "data-radix-vue-collection-item": "",
      "aria-labelledby": p(d),
      "data-highlighted": l.value ? "" : void 0,
      "aria-selected": a.value && l.value,
      "data-state": a.value ? "checked" : "unchecked",
      "aria-disabled": p(n) || void 0,
      "data-disabled": p(n) ? "" : void 0,
      tabindex: p(n) ? void 0 : -1,
      as: g.as,
      "as-child": g.asChild,
      onFocus: v[0] || (v[0] = (y) => l.value = !0),
      onBlur: v[1] || (v[1] = (y) => l.value = !1),
      onPointerup: u,
      onPointerdown: v[2] || (v[2] = (y) => {
        y.currentTarget.focus({ preventScroll: !0 });
      }),
      onTouchend: v[3] || (v[3] = yt(() => {
      }, ["prevent", "stop"])),
      onPointermove: f,
      onPointerleave: h,
      onKeydown: m
    }, {
      default: w(() => [
        D(g.$slots, "default")
      ]),
      _: 3
    }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"]));
  }
}), TP = /* @__PURE__ */ T({
  __name: "SelectItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const e = t, n = x4();
    return (o, r) => p(n).isSelected.value ? (k(), _(p(se), j({
      key: 0,
      "aria-hidden": ""
    }, e), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16)) : ae("", !0);
  }
}), [aJ, OP] = Ve("SelectGroup"), IP = /* @__PURE__ */ T({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = At(void 0, "radix-vue-select-group");
    return OP({ id: n }), (o, r) => (k(), _(p(se), j({ role: "group" }, e, { "aria-labelledby": p(n) }), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), DP = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const e = t, n = Mi(), o = Ti(Ts), r = uP(), i = x4(), { forwardRef: s, currentElement: a } = X(), l = P(() => {
      var c;
      return jt("option", {
        key: i.value,
        value: i.value,
        disabled: i.disabled.value,
        innerHTML: (c = a.value) == null ? void 0 : c.textContent
      });
    });
    return _e(() => {
      a.value && (i.onItemTextChange(a.value), o.itemTextRefCallback(
        a.value,
        i.value,
        i.disabled.value
      ), r.onNativeOptionAdd(l.value));
    }), jo(() => {
      r.onNativeOptionRemove(l.value);
    }), (c, d) => (k(), U(ve, null, [
      E(p(se), j({
        id: p(i).textId,
        ref: p(s)
      }, { ...e, ...c.$attrs }), {
        default: w(() => [
          D(c.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]),
      p(i).isSelected.value && p(n).valueElement.value && !p(n).valueElementHasChildren.value ? (k(), _(gl, {
        key: 0,
        to: p(n).valueElement.value
      }, [
        D(c.$slots, "default")
      ], 8, ["to"])) : ae("", !0)
    ], 64));
  }
}), RP = /* @__PURE__ */ T({
  __name: "SelectViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = Ti(Ts), o = n.position === "item-aligned" ? xg() : void 0, { forwardRef: r, currentElement: i } = X();
    _e(() => {
      n == null || n.onViewportChange(i.value);
    });
    const s = O(0);
    function a(l) {
      const c = l.currentTarget, { shouldExpandOnScrollRef: d, contentWrapper: u } = o ?? {};
      if (d != null && d.value && u != null && u.value) {
        const f = Math.abs(s.value - c.scrollTop);
        if (f > 0) {
          const h = window.innerHeight - _o * 2, m = Number.parseFloat(
            u.value.style.minHeight
          ), g = Number.parseFloat(u.value.style.height), v = Math.max(m, g);
          if (v < h) {
            const y = v + f, x = Math.min(h, y), C = y - x;
            u.value.style.height = `${x}px`, u.value.style.bottom === "0px" && (c.scrollTop = C > 0 ? C : 0, u.value.style.justifyContent = "flex-end");
          }
        }
      }
      s.value = c.scrollTop;
    }
    return (l, c) => (k(), U(ve, null, [
      E(p(se), j({
        ref: p(r),
        "data-radix-select-viewport": "",
        role: "presentation"
      }, { ...l.$attrs, ...e }, {
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto"
        },
        onScroll: a
      }), {
        default: w(() => [
          D(l.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"]),
      E(p(se), {
        as: "style",
        nonce: l.nonce
      }, {
        default: w(() => [
          he(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      }, 8, ["nonce"])
    ], 64));
  }
}), k4 = /* @__PURE__ */ T({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(t, { emit: e }) {
    const n = e, { injectCollection: o } = ho(), r = o(), i = Ti(Ts), s = O(null);
    function a() {
      s.value !== null && (window.clearInterval(s.value), s.value = null);
    }
    Pe(() => {
      const d = r.value.find(
        (u) => u === document.activeElement
      );
      d == null || d.scrollIntoView({ block: "nearest" });
    });
    function l() {
      s.value === null && (s.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    function c() {
      var d;
      (d = i.onItemLeave) == null || d.call(i), s.value === null && (s.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    return jo(() => a()), (d, u) => {
      var f;
      return k(), _(p(se), j({
        "aria-hidden": "",
        style: {
          flexShrink: 0
        }
      }, (f = d.$parent) == null ? void 0 : f.$props, {
        onPointerdown: l,
        onPointermove: c,
        onPointerleave: u[0] || (u[0] = () => {
          a();
        })
      }), {
        default: w(() => [
          D(d.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
}), PP = /* @__PURE__ */ T({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = Ti(Ts), n = e.position === "item-aligned" ? xg() : void 0, { forwardRef: o, currentElement: r } = X(), i = O(!1);
    return Pe((s) => {
      var a, l;
      if ((a = e.viewport) != null && a.value && (l = e.isPositioned) != null && l.value) {
        let c = function() {
          i.value = d.scrollTop > 0;
        };
        const d = e.viewport.value;
        c(), d.addEventListener("scroll", c), s(() => d.removeEventListener("scroll", c));
      }
    }), ce(r, () => {
      r.value && (n == null || n.onScrollButtonChange(r.value));
    }), (s, a) => i.value ? (k(), _(k4, {
      key: 0,
      ref: p(o),
      onAutoScroll: a[0] || (a[0] = () => {
        const { viewport: l, selectedItem: c } = p(e);
        l != null && l.value && c != null && c.value && (l.value.scrollTop = l.value.scrollTop - c.value.offsetHeight);
      })
    }, {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 512)) : ae("", !0);
  }
}), LP = /* @__PURE__ */ T({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = Ti(Ts), n = e.position === "item-aligned" ? xg() : void 0, { forwardRef: o, currentElement: r } = X(), i = O(!1);
    return Pe((s) => {
      var a, l;
      if ((a = e.viewport) != null && a.value && (l = e.isPositioned) != null && l.value) {
        let c = function() {
          const u = d.scrollHeight - d.clientHeight;
          i.value = Math.ceil(d.scrollTop) < u;
        };
        const d = e.viewport.value;
        c(), d.addEventListener("scroll", c), s(() => d.removeEventListener("scroll", c));
      }
    }), ce(r, () => {
      r.value && (n == null || n.onScrollButtonChange(r.value));
    }), (s, a) => i.value ? (k(), _(k4, {
      key: 0,
      ref: p(o),
      onAutoScroll: a[0] || (a[0] = () => {
        const { viewport: l, selectedItem: c } = p(e);
        l != null && l.value && c != null && c.value && (l.value.scrollTop = l.value.scrollTop + c.value.offsetHeight);
      })
    }, {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 512)) : ae("", !0);
  }
}), NP = /* @__PURE__ */ T({
  __name: "SelectValue",
  props: {
    placeholder: { default: "" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    const { forwardRef: e, currentElement: n } = X(), o = Mi(), r = Tb();
    return r8(() => {
      var i;
      const s = !!Au((i = r == null ? void 0 : r.default) == null ? void 0 : i.call(r)).length;
      o.onValueElementHasChildrenChange(s);
    }), _e(() => {
      o.valueElement = n;
    }), (i, s) => (k(), _(p(se), {
      ref: p(e),
      as: i.as,
      "as-child": i.asChild,
      style: { pointerEvents: "none" }
    }, {
      default: w(() => {
        var a;
        return [
          p(w4)((a = p(o).modelValue) == null ? void 0 : a.value) ? (k(), U(ve, { key: 0 }, [
            he(q(i.placeholder), 1)
          ], 64)) : D(i.$slots, "default", { key: 1 })
        ];
      }),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), BP = /* @__PURE__ */ T({
  __name: "SelectIcon",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(t) {
    return (e, n) => (k(), _(p(se), {
      "aria-hidden": "",
      as: e.as,
      "as-child": e.asChild
    }, {
      default: w(() => [
        D(e.$slots, "default", {}, () => [
          he("▼")
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), $P = /* @__PURE__ */ T({
  __name: "BaseSeparator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, n = ["horizontal", "vertical"];
    function o(a) {
      return n.includes(a);
    }
    const r = P(
      () => o(e.orientation) ? e.orientation : "horizontal"
    ), i = P(
      () => r.value === "vertical" ? e.orientation : void 0
    ), s = P(
      () => e.decorative ? { role: "none" } : { "aria-orientation": i.value, role: "separator" }
    );
    return (a, l) => (k(), _(p(se), j({
      as: a.as,
      "as-child": a.asChild,
      "data-orientation": r.value
    }, s.value), {
      default: w(() => [
        D(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "data-orientation"]));
  }
}), zP = /* @__PURE__ */ T({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _($P, Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
let bh = null, ti = null;
function FP(t, e) {
  if (e) {
    const n = (e & M4) !== 0, o = (e & T4) !== 0, r = (e & O4) !== 0, i = (e & I4) !== 0;
    if (n)
      return r ? "se-resize" : i ? "ne-resize" : "e-resize";
    if (o)
      return r ? "sw-resize" : i ? "nw-resize" : "w-resize";
    if (r)
      return "s-resize";
    if (i)
      return "n-resize";
  }
  switch (t) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function HP() {
  ti !== null && (document.head.removeChild(ti), bh = null, ti = null);
}
function Vf(t, e) {
  const n = FP(t, e);
  bh !== n && (bh = n, ti === null && (ti = document.createElement("style"), document.head.appendChild(ti)), ti.innerHTML = `*{cursor: ${n}!important;}`);
}
function VP({
  defaultSize: t,
  dragState: e,
  layout: n,
  panelData: o,
  panelIndex: r,
  precision: i = 3
}) {
  const s = n[r];
  let a;
  return s == null ? a = t !== void 0 ? t.toPrecision(i) : "1" : o.length === 1 ? a = "1" : a = s.toPrecision(i), {
    flexBasis: 0,
    flexGrow: a,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: e !== null ? "none" : void 0
  };
}
function C4(t) {
  return t.type === "keydown";
}
function S4(t) {
  return t.type.startsWith("mouse");
}
function A4(t) {
  return t.type.startsWith("touch");
}
function Nu(t) {
  if (S4(t))
    return {
      x: t.clientX,
      y: t.clientY
    };
  if (A4(t)) {
    const e = t.touches[0];
    if (e && e.clientX && e.clientY)
      return {
        x: e.clientX,
        y: e.clientY
      };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function E4(t, e) {
  const n = t === "horizontal", { x: o, y: r } = Nu(e);
  return n ? o : r;
}
function jP(t, e, n) {
  return t.x < e.x + e.width && t.x + t.width > e.x && t.y < e.y + e.height && t.y + t.height > e.y;
}
function Me(t, e = "Assertion failed!") {
  if (!t)
    throw console.error(e), new Error(e);
}
function UP(t, e) {
  if (t === e)
    throw new Error("Cannot compare node with itself");
  const n = {
    a: Bv(t),
    b: Bv(e)
  };
  let o;
  for (; n.a.at(-1) === n.b.at(-1); )
    t = n.a.pop(), e = n.b.pop(), o = t;
  Me(o);
  const r = {
    a: Nv(Lv(n.a)),
    b: Nv(Lv(n.b))
  };
  if (r.a === r.b) {
    const i = o.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let a = i.length;
    for (; a--; ) {
      const l = i[a];
      if (l === s.a)
        return 1;
      if (l === s.b)
        return -1;
    }
  }
  return Math.sign(r.a - r.b);
}
const WP = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function KP(t) {
  const e = getComputedStyle(_4(t)).display;
  return e === "flex" || e === "inline-flex";
}
function qP(t) {
  const e = getComputedStyle(t);
  return !!(e.position === "fixed" || e.zIndex !== "auto" && (e.position !== "static" || KP(t)) || +e.opacity < 1 || "transform" in e && e.transform !== "none" || "webkitTransform" in e && e.webkitTransform !== "none" || "mixBlendMode" in e && e.mixBlendMode !== "normal" || "filter" in e && e.filter !== "none" || "webkitFilter" in e && e.webkitFilter !== "none" || "isolation" in e && e.isolation === "isolate" || WP.test(e.willChange) || e.webkitOverflowScrolling === "touch");
}
function Lv(t) {
  let e = t.length;
  for (; e--; ) {
    const n = t[e];
    if (Me(n), qP(n))
      return n;
  }
  return null;
}
function Nv(t) {
  return t && Number(getComputedStyle(t).zIndex) || 0;
}
function Bv(t) {
  const e = [];
  for (; t; )
    e.push(t), t = _4(t);
  return e;
}
function _4(t) {
  var e;
  return ((e = t.parentNode) == null ? void 0 : e.host) || t.parentNode;
}
const M4 = 1, T4 = 2, O4 = 4, I4 = 8;
function GP() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const JP = GP() === "coarse", Dr = [];
let Bu = !1;
const ur = /* @__PURE__ */ new Map(), $u = /* @__PURE__ */ new Map(), Ya = /* @__PURE__ */ new Set();
function YP(t, e, n, o, r) {
  const { ownerDocument: i } = e, s = {
    direction: n,
    element: e,
    hitAreaMargins: o,
    setResizeHandlerState: r
  }, a = ur.get(i) ?? 0;
  return ur.set(i, a + 1), Ya.add(s), hd(), function() {
    $u.delete(t), Ya.delete(s);
    const l = ur.get(i) ?? 1;
    ur.set(i, l - 1), hd(), l === 1 && ur.delete(i);
  };
}
function rc(t) {
  const { target: e } = t, { x: n, y: o } = Nu(t);
  Bu = !0, kg({ target: e, x: n, y: o }), hd(), Dr.length > 0 && (Cg("down", t), t.preventDefault());
}
function Qo(t) {
  const { x: e, y: n } = Nu(t);
  if (!Bu) {
    const { target: o } = t;
    kg({ target: o, x: e, y: n });
  }
  Cg("move", t), D4(), Dr.length > 0 && t.preventDefault();
}
function er(t) {
  const { target: e } = t, { x: n, y: o } = Nu(t);
  $u.clear(), Bu = !1, Dr.length > 0 && t.preventDefault(), Cg("up", t), kg({ target: e, x: n, y: o }), D4(), hd();
}
function kg({
  target: t,
  x: e,
  y: n
}) {
  Dr.splice(0);
  let o = null;
  t instanceof HTMLElement && (o = t), Ya.forEach((r) => {
    const { element: i, hitAreaMargins: s } = r, a = i.getBoundingClientRect(), { bottom: l, left: c, right: d, top: u } = a, f = JP ? s.coarse : s.fine;
    if (e >= c - f && e <= d + f && n >= u - f && n <= l + f) {
      if (o !== null && i !== o && !i.contains(o) && !o.contains(i) && UP(o, i) > 0) {
        let h = o, m = !1;
        for (; h && !h.contains(i); ) {
          if (jP(
            h.getBoundingClientRect(),
            a
          )) {
            m = !0;
            break;
          }
          h = h.parentElement;
        }
        if (m)
          return;
      }
      Dr.push(r);
    }
  });
}
function jf(t, e) {
  $u.set(t, e);
}
function D4() {
  let t = !1, e = !1;
  Dr.forEach((o) => {
    const { direction: r } = o;
    r === "horizontal" ? t = !0 : e = !0;
  });
  let n = 0;
  $u.forEach((o) => {
    n |= o;
  }), t && e ? Vf("intersection", n) : t ? Vf("horizontal", n) : e ? Vf("vertical", n) : HP();
}
function hd() {
  ur.forEach((t, e) => {
    const { body: n } = e;
    n.removeEventListener("contextmenu", er), n.removeEventListener("mousedown", rc), n.removeEventListener("mouseleave", Qo), n.removeEventListener("mousemove", Qo), n.removeEventListener("touchmove", Qo), n.removeEventListener("touchstart", rc);
  }), window.removeEventListener("mouseup", er), window.removeEventListener("touchcancel", er), window.removeEventListener("touchend", er), Ya.size > 0 && (Bu ? (Dr.length > 0 && ur.forEach((t, e) => {
    const { body: n } = e;
    t > 0 && (n.addEventListener("contextmenu", er), n.addEventListener("mouseleave", Qo), n.addEventListener("mousemove", Qo), n.addEventListener("touchmove", Qo, {
      passive: !1
    }));
  }), window.addEventListener("mouseup", er), window.addEventListener("touchcancel", er), window.addEventListener("touchend", er)) : ur.forEach((t, e) => {
    const { body: n } = e;
    t > 0 && (n.addEventListener("mousedown", rc), n.addEventListener("mousemove", Qo), n.addEventListener("touchmove", Qo, {
      passive: !1
    }), n.addEventListener("touchstart", rc));
  }));
}
function Cg(t, e) {
  Ya.forEach((n) => {
    const { setResizeHandlerState: o } = n, r = Dr.includes(n);
    o(t, r, e);
  });
}
const R4 = 10;
function Xa(t, e, n = R4) {
  t = Number.parseFloat(t.toFixed(n)), e = Number.parseFloat(e.toFixed(n));
  const o = t - e;
  return o === 0 ? 0 : o > 0 ? 1 : -1;
}
function on(t, e, n) {
  return Xa(t, e, n) === 0;
}
function Yi({
  panelConstraints: t,
  panelIndex: e,
  size: n
}) {
  const o = t[e];
  Me(o != null);
  const { collapsedSize: r = 0, collapsible: i, maxSize: s = 100, minSize: a = 0 } = o;
  if (Xa(n, a) < 0)
    if (i) {
      const l = (r + a) / 2;
      Xa(n, l) < 0 ? n = r : n = a;
    } else
      n = a;
  return n = Math.min(s, n), n = Number.parseFloat(n.toFixed(R4)), n;
}
function ic(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function ra({
  delta: t,
  layout: e,
  panelConstraints: n,
  pivotIndices: o,
  trigger: r
}) {
  if (on(t, 0))
    return e;
  const i = [...e], [s, a] = o;
  Me(s != null), Me(a != null);
  let l = 0;
  if (r === "keyboard") {
    {
      const d = t < 0 ? a : s, u = n[d];
      if (Me(u), u.collapsible) {
        const f = e[d];
        Me(f != null);
        const h = n[d];
        Me(h);
        const { collapsedSize: m = 0, minSize: g = 0 } = h;
        if (on(f, m)) {
          const v = g - f;
          Xa(v, Math.abs(t)) > 0 && (t = t < 0 ? 0 - v : v);
        }
      }
    }
    {
      const d = t < 0 ? s : a, u = n[d];
      Me(u);
      const { collapsible: f } = u;
      if (f) {
        const h = e[d];
        Me(h != null);
        const m = n[d];
        Me(m);
        const { collapsedSize: g = 0, minSize: v = 0 } = m;
        if (on(h, v)) {
          const y = h - g;
          Xa(y, Math.abs(t)) > 0 && (t = t < 0 ? 0 - y : y);
        }
      }
    }
  }
  {
    const d = t < 0 ? 1 : -1;
    let u = t < 0 ? a : s, f = 0;
    for (; ; ) {
      const m = e[u];
      Me(m != null);
      const g = Yi({
        panelConstraints: n,
        panelIndex: u,
        size: 100
      }) - m;
      if (f += g, u += d, u < 0 || u >= n.length)
        break;
    }
    const h = Math.min(Math.abs(t), Math.abs(f));
    t = t < 0 ? 0 - h : h;
  }
  {
    let d = t < 0 ? s : a;
    for (; d >= 0 && d < n.length; ) {
      const u = Math.abs(t) - Math.abs(l), f = e[d];
      Me(f != null);
      const h = f - u, m = Yi({
        panelConstraints: n,
        panelIndex: d,
        size: h
      });
      if (!on(f, m) && (l += f - m, i[d] = m, l.toPrecision(3).localeCompare(Math.abs(t).toPrecision(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      t < 0 ? d-- : d++;
    }
  }
  if (on(l, 0))
    return e;
  {
    const d = t < 0 ? a : s, u = e[d];
    Me(u != null);
    const f = u + l, h = Yi({
      panelConstraints: n,
      panelIndex: d,
      size: f
    });
    if (i[d] = h, !on(h, f)) {
      let m = f - h, g = t < 0 ? a : s;
      for (; g >= 0 && g < n.length; ) {
        const v = i[g];
        Me(v != null);
        const y = v + m, x = Yi({
          panelConstraints: n,
          panelIndex: g,
          size: y
        });
        if (on(v, x) || (m -= x - v, i[g] = x), on(m, 0))
          break;
        t > 0 ? g-- : g++;
      }
    }
  }
  const c = i.reduce((d, u) => u + d, 0);
  return on(c, 100) ? i : e;
}
function P4(t, e = document) {
  var n;
  return _l ? e instanceof HTMLElement && ((n = e == null ? void 0 : e.dataset) == null ? void 0 : n.panelGroupId) === t ? e : e.querySelector(
    `[data-panel-group][data-panel-group-id="${t}"]`
  ) || null : null;
}
function zu(t, e = document) {
  return _l && e.querySelector(`[data-panel-resize-handle-id="${t}"]`) || null;
}
function L4(t, e, n = document) {
  return _l ? Za(t, n).findIndex(
    (o) => o.getAttribute("data-panel-resize-handle-id") === e
  ) ?? null : null;
}
function Za(t, e = document) {
  return _l ? Array.from(
    e.querySelectorAll(
      `[data-panel-resize-handle-id][data-panel-group-id="${t}"]`
    )
  ) : [];
}
function XP(t, e, n, o = document) {
  var r, i;
  const s = zu(e, o), a = Za(t, o), l = s ? a.indexOf(s) : -1, c = ((r = n[l]) == null ? void 0 : r.id) ?? null, d = ((i = n[l + 1]) == null ? void 0 : i.id) ?? null;
  return [c, d];
}
function ZP(t, e, n, o, r) {
  const i = n === "horizontal", s = zu(e, r);
  Me(s);
  const a = s.getAttribute("data-panel-group-id");
  Me(a);
  const { initialCursorPosition: l } = o, c = E4(n, t), d = P4(a, r);
  Me(d);
  const u = d.getBoundingClientRect(), f = i ? u.width : u.height;
  return (c - l) / f * 100;
}
function QP(t, e, n, o, r, i) {
  if (C4(t)) {
    const s = n === "horizontal";
    let a = 0;
    t.shiftKey ? a = 100 : a = r ?? 10;
    let l = 0;
    switch (t.key) {
      case "ArrowDown":
        l = s ? 0 : a;
        break;
      case "ArrowLeft":
        l = s ? -a : 0;
        break;
      case "ArrowRight":
        l = s ? a : 0;
        break;
      case "ArrowUp":
        l = s ? 0 : -a;
        break;
      case "End":
        l = 100;
        break;
      case "Home":
        l = -100;
        break;
    }
    return l;
  } else
    return o == null ? 0 : ZP(
      t,
      e,
      n,
      o,
      i
    );
}
function eL({
  layout: t,
  panelsArray: e,
  pivotIndices: n
}) {
  let o = 0, r = 100, i = 0, s = 0;
  const a = n[0];
  Me(a != null), e.forEach((u, f) => {
    const { constraints: h } = u, { maxSize: m = 100, minSize: g = 0 } = h;
    f === a ? (o = g, r = m) : (i += g, s += m);
  });
  const l = Math.min(r, 100 - i), c = Math.max(o, 100 - s), d = t[a];
  return {
    valueMax: l,
    valueMin: c,
    valueNow: d
  };
}
function tL({
  panelDataArray: t
}) {
  const e = Array(t.length), n = t.map(
    (i) => i.constraints
  );
  let o = 0, r = 100;
  for (let i = 0; i < t.length; i++) {
    const s = n[i];
    Me(s);
    const { defaultSize: a } = s;
    a != null && (o++, e[i] = a, r -= a);
  }
  for (let i = 0; i < t.length; i++) {
    const s = n[i];
    Me(s);
    const { defaultSize: a } = s;
    if (a != null)
      continue;
    const l = t.length - o, c = r / l;
    o++, e[i] = c, r -= c;
  }
  return e;
}
function Ys(t, e, n) {
  e.forEach((o, r) => {
    const i = t[r];
    Me(i);
    const { callbacks: s, constraints: a, id: l } = i, { collapsedSize: c = 0, collapsible: d } = a, u = n[l];
    if (u == null || o !== u) {
      n[l] = o;
      const { onCollapse: f, onExpand: h, onResize: m } = s;
      m && m(o, u), d && (f || h) && (h && (u == null || u === c) && o !== c && h(), f && (u == null || u !== c) && o === c && f());
    }
  });
}
function nL(t, e = 10) {
  let n = null;
  return (...o) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      t(...o);
    }, e);
  };
}
function N4(t, e, n) {
  const o = L4(
    t,
    e,
    n
  );
  return o != null ? [o, o + 1] : [-1, -1];
}
function oL({
  layout: t,
  panelConstraints: e
}) {
  const n = [...t], o = n.reduce(
    (i, s) => i + s,
    0
  );
  if (n.length !== e.length)
    throw new Error(
      `Invalid ${e.length} panel layout: ${n.map((i) => `${i}%`).join(", ")}`
    );
  if (!on(o, 100)) {
    console.warn(
      `WARNING: Invalid layout total size: ${n.map((i) => `${i}%`).join(", ")}. Layout normalization will be applied.`
    );
    for (let i = 0; i < e.length; i++) {
      const s = n[i];
      Me(s != null);
      const a = 100 / o * s;
      n[i] = a;
    }
  }
  let r = 0;
  for (let i = 0; i < e.length; i++) {
    const s = n[i];
    Me(s != null);
    const a = Yi({
      panelConstraints: e,
      panelIndex: i,
      size: s
    });
    s !== a && (r += s - a, n[i] = a);
  }
  if (!on(r, 0))
    for (let i = 0; i < e.length; i++) {
      const s = n[i];
      Me(s != null);
      const a = s + r, l = Yi({
        panelConstraints: e,
        panelIndex: i,
        size: a
      });
      if (s !== l && (r -= l - s, n[i] = l, on(r, 0)))
        break;
    }
  return n;
}
function $v(t) {
  try {
    if (typeof localStorage < "u")
      t.getItem = (e) => localStorage.getItem(e), t.setItem = (e, n) => {
        localStorage.setItem(e, n);
      };
    else
      throw new TypeError("localStorage not supported in this environment");
  } catch (e) {
    console.error(e), t.getItem = () => null, t.setItem = () => {
    };
  }
}
function B4(t) {
  return `radix-vue:${t}`;
}
function $4(t) {
  return t.map((e) => {
    const { constraints: n, id: o, idIsFromProps: r, order: i } = e;
    return r ? o : i ? `${i}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((e, n) => e.localeCompare(n)).join(",");
}
function z4(t, e) {
  try {
    const n = B4(t), o = e.getItem(n);
    if (o) {
      const r = JSON.parse(o);
      if (typeof r == "object" && r != null)
        return r;
    }
  } catch {
  }
  return null;
}
function rL(t, e, n) {
  const o = z4(t, n) ?? {}, r = $4(e);
  return o[r] ?? null;
}
function iL(t, e, n, o, r) {
  const i = B4(t), s = $4(e), a = z4(t, r) ?? {};
  a[s] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: o
  };
  try {
    r.setItem(i, JSON.stringify(a));
  } catch (l) {
    console.error(l);
  }
}
function sL({
  eagerValuesRef: t,
  groupId: e,
  layout: n,
  panelDataArray: o,
  panelGroupElement: r,
  setLayout: i
}) {
  Pe((s) => {
    const a = r.value;
    if (!a)
      return;
    const l = Za(
      e,
      a
    );
    for (let c = 0; c < o.length - 1; c++) {
      const { valueMax: d, valueMin: u, valueNow: f } = eL({
        layout: n.value,
        panelsArray: o,
        pivotIndices: [c, c + 1]
      }), h = l[c];
      if (h != null) {
        const m = o[c];
        Me(m), h.setAttribute("aria-controls", m.id), h.setAttribute(
          "aria-valuemax",
          `${Math.round(d)}`
        ), h.setAttribute(
          "aria-valuemin",
          `${Math.round(u)}`
        ), h.setAttribute(
          "aria-valuenow",
          f != null ? `${Math.round(f)}` : ""
        );
      }
    }
    s(() => {
      l.forEach((c) => {
        c.removeAttribute("aria-controls"), c.removeAttribute("aria-valuemax"), c.removeAttribute("aria-valuemin"), c.removeAttribute("aria-valuenow");
      });
    });
  }), Pe((s) => {
    const a = r.value;
    if (!a)
      return;
    const l = t.value;
    Me(l);
    const { panelDataArray: c } = l, d = P4(e, a);
    Me(d != null, `No group found for id "${e}"`);
    const u = Za(e, a);
    Me(u);
    const f = u.map((h) => {
      const m = h.getAttribute("data-panel-resize-handle-id");
      Me(m);
      const [g, v] = XP(
        e,
        m,
        c,
        a
      );
      if (g == null || v == null)
        return () => {
        };
      const y = (x) => {
        if (!x.defaultPrevented)
          switch (x.key) {
            case "Enter": {
              x.preventDefault();
              const C = c.findIndex(
                (b) => b.id === g
              );
              if (C >= 0) {
                const b = c[C];
                Me(b);
                const S = n.value[C], {
                  collapsedSize: A = 0,
                  collapsible: I,
                  minSize: z = 0
                } = b.constraints;
                if (S != null && I) {
                  const N = ra({
                    delta: on(S, A) ? z - A : A - S,
                    layout: n.value,
                    panelConstraints: c.map(
                      (M) => M.constraints
                    ),
                    pivotIndices: N4(
                      e,
                      m,
                      a
                    ),
                    trigger: "keyboard"
                  });
                  n.value !== N && i(N);
                }
              }
              break;
            }
          }
      };
      return h.addEventListener("keydown", y), () => {
        h.removeEventListener("keydown", y);
      };
    });
    s(() => {
      f.forEach((h) => h());
    });
  });
}
const aL = 100, ia = {
  getItem: (t) => ($v(ia), ia.getItem(t)),
  setItem: (t, e) => {
    $v(ia), ia.setItem(t, e);
  }
}, [F4, lL] = Ve("PanelGroup"), cL = /* @__PURE__ */ T({
  __name: "SplitterGroup",
  props: {
    id: {},
    autoSaveId: { default: null },
    direction: {},
    keyboardResizeBy: { default: 10 },
    storage: { default: () => ia },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["layout"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = {}, i = At(n.id, "radix-vue-splitter-group"), s = qo(), { forwardRef: a, currentElement: l } = X(), c = O(null), d = O([]), u = O({}), f = O(/* @__PURE__ */ new Map()), h = O(0), m = P(() => ({
      autoSaveId: n.autoSaveId,
      direction: n.direction,
      dragState: c.value,
      id: i,
      keyboardResizeBy: n.keyboardResizeBy,
      storage: n.storage
    })), g = O({
      layout: d.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), v = (F) => d.value = F;
    sL({
      eagerValuesRef: g,
      groupId: i,
      layout: d,
      panelDataArray: g.value.panelDataArray,
      setLayout: v,
      panelGroupElement: l
    }), Pe(() => {
      const { panelDataArray: F } = g.value, { autoSaveId: R } = n;
      if (R) {
        if (d.value.length === 0 || d.value.length !== F.length)
          return;
        let H = r[R];
        H || (H = nL(
          iL,
          aL
        ), r[R] = H);
        const K = [...F], Q = new Map(
          f.value
        );
        H(
          R,
          K,
          Q,
          d.value,
          n.storage
        );
      }
    });
    function y(F, R) {
      const { panelDataArray: H } = g.value, K = J(H, F);
      return VP({
        defaultSize: R,
        dragState: c.value,
        layout: d.value,
        panelData: H,
        panelIndex: K
      });
    }
    function x(F) {
      const { panelDataArray: R } = g.value;
      R.push(F), R.sort((H, K) => {
        const Q = H.order, Z = K.order;
        return Q == null && Z == null ? 0 : Q == null ? -1 : Z == null ? 1 : Q - Z;
      }), g.value.panelDataArrayChanged = !0;
    }
    ce(() => g.value.panelDataArrayChanged, () => {
      if (g.value.panelDataArrayChanged) {
        g.value.panelDataArrayChanged = !1;
        const { autoSaveId: F, storage: R } = m.value, { layout: H, panelDataArray: K } = g.value;
        let Q = null;
        if (F) {
          const ue = rL(F, K, R);
          ue && (f.value = new Map(
            Object.entries(ue.expandToSizes)
          ), Q = ue.layout);
        }
        Q === null && (Q = tL({
          panelDataArray: K
        }));
        const Z = oL({
          layout: Q,
          panelConstraints: K.map(
            (ue) => ue.constraints
          )
        });
        SI(H, Z) || (v(Z), g.value.layout = Z, o("layout", Z), Ys(
          K,
          Z,
          u.value
        ));
      }
    });
    function C(F) {
      return function(R) {
        R.preventDefault();
        const H = l.value;
        if (!H)
          return () => null;
        const { direction: K, dragState: Q, id: Z, keyboardResizeBy: ue } = m.value, { layout: Se, panelDataArray: be } = g.value, { initialLayout: we } = Q ?? {}, Re = N4(
          Z,
          F,
          H
        );
        let Ie = QP(
          R,
          F,
          K,
          Q,
          ue,
          H
        );
        if (Ie === 0)
          return;
        const Ge = K === "horizontal";
        s.value === "rtl" && Ge && (Ie = -Ie);
        const gt = be.map((mn) => mn.constraints), We = ra({
          delta: Ie,
          layout: we ?? Se,
          panelConstraints: gt,
          pivotIndices: Re,
          trigger: C4(R) ? "keyboard" : "mouse-or-touch"
        }), Ft = !ic(Se, We);
        (S4(R) || A4(R)) && h.value !== Ie && (h.value = Ie, Ft ? jf(F, 0) : Ge ? jf(
          F,
          Ie < 0 ? M4 : T4
        ) : jf(
          F,
          Ie < 0 ? O4 : I4
        )), Ft && (v(We), g.value.layout = We, o("layout", We), Ys(
          be,
          We,
          u.value
        ));
      };
    }
    function b(F, R) {
      const { layout: H, panelDataArray: K } = g.value, Q = K.map((we) => we.constraints), { panelSize: Z, pivotIndices: ue } = ne(
        K,
        F,
        H
      );
      Me(Z != null);
      const Se = J(K, F) === K.length - 1 ? Z - R : R - Z, be = ra({
        delta: Se,
        layout: H,
        panelConstraints: Q,
        pivotIndices: ue,
        trigger: "imperative-api"
      });
      ic(H, be) || (v(be), g.value.layout = be, o("layout", be), Ys(
        K,
        be,
        u.value
      ));
    }
    function S(F, R) {
      const { layout: H, panelDataArray: K } = g.value, {
        collapsedSize: Q = 0,
        collapsible: Z
      } = R, {
        collapsedSize: ue = 0,
        collapsible: Se,
        maxSize: be = 100,
        minSize: we = 0
      } = F.constraints, { panelSize: Re } = ne(
        K,
        F,
        H
      );
      Re !== null && (Z && Se && Re === Q ? Q !== ue && b(F, ue) : Re < we ? b(F, we) : Re > be && b(F, be));
    }
    function A(F, R) {
      const { direction: H } = m.value, { layout: K } = g.value;
      if (!l.value)
        return;
      const Q = zu(
        F,
        l.value
      );
      Me(Q);
      const Z = E4(
        H,
        R
      );
      c.value = {
        dragHandleId: F,
        dragHandleRect: Q.getBoundingClientRect(),
        initialCursorPosition: Z,
        initialLayout: K
      };
    }
    function I() {
      c.value = null;
    }
    function z(F) {
      const { panelDataArray: R } = g.value, H = J(R, F);
      H >= 0 && (R.splice(H, 1), delete u.value[F.id], g.value.panelDataArrayChanged = !0);
    }
    function N(F) {
      const { layout: R, panelDataArray: H } = g.value;
      if (F.constraints.collapsible) {
        const K = H.map(
          (Se) => Se.constraints
        ), {
          collapsedSize: Q = 0,
          panelSize: Z,
          pivotIndices: ue
        } = ne(H, F, R);
        if (Me(
          Z != null,
          `Panel size not found for panel "${F.id}"`
        ), Z !== Q) {
          f.value.set(F.id, Z);
          const Se = J(H, F) === H.length - 1 ? Z - Q : Q - Z, be = ra({
            delta: Se,
            layout: R,
            panelConstraints: K,
            pivotIndices: ue,
            trigger: "imperative-api"
          });
          ic(R, be) || (v(be), g.value.layout = be, o("layout", be), Ys(
            H,
            be,
            u.value
          ));
        }
      }
    }
    function M(F) {
      const { layout: R, panelDataArray: H } = g.value;
      if (F.constraints.collapsible) {
        const K = H.map(
          (be) => be.constraints
        ), {
          collapsedSize: Q = 0,
          panelSize: Z,
          minSize: ue = 0,
          pivotIndices: Se
        } = ne(H, F, R);
        if (Z === Q) {
          const be = f.value.get(
            F.id
          ), we = be != null && be >= ue ? be : ue, Re = J(H, F) === H.length - 1 ? Z - we : we - Z, Ie = ra({
            delta: Re,
            layout: R,
            panelConstraints: K,
            pivotIndices: Se,
            trigger: "imperative-api"
          });
          ic(R, Ie) || (v(Ie), g.value.layout = Ie, o("layout", Ie), Ys(
            H,
            Ie,
            u.value
          ));
        }
      }
    }
    function $(F) {
      const { layout: R, panelDataArray: H } = g.value, { panelSize: K } = ne(H, F, R);
      return Me(
        K != null,
        `Panel size not found for panel "${F.id}"`
      ), K;
    }
    function L(F) {
      const { layout: R, panelDataArray: H } = g.value, {
        collapsedSize: K = 0,
        collapsible: Q,
        panelSize: Z
      } = ne(H, F, R);
      return Q === !0 && Z === K;
    }
    function Y(F) {
      const { layout: R, panelDataArray: H } = g.value, {
        collapsedSize: K = 0,
        collapsible: Q,
        panelSize: Z
      } = ne(H, F, R);
      return Me(
        Z != null,
        `Panel size not found for panel "${F.id}"`
      ), !Q || Z > K;
    }
    lL({
      direction: n.direction,
      dragState: c.value,
      groupId: i,
      reevaluatePanelConstraints: S,
      registerPanel: x,
      registerResizeHandle: C,
      resizePanel: b,
      startDragging: A,
      stopDragging: I,
      unregisterPanel: z,
      panelGroupElement: l,
      collapsePanel: N,
      expandPanel: M,
      isPanelCollapsed: L,
      isPanelExpanded: Y,
      getPanelSize: $,
      getPanelStyle: y
    });
    function J(F, R) {
      return F.findIndex(
        (H) => H === R || H.id === R.id
      );
    }
    function ne(F, R, H) {
      const K = J(F, R), Q = K === F.length - 1 ? [K - 1, K] : [K, K + 1], Z = H[K];
      return {
        ...R.constraints,
        panelSize: Z,
        pivotIndices: Q
      };
    }
    return (F, R) => (k(), _(p(se), {
      ref: p(a),
      style: ct({
        display: "flex",
        flexDirection: F.direction === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": F.direction,
      "data-panel-group-id": p(i)
    }, {
      default: w(() => [
        D(F.$slots, "default", { layout: d.value })
      ]),
      _: 3
    }, 8, ["style", "data-orientation", "data-panel-group-id"]));
  }
}), zv = /* @__PURE__ */ T({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {},
    collapsible: { type: Boolean },
    defaultSize: {},
    id: {},
    maxSize: {},
    minSize: {},
    order: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["collapse", "expand", "resize"],
  setup(t, { expose: e, emit: n }) {
    const o = t, r = n, i = F4();
    if (i === null)
      throw new Error(
        "SplitterPanel components must be rendered within a SplitterGroup container"
      );
    const { collapsePanel: s, expandPanel: a, getPanelSize: l, getPanelStyle: c, isPanelCollapsed: d, resizePanel: u, groupId: f, reevaluatePanelConstraints: h, registerPanel: m, unregisterPanel: g } = i, v = At(o.id, "radix-vue-splitter-panel"), y = P(() => ({
      callbacks: {
        onCollapse: () => r("collapse"),
        onExpand: () => r("expand"),
        onResize: (...S) => r("resize", ...S)
      },
      constraints: {
        collapsedSize: o.collapsedSize,
        collapsible: o.collapsible,
        defaultSize: o.defaultSize,
        /** Panel id (unique within group); falls back to useId when not provided */
        /** Panel id (unique within group); falls back to useId when not provided */
        maxSize: o.maxSize,
        minSize: o.minSize
      },
      id: v,
      idIsFromProps: o.id !== void 0,
      order: o.order
    }));
    ce(() => y.value.constraints, (S, A) => {
      (S.collapsedSize !== A.collapsedSize || S.collapsible !== A.collapsible || S.maxSize !== A.maxSize || S.minSize !== A.minSize) && h(y.value, S);
    }, { deep: !0 }), _e(() => {
      const S = y.value;
      m(S), en(() => {
        g(S);
      });
    });
    const x = P(() => c(y.value, o.defaultSize)), C = P(() => d(y.value)), b = P(() => !C.value);
    return e({
      /** If panel is `collapsible`, collapse it fully. */
      collapse: () => {
        s(y.value);
      },
      /** If panel is currently collapsed, expand it to its most recent size. */
      expand: () => {
        a(y.value);
      },
      /** Gets the current size of the panel as a percentage (1 - 100). */
      getSize() {
        return l(y.value);
      },
      /** Resize panel to the specified percentage (1 - 100). */
      resize: (S) => {
        u(y.value, S);
      },
      /** Returns `true` if the panel is currently collapsed */
      isCollapsed: C,
      /** Returns `true` if the panel is currently not collapsed */
      isExpanded: b
    }), (S, A) => (k(), _(p(se), {
      id: p(v),
      style: ct(x.value),
      "data-panel": "",
      "data-panel-collapsible": S.collapsible || void 0,
      "data-panel-group-id": p(f),
      "data-panel-id": p(v),
      "data-panel-size": Number.parseFloat(`${x.value.flexGrow}`).toFixed(1),
      "data-state": S.collapsible ? C.value ? "collapsed" : "expanded" : void 0
    }, {
      default: w(() => [
        D(S.$slots, "default", {
          isCollapsed: C.value,
          isExpanded: b.value
        })
      ]),
      _: 3
    }, 8, ["id", "style", "data-panel-collapsible", "data-panel-group-id", "data-panel-id", "data-panel-size", "data-state"]));
  }
});
function dL({
  disabled: t,
  handleId: e,
  resizeHandler: n,
  panelGroupElement: o
}) {
  Pe((r) => {
    const i = o.value;
    if (t.value || n.value === null || i === null)
      return;
    const s = zu(e, i);
    if (s == null)
      return;
    const a = (l) => {
      var c;
      if (!l.defaultPrevented)
        switch (l.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            l.preventDefault(), (c = n.value) == null || c.call(n, l);
            break;
          }
          case "F6": {
            l.preventDefault();
            const d = s.getAttribute("data-panel-group-id");
            Me(d);
            const u = Za(
              d,
              i
            ), f = L4(
              d,
              e,
              i
            );
            Me(f !== null);
            const h = l.shiftKey ? f > 0 ? f - 1 : u.length - 1 : f + 1 < u.length ? f + 1 : 0;
            u[h].focus();
            break;
          }
        }
    };
    s.addEventListener("keydown", a), r(() => {
      s.removeEventListener("keydown", a);
    });
  });
}
const uL = /* @__PURE__ */ T({
  __name: "SplitterResizeHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: { default: 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["dragging"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = X(), { disabled: s } = mt(n), a = F4();
    if (a === null)
      throw new Error(
        "PanelResizeHandle components must be rendered within a PanelGroup container"
      );
    const {
      direction: l,
      groupId: c,
      registerResizeHandle: d,
      startDragging: u,
      stopDragging: f,
      panelGroupElement: h
    } = a, m = At(n.id, "radix-vue-splitter-resize-handle"), g = O("inactive"), v = O(!1), y = O(null);
    return ce(s, () => {
      _l && (s.value ? y.value = null : y.value = d(m));
    }, { immediate: !0 }), Pe((x) => {
      var C, b;
      if (s.value || y.value === null)
        return;
      const S = i.value;
      if (!S)
        return;
      Me(S);
      const A = (I, z, N) => {
        var M;
        if (z)
          switch (I) {
            case "down": {
              g.value = "drag", u(m, N), o("dragging", !0);
              break;
            }
            case "move": {
              g.value !== "drag" && (g.value = "hover"), (M = y.value) == null || M.call(y, N);
              break;
            }
            case "up": {
              g.value = "hover", f(), o("dragging", !1);
              break;
            }
          }
        else
          g.value = "inactive";
      };
      x(YP(
        m,
        S,
        l,
        {
          // Coarse inputs (e.g. finger/touch)
          coarse: ((C = n.hitAreaMargins) == null ? void 0 : C.coarse) ?? 15,
          // Fine inputs (e.g. mouse)
          fine: ((b = n.hitAreaMargins) == null ? void 0 : b.fine) ?? 5
        },
        A
      ));
    }), dL({
      disabled: s,
      resizeHandler: y,
      handleId: m,
      panelGroupElement: h
    }), (x, C) => (k(), _(p(se), {
      id: p(m),
      ref: p(r),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      role: "separator",
      "data-resize-handle": "",
      tabindex: x.tabindex,
      "data-state": g.value,
      "data-disabled": p(s) ? "" : void 0,
      "data-orientation": p(l),
      "data-panel-group-id": p(c),
      "data-resize-handle-active": g.value === "drag" ? "pointer" : v.value ? "keyboard" : void 0,
      "data-resize-handle-state": g.value,
      "data-panel-resize-handle-enabled": !p(s),
      "data-panel-resize-handle-id": p(m),
      onBlur: C[0] || (C[0] = (b) => v.value = !1),
      onFocus: C[1] || (C[1] = (b) => v.value = !1)
    }, {
      default: w(() => [
        D(x.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "tabindex", "data-state", "data-disabled", "data-orientation", "data-panel-group-id", "data-resize-handle-active", "data-resize-handle-state", "data-panel-resize-handle-enabled", "data-panel-resize-handle-id"]));
  }
}), [Sg, fL] = Ve("TabsRoot"), pL = /* @__PURE__ */ T({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: {},
    activationMode: { default: "automatic" },
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, { orientation: r, dir: i } = mt(n), s = qo(i);
    X();
    const a = Rt(n, "modelValue", o, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), l = O();
    return fL({
      modelValue: a,
      changeModelValue: (c) => {
        a.value = c;
      },
      orientation: r,
      dir: s,
      activationMode: n.activationMode,
      baseId: At(void 0, "radix-vue-tabs"),
      tabsList: l
    }), (c, d) => (k(), _(p(se), {
      dir: p(s),
      "data-orientation": p(r),
      "as-child": c.asChild,
      as: c.as
    }, {
      default: w(() => [
        D(c.$slots, "default", { modelValue: p(a) })
      ]),
      _: 3
    }, 8, ["dir", "data-orientation", "as-child", "as"]));
  }
}), hL = /* @__PURE__ */ T({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { loop: n } = mt(e), { forwardRef: o, currentElement: r } = X(), i = Sg();
    return i.tabsList = r, (s, a) => (k(), _(p(Du), {
      "as-child": "",
      orientation: p(i).orientation.value,
      dir: p(i).dir.value,
      loop: p(n)
    }, {
      default: w(() => [
        E(p(se), {
          ref: p(o),
          role: "tablist",
          "as-child": s.asChild,
          as: s.as,
          "aria-orientation": p(i).orientation.value
        }, {
          default: w(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "aria-orientation"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
});
function H4(t, e) {
  return `${t}-trigger-${e}`;
}
function V4(t, e) {
  return `${t}-content-${e}`;
}
const mL = /* @__PURE__ */ T({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t, { forwardRef: n } = X(), o = Sg(), r = P(() => H4(o.baseId, e.value)), i = P(() => V4(o.baseId, e.value)), s = P(() => e.value === o.modelValue.value), a = O(s.value);
    return _e(() => {
      requestAnimationFrame(() => {
        a.value = !1;
      });
    }), (l, c) => (k(), _(p(hn), {
      present: s.value,
      "force-mount": ""
    }, {
      default: w(({ present: d }) => [
        E(p(se), {
          id: i.value,
          ref: p(n),
          "as-child": l.asChild,
          as: l.as,
          role: "tabpanel",
          "data-state": s.value ? "active" : "inactive",
          "data-orientation": p(o).orientation.value,
          "aria-labelledby": r.value,
          hidden: !d.value,
          tabindex: "0",
          style: ct({
            animationDuration: a.value ? "0s" : void 0
          })
        }, {
          default: w(() => [
            l.forceMount || s.value ? D(l.$slots, "default", { key: 0 }) : ae("", !0)
          ]),
          _: 2
        }, 1032, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), gL = /* @__PURE__ */ T({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, { forwardRef: n } = X(), o = Sg(), r = P(() => H4(o.baseId, e.value)), i = P(() => V4(o.baseId, e.value)), s = P(() => e.value === o.modelValue.value);
    return (a, l) => (k(), _(p(mg), {
      "as-child": "",
      focusable: !a.disabled,
      active: s.value
    }, {
      default: w(() => [
        E(p(se), {
          id: r.value,
          ref: p(n),
          role: "tab",
          type: a.as === "button" ? "button" : void 0,
          as: a.as,
          "as-child": a.asChild,
          "aria-selected": s.value ? "true" : "false",
          "aria-controls": i.value,
          "data-state": s.value ? "active" : "inactive",
          disabled: a.disabled,
          "data-disabled": a.disabled ? "" : void 0,
          "data-orientation": p(o).orientation.value,
          onMousedown: l[0] || (l[0] = yt((c) => {
            !a.disabled && c.ctrlKey === !1 ? p(o).changeModelValue(a.value) : c.preventDefault();
          }, ["left"])),
          onKeydown: l[1] || (l[1] = Sr((c) => p(o).changeModelValue(a.value), ["enter", "space"])),
          onFocus: l[2] || (l[2] = () => {
            const c = p(o).activationMode !== "manual";
            !s.value && !a.disabled && c && p(o).changeModelValue(a.value);
          })
        }, {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), [Fu, vL] = Ve("ToastProvider"), yL = /* @__PURE__ */ T({
  __name: "ToastProvider",
  props: {
    label: { default: "Notification" },
    duration: { default: 5e3 },
    swipeDirection: { default: "right" },
    swipeThreshold: { default: 50 }
  },
  setup(t) {
    const e = t, { label: n, duration: o, swipeDirection: r, swipeThreshold: i } = mt(e), s = O(), a = O(0), l = O(!1), c = O(!1);
    if (e.label && typeof e.label == "string" && !e.label.trim()) {
      const d = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(d);
    }
    return vL({
      label: n,
      duration: o,
      swipeDirection: r,
      swipeThreshold: i,
      toastCount: a,
      viewport: s,
      onViewportChange(d) {
        s.value = d;
      },
      onToastAdd() {
        a.value++;
      },
      onToastRemove() {
        a.value--;
      },
      isFocusedToastEscapeKeyDownRef: l,
      isClosePausedRef: c
    }), (d, u) => D(d.$slots, "default");
  }
}), bL = "toast.swipeStart", wL = "toast.swipeMove", xL = "toast.swipeCancel", kL = "toast.swipeEnd", wh = "toast.viewportPause", xh = "toast.viewportResume";
function sc(t, e, n) {
  const o = n.originalEvent.currentTarget, r = new CustomEvent(t, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  e && o.addEventListener(t, e, { once: !0 }), o.dispatchEvent(r);
}
function Fv(t, e, n = 0) {
  const o = Math.abs(t.x), r = Math.abs(t.y), i = o > r;
  return e === "left" || e === "right" ? i && o > n : !i && r > n;
}
function CL(t) {
  return t.nodeType === t.ELEMENT_NODE;
}
function j4(t) {
  const e = [];
  return Array.from(t.childNodes).forEach((n) => {
    if (n.nodeType === n.TEXT_NODE && n.textContent && e.push(n.textContent), CL(n)) {
      const o = n.ariaHidden || n.hidden || n.style.display === "none", r = n.dataset.radixToastAnnounceExclude === "";
      if (!o)
        if (r) {
          const i = n.dataset.radixToastAnnounceAlt;
          i && e.push(i);
        } else
          e.push(...j4(n));
    }
  }), e;
}
const SL = /* @__PURE__ */ T({
  __name: "ToastAnnounce",
  setup(t) {
    const e = Fu(), n = $I(1e3), o = O(!1);
    return Fx(() => {
      o.value = !0;
    }), (r, i) => p(n) || o.value ? (k(), _(p(Iu), { key: 0 }, {
      default: w(() => [
        he(q(p(e).label.value) + " ", 1),
        D(r.$slots, "default")
      ]),
      _: 3
    })) : ae("", !0);
  }
}), [AL, EL] = Ve("ToastRoot"), _L = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "ToastRootImpl",
  props: {
    type: {},
    open: { type: Boolean, default: !1 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r, currentElement: i } = X(), s = Fu(), a = O(null), l = O(null), c = P(() => n.duration || s.duration.value), d = O(0), u = O(c.value), f = O(0), h = O(c.value), m = Fx(() => {
      const x = (/* @__PURE__ */ new Date()).getTime() - d.value;
      h.value = Math.max(u.value - x, 0);
    }, { fpsLimit: 60 });
    function g(x) {
      !x || x === Number.POSITIVE_INFINITY || (window.clearTimeout(f.value), d.value = (/* @__PURE__ */ new Date()).getTime(), f.value = window.setTimeout(v, x));
    }
    function v() {
      var x, C;
      (x = i.value) != null && x.contains(document.activeElement) && ((C = s.viewport.value) == null || C.focus()), s.isClosePausedRef.value = !1, o("close");
    }
    const y = P(() => i.value ? j4(i.value) : null);
    if (n.type && !["foreground", "background"].includes(n.type)) {
      const x = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(x);
    }
    return Pe((x) => {
      const C = s.viewport.value;
      if (C) {
        const b = () => {
          g(u.value), m.resume(), o("resume");
        }, S = () => {
          const A = (/* @__PURE__ */ new Date()).getTime() - d.value;
          u.value = u.value - A, window.clearTimeout(f.value), m.pause(), o("pause");
        };
        return C.addEventListener(wh, S), C.addEventListener(xh, b), () => {
          C.removeEventListener(wh, S), C.removeEventListener(xh, b);
        };
      }
    }), ce(() => [n.open, c.value], () => {
      u.value = c.value, n.open && !s.isClosePausedRef.value && g(c.value);
    }, { immediate: !0 }), ag("Escape", (x) => {
      o("escapeKeyDown", x), x.defaultPrevented || (s.isFocusedToastEscapeKeyDownRef.value = !0, v());
    }), _e(() => {
      s.onToastAdd();
    }), en(() => {
      s.onToastRemove();
    }), EL({ onClose: v }), (x, C) => (k(), U(ve, null, [
      y.value ? (k(), _(SL, {
        key: 0,
        role: "status",
        "aria-live": x.type === "foreground" ? "assertive" : "polite",
        "aria-atomic": ""
      }, {
        default: w(() => [
          he(q(y.value), 1)
        ]),
        _: 1
      }, 8, ["aria-live"])) : ae("", !0),
      (k(), _(gl, {
        to: p(s).viewport.value
      }, [
        E(p(se), j({
          ref: p(r),
          role: "status",
          "aria-live": "off",
          "aria-atomic": "",
          tabindex: "0",
          "data-radix-vue-collection-item": ""
        }, x.$attrs, {
          as: x.as,
          "as-child": x.asChild,
          "data-state": x.open ? "open" : "closed",
          "data-swipe-direction": p(s).swipeDirection.value,
          style: { userSelect: "none", touchAction: "none" },
          onPointerdown: C[0] || (C[0] = yt((b) => {
            a.value = { x: b.clientX, y: b.clientY };
          }, ["left"])),
          onPointermove: C[1] || (C[1] = (b) => {
            if (!a.value)
              return;
            const S = b.clientX - a.value.x, A = b.clientY - a.value.y, I = !!l.value, z = ["left", "right"].includes(p(s).swipeDirection.value), N = ["left", "up"].includes(p(s).swipeDirection.value) ? Math.min : Math.max, M = z ? N(0, S) : 0, $ = z ? 0 : N(0, A), L = b.pointerType === "touch" ? 10 : 2, Y = { x: M, y: $ }, J = { originalEvent: b, delta: Y };
            I ? (l.value = Y, p(sc)(p(wL), (ne) => o("swipeMove", ne), J)) : p(Fv)(Y, p(s).swipeDirection.value, L) ? (l.value = Y, p(sc)(p(bL), (ne) => o("swipeStart", ne), J), b.target.setPointerCapture(b.pointerId)) : (Math.abs(S) > L || Math.abs(A) > L) && (a.value = null);
          }),
          onPointerup: C[2] || (C[2] = (b) => {
            const S = l.value, A = b.target;
            if (A.hasPointerCapture(b.pointerId) && A.releasePointerCapture(b.pointerId), l.value = null, a.value = null, S) {
              const I = b.currentTarget, z = { originalEvent: b, delta: S };
              p(Fv)(S, p(s).swipeDirection.value, p(s).swipeThreshold.value) ? p(sc)(p(kL), (N) => o("swipeEnd", N), z) : p(sc)(p(xL), (N) => o("swipeCancel", N), z), I == null || I.addEventListener("click", (N) => N.preventDefault(), {
                once: !0
              });
            }
          })
        }), {
          default: w(() => [
            D(x.$slots, "default", { remaining: h.value })
          ]),
          _: 3
        }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])
      ], 8, ["to"]))
    ], 64));
  }
}), ML = /* @__PURE__ */ T({
  __name: "ToastRoot",
  props: {
    defaultOpen: { type: Boolean, default: !0 },
    forceMount: { type: Boolean },
    type: { default: "foreground" },
    open: { type: Boolean, default: void 0 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, { forwardRef: r } = X(), i = Rt(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    return (s, a) => (k(), _(p(hn), {
      present: s.forceMount || p(i)
    }, {
      default: w(() => [
        E(_L, j({
          ref: p(r),
          open: p(i),
          type: s.type,
          as: s.as,
          "as-child": s.asChild,
          duration: s.duration
        }, s.$attrs, {
          onClose: a[0] || (a[0] = (l) => i.value = !1),
          onPause: a[1] || (a[1] = (l) => o("pause")),
          onResume: a[2] || (a[2] = (l) => o("resume")),
          onEscapeKeyDown: a[3] || (a[3] = (l) => o("escapeKeyDown", l)),
          onSwipeStart: a[4] || (a[4] = (l) => {
            o("swipeStart", l), l.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: a[5] || (a[5] = (l) => {
            const { x: c, y: d } = l.detail.delta, u = l.currentTarget;
            u.setAttribute("data-swipe", "move"), u.style.setProperty("--radix-toast-swipe-move-x", `${c}px`), u.style.setProperty("--radix-toast-swipe-move-y", `${d}px`);
          }),
          onSwipeCancel: a[6] || (a[6] = (l) => {
            const c = l.currentTarget;
            c.setAttribute("data-swipe", "cancel"), c.style.removeProperty("--radix-toast-swipe-move-x"), c.style.removeProperty("--radix-toast-swipe-move-y"), c.style.removeProperty("--radix-toast-swipe-end-x"), c.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: a[7] || (a[7] = (l) => {
            const { x: c, y: d } = l.detail.delta, u = l.currentTarget;
            u.setAttribute("data-swipe", "end"), u.style.removeProperty("--radix-toast-swipe-move-x"), u.style.removeProperty("--radix-toast-swipe-move-y"), u.style.setProperty("--radix-toast-swipe-end-x", `${c}px`), u.style.setProperty("--radix-toast-swipe-end-y", `${d}px`), i.value = !1;
          })
        }), {
          default: w(({ remaining: l }) => [
            D(s.$slots, "default", {
              remaining: l,
              open: p(i)
            })
          ]),
          _: 3
        }, 16, ["open", "type", "as", "as-child", "duration"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), TL = /* @__PURE__ */ T({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    return (e, n) => (k(), _(p(se), {
      as: e.as,
      "as-child": e.asChild,
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": e.altText || void 0
    }, {
      default: w(() => [
        D(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-radix-toast-announce-alt"]));
  }
}), OL = /* @__PURE__ */ T({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = AL(), { forwardRef: o } = X();
    return (r, i) => (k(), _(TL, { "as-child": "" }, {
      default: w(() => [
        E(p(se), j(e, {
          ref: p(o),
          type: r.as === "button" ? "button" : void 0,
          onClick: i[0] || (i[0] = (s) => p(n).onClose())
        }), {
          default: w(() => [
            D(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }));
  }
}), Hv = /* @__PURE__ */ T({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(t, { emit: e }) {
    const n = e, o = Fu();
    return (r, i) => (k(), _(p(Iu), {
      "aria-hidden": "",
      tabindex: "0",
      style: { position: "fixed" },
      onFocus: i[0] || (i[0] = (s) => {
        var a;
        const l = s.relatedTarget;
        !((a = p(o).viewport.value) != null && a.contains(l)) && n("focusFromOutsideViewport");
      })
    }, {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }));
  }
}), IL = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "ToastViewport",
  props: {
    hotkey: { default: () => ["F8"] },
    label: { type: [String, Function], default: "Notifications ({hotkey})" },
    asChild: { type: Boolean },
    as: { default: "ol" }
  },
  setup(t) {
    const e = t, { hotkey: n, label: o } = mt(e), { forwardRef: r, currentElement: i } = X(), { createCollection: s } = ho(), a = s(i), l = Fu(), c = P(() => l.toastCount.value > 0), d = O(), u = O(), f = P(() => n.value.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
    ag(n.value, () => {
      i.value.focus();
    }), _e(() => {
      l.onViewportChange(i.value);
    }), Pe((m) => {
      const g = i.value;
      if (c.value && g) {
        const v = () => {
          if (!l.isClosePausedRef.value) {
            const S = new CustomEvent(wh);
            g.dispatchEvent(S), l.isClosePausedRef.value = !0;
          }
        }, y = () => {
          if (l.isClosePausedRef.value) {
            const S = new CustomEvent(xh);
            g.dispatchEvent(S), l.isClosePausedRef.value = !1;
          }
        }, x = (S) => {
          !g.contains(S.relatedTarget) && y();
        }, C = () => {
          g.contains(document.activeElement) || y();
        }, b = (S) => {
          var A, I, z;
          const N = S.altKey || S.ctrlKey || S.metaKey;
          if (S.key === "Tab" && !N) {
            const M = document.activeElement, $ = S.shiftKey;
            if (S.target === g && $) {
              (A = d.value) == null || A.focus();
              return;
            }
            const L = h({ tabbingDirection: $ ? "backwards" : "forwards" }), Y = L.findIndex((J) => J === M);
            Oc(L.slice(Y + 1)) ? S.preventDefault() : $ ? (I = d.value) == null || I.focus() : (z = u.value) == null || z.focus();
          }
        };
        g.addEventListener("focusin", v), g.addEventListener("focusout", x), g.addEventListener("pointermove", v), g.addEventListener("pointerleave", C), g.addEventListener("keydown", b), window.addEventListener("blur", v), window.addEventListener("focus", y), m(() => {
          g.removeEventListener("focusin", v), g.removeEventListener("focusout", x), g.removeEventListener("pointermove", v), g.removeEventListener("pointerleave", C), g.removeEventListener("keydown", b), window.removeEventListener("blur", v), window.removeEventListener("focus", y);
        });
      }
    });
    function h({ tabbingDirection: m }) {
      const g = a.value.map((v) => {
        const y = [v, ...fg(v)];
        return m === "forwards" ? y : y.reverse();
      });
      return (m === "forwards" ? g.reverse() : g).flat();
    }
    return (m, g) => (k(), _(p(kD), {
      role: "region",
      "aria-label": typeof p(o) == "string" ? p(o).replace("{hotkey}", f.value) : p(o)(f.value),
      tabindex: "-1",
      style: ct({
        // incase list has size when empty (e.g. padding), we remove pointer events so
        // it doesn't prevent interactions with page elements that it overlays
        pointerEvents: c.value ? void 0 : "none"
      })
    }, {
      default: w(() => [
        c.value ? (k(), _(Hv, {
          key: 0,
          ref: (v) => {
            d.value = p(fn)(v);
          },
          onFocusFromOutsideViewport: g[0] || (g[0] = () => {
            const v = h({
              tabbingDirection: "forwards"
            });
            p(Oc)(v);
          })
        }, null, 512)) : ae("", !0),
        E(p(se), j({
          ref: p(r),
          tabindex: "-1",
          as: m.as,
          "as-child": m.asChild
        }, m.$attrs), {
          default: w(() => [
            D(m.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child"]),
        c.value ? (k(), _(Hv, {
          key: 1,
          ref: (v) => {
            u.value = p(fn)(v);
          },
          onFocusFromOutsideViewport: g[1] || (g[1] = () => {
            const v = h({
              tabbingDirection: "backwards"
            });
            p(Oc)(v);
          })
        }, null, 512)) : ae("", !0)
      ]),
      _: 3
    }, 8, ["aria-label", "style"]));
  }
}), DL = /* @__PURE__ */ T({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return X(), (n, o) => (k(), _(p(se), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), RL = /* @__PURE__ */ T({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return X(), (n, o) => (k(), _(p(se), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), U4 = /* @__PURE__ */ T({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    pressed: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:pressed"],
  setup(t, { emit: e }) {
    const n = t, o = e;
    X();
    const r = Rt(n, "pressed", o, {
      defaultValue: n.defaultValue,
      passive: n.pressed === void 0
    });
    function i() {
      r.value = !r.value;
    }
    const s = P(() => r.value ? "on" : "off");
    return (a, l) => (k(), _(p(se), {
      type: a.as === "button" ? "button" : void 0,
      "as-child": n.asChild,
      as: a.as,
      "aria-pressed": p(r),
      "data-state": s.value,
      "data-disabled": a.disabled ? "" : void 0,
      disabled: a.disabled,
      onClick: i
    }, {
      default: w(() => [
        D(a.$slots, "default", { pressed: p(r) })
      ]),
      _: 3
    }, 8, ["type", "as-child", "as", "aria-pressed", "data-state", "data-disabled", "disabled"]));
  }
}), [PL, LL] = Ve("ToggleGroupRoot"), NL = /* @__PURE__ */ T({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    orientation: {},
    dir: {},
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, { loop: r, rovingFocus: i, disabled: s, dir: a } = mt(n), l = qo(a), { forwardRef: c } = X(), { modelValue: d, changeModelValue: u, isSingle: f } = hD(n, o);
    return LL({
      isSingle: f,
      modelValue: d,
      changeModelValue: u,
      dir: l,
      orientation: n.orientation,
      loop: r,
      rovingFocus: i,
      disabled: s
    }), (h, m) => (k(), _(_n(p(i) ? p(Du) : p(se)), {
      "as-child": "",
      orientation: p(i) ? h.orientation : void 0,
      dir: p(l),
      loop: p(i) ? p(r) : void 0
    }, {
      default: w(() => [
        E(p(se), {
          ref: p(c),
          role: "group",
          "as-child": h.asChild,
          as: h.as
        }, {
          default: w(() => [
            D(h.$slots, "default", { modelValue: p(d) })
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), BL = /* @__PURE__ */ T({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = PL(), o = P(() => {
      var a;
      return ((a = n.disabled) == null ? void 0 : a.value) || e.disabled;
    }), r = P(() => {
      var a;
      return (a = n.modelValue.value) == null ? void 0 : a.includes(e.value);
    }), i = P(() => {
      var a;
      return n.isSingle.value ? n.modelValue.value === e.value : (a = n.modelValue.value) == null ? void 0 : a.includes(e.value);
    }), { forwardRef: s } = X();
    return (a, l) => (k(), _(_n(p(n).rovingFocus.value ? p(mg) : p(se)), {
      "as-child": "",
      focusable: !o.value,
      active: r.value
    }, {
      default: w(() => [
        E(p(U4), j(e, {
          ref: p(s),
          disabled: o.value,
          pressed: i.value,
          "onUpdate:pressed": l[0] || (l[0] = (c) => p(n).changeModelValue(a.value))
        }), {
          default: w(() => [
            D(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["disabled", "pressed"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), W4 = "tooltip.open", [Ag, $L] = Ve("TooltipProvider"), zL = /* @__PURE__ */ T({
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 700 },
    skipDelayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean, default: !1 },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, { delayDuration: n, skipDelayDuration: o, disableHoverableContent: r, disableClosingTrigger: i, ignoreNonKeyboardFocus: s, disabled: a } = mt(e);
    X();
    const l = O(!0), c = O(!1), { start: d, stop: u } = sg(() => {
      l.value = !0;
    }, o, { immediate: !1 });
    return $L({
      isOpenDelayed: l,
      delayDuration: n,
      onOpen() {
        u(), l.value = !1;
      },
      onClose() {
        d();
      },
      isPointerInTransitRef: c,
      disableHoverableContent: r,
      disableClosingTrigger: i,
      disabled: a,
      ignoreNonKeyboardFocus: s
    }), (f, h) => D(f.$slots, "default");
  }
}), [Hu, FL] = Ve("TooltipRoot"), HL = /* @__PURE__ */ T({
  __name: "TooltipRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    delayDuration: { default: void 0 },
    disableHoverableContent: { type: Boolean, default: void 0 },
    disableClosingTrigger: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    ignoreNonKeyboardFocus: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e;
    X();
    const r = Ag(), i = P(() => n.disableHoverableContent ?? r.disableHoverableContent.value), s = P(() => n.disableClosingTrigger ?? r.disableClosingTrigger.value), a = P(() => n.disabled ?? r.disabled.value), l = P(() => n.delayDuration ?? r.delayDuration.value), c = P(() => n.ignoreNonKeyboardFocus ?? r.ignoreNonKeyboardFocus.value), d = Rt(n, "open", o, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    ce(d, (C) => {
      r.onClose && (C ? (r.onOpen(), document.dispatchEvent(new CustomEvent(W4))) : r.onClose());
    });
    const u = O(!1), f = O(), h = P(() => d.value ? u.value ? "delayed-open" : "instant-open" : "closed"), { start: m, stop: g } = sg(() => {
      u.value = !0, d.value = !0;
    }, l, { immediate: !1 });
    function v() {
      g(), u.value = !1, d.value = !0;
    }
    function y() {
      g(), d.value = !1;
    }
    function x() {
      m();
    }
    return FL({
      contentId: "",
      open: d,
      stateAttribute: h,
      trigger: f,
      onTriggerChange(C) {
        f.value = C;
      },
      onTriggerEnter() {
        r.isOpenDelayed.value ? x() : v();
      },
      onTriggerLeave() {
        i.value ? y() : g();
      },
      onOpen: v,
      onClose: y,
      disableHoverableContent: i,
      disableClosingTrigger: s,
      disabled: a,
      ignoreNonKeyboardFocus: c
    }), (C, b) => (k(), _(p(Ol), null, {
      default: w(() => [
        D(C.$slots, "default", { open: p(d) })
      ]),
      _: 3
    }));
  }
}), VL = /* @__PURE__ */ T({
  __name: "TooltipTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t, n = Hu(), o = Ag();
    n.contentId || (n.contentId = At(void 0, "radix-vue-tooltip-content"));
    const { forwardRef: r, currentElement: i } = X(), s = O(!1), a = O(!1), l = P(() => n.disabled.value ? {} : {
      click: g,
      focus: h,
      pointermove: u,
      pointerleave: f,
      pointerdown: d,
      blur: m
    });
    _e(() => {
      n.onTriggerChange(i.value);
    });
    function c() {
      s.value = !1;
    }
    function d() {
      s.value = !0, document.addEventListener("pointerup", c, { once: !0 });
    }
    function u(v) {
      v.pointerType !== "touch" && !a.value && !o.isPointerInTransitRef.value && (n.onTriggerEnter(), a.value = !0);
    }
    function f() {
      n.onTriggerLeave(), a.value = !1;
    }
    function h(v) {
      var y, x;
      s.value || n.ignoreNonKeyboardFocus.value && !((x = (y = v.target).matches) != null && x.call(y, ":focus-visible")) || n.onOpen();
    }
    function m() {
      n.onClose();
    }
    function g() {
      n.disableClosingTrigger.value || n.onClose();
    }
    return (v, y) => (k(), _(p(Tu), { "as-child": "" }, {
      default: w(() => [
        E(p(se), j({
          ref: p(r),
          "aria-describedby": p(n).open.value ? p(n).contentId : void 0,
          "data-state": p(n).stateAttribute.value,
          as: v.as,
          "as-child": e.asChild
        }, e8(l.value)), {
          default: w(() => [
            D(v.$slots, "default")
          ]),
          _: 3
        }, 16, ["aria-describedby", "data-state", "as", "as-child"])
      ]),
      _: 3
    }));
  }
}), K4 = /* @__PURE__ */ T({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: { default: 0 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    arrowPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Hu(), { forwardRef: i } = X(), s = Tb(), a = P(() => {
      var d;
      return (d = s.default) == null ? void 0 : d.call(s);
    }), l = P(() => {
      var d;
      if (n.ariaLabel)
        return n.ariaLabel;
      let u = "";
      function f(h) {
        typeof h.children == "string" ? u += h.children : Array.isArray(h.children) && h.children.forEach((m) => f(m));
      }
      return (d = a.value) == null || d.forEach((h) => f(h)), u;
    }), c = P(() => {
      const { ariaLabel: d, ...u } = n;
      return u;
    });
    return _e(() => {
      ud(window, "scroll", (d) => {
        const u = d.target;
        u != null && u.contains(r.trigger.value) && r.onClose();
      }), ud(window, W4, r.onClose);
    }), (d, u) => (k(), _(p(Tl), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: u[0] || (u[0] = (f) => o("escapeKeyDown", f)),
      onPointerDownOutside: u[1] || (u[1] = (f) => {
        var h;
        p(r).disableClosingTrigger.value && (h = p(r).trigger.value) != null && h.contains(f.target) && f.preventDefault(), o("pointerDownOutside", f);
      }),
      onFocusOutside: u[2] || (u[2] = yt(() => {
      }, ["prevent"])),
      onDismiss: u[3] || (u[3] = (f) => p(r).onClose())
    }, {
      default: w(() => [
        E(p(Ou), j({
          ref: p(i),
          "data-state": p(r).stateAttribute.value
        }, { ...d.$attrs, ...c.value }, { style: {
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        } }), {
          default: w(() => [
            D(d.$slots, "default"),
            E(p(Iu), {
              id: p(r).contentId,
              role: "tooltip"
            }, {
              default: w(() => [
                he(q(l.value), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 3
        }, 16, ["data-state", "style"])
      ]),
      _: 3
    }));
  }
}), jL = /* @__PURE__ */ T({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  setup(t) {
    const e = _t(t), { forwardRef: n, currentElement: o } = X(), { trigger: r, onClose: i } = Hu(), s = Ag(), { isPointerInTransit: a, onPointerExit: l } = XI(r, o);
    return s.isPointerInTransitRef = a, l(() => {
      i();
    }), (c, d) => (k(), _(K4, j({ ref: p(n) }, p(e)), {
      default: w(() => [
        D(c.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), UL = /* @__PURE__ */ T({
  __name: "TooltipContent",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = Hu(), i = De(n, o), { forwardRef: s } = X();
    return (a, l) => p(r).open.value ? (k(), _(_n(p(r).disableHoverableContent.value ? K4 : jL), j({
      key: 0,
      ref: p(s)
    }, p(i)), {
      default: w(() => [
        D(a.$slots, "default")
      ]),
      _: 3
    }, 16)) : ae("", !0);
  }
}), WL = /* @__PURE__ */ T({
  __name: "TooltipPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(Ml), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
function q4(t) {
  var e, n, o = "";
  if (typeof t == "string" || typeof t == "number")
    o += t;
  else if (typeof t == "object")
    if (Array.isArray(t)) {
      var r = t.length;
      for (e = 0; e < r; e++)
        t[e] && (n = q4(t[e])) && (o && (o += " "), o += n);
    } else
      for (n in t)
        t[n] && (o && (o += " "), o += n);
  return o;
}
function KL() {
  for (var t, e, n = 0, o = "", r = arguments.length; n < r; n++)
    (t = arguments[n]) && (e = q4(t)) && (o && (o += " "), o += e);
  return o;
}
const Eg = "-";
function qL(t) {
  const e = JL(t), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: o
  } = t;
  function r(s) {
    const a = s.split(Eg);
    return a[0] === "" && a.length !== 1 && a.shift(), G4(a, e) || GL(s);
  }
  function i(s, a) {
    const l = n[s] || [];
    return a && o[s] ? [...l, ...o[s]] : l;
  }
  return {
    getClassGroupId: r,
    getConflictingClassGroupIds: i
  };
}
function G4(t, e) {
  var s;
  if (t.length === 0)
    return e.classGroupId;
  const n = t[0], o = e.nextPart.get(n), r = o ? G4(t.slice(1), o) : void 0;
  if (r)
    return r;
  if (e.validators.length === 0)
    return;
  const i = t.join(Eg);
  return (s = e.validators.find(({
    validator: a
  }) => a(i))) == null ? void 0 : s.classGroupId;
}
const Vv = /^\[(.+)\]$/;
function GL(t) {
  if (Vv.test(t)) {
    const e = Vv.exec(t)[1], n = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}
function JL(t) {
  const {
    theme: e,
    prefix: n
  } = t, o = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return XL(Object.entries(t.classGroups), n).forEach(([i, s]) => {
    kh(s, o, i, e);
  }), o;
}
function kh(t, e, n, o) {
  t.forEach((r) => {
    if (typeof r == "string") {
      const i = r === "" ? e : jv(e, r);
      i.classGroupId = n;
      return;
    }
    if (typeof r == "function") {
      if (YL(r)) {
        kh(r(o), e, n, o);
        return;
      }
      e.validators.push({
        validator: r,
        classGroupId: n
      });
      return;
    }
    Object.entries(r).forEach(([i, s]) => {
      kh(s, jv(e, i), n, o);
    });
  });
}
function jv(t, e) {
  let n = t;
  return e.split(Eg).forEach((o) => {
    n.nextPart.has(o) || n.nextPart.set(o, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(o);
  }), n;
}
function YL(t) {
  return t.isThemeGetter;
}
function XL(t, e) {
  return e ? t.map(([n, o]) => {
    const r = o.map((i) => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([s, a]) => [e + s, a])) : i);
    return [n, r];
  }) : t;
}
function ZL(t) {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, n = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  function r(i, s) {
    n.set(i, s), e++, e > t && (e = 0, o = n, n = /* @__PURE__ */ new Map());
  }
  return {
    get(i) {
      let s = n.get(i);
      if (s !== void 0)
        return s;
      if ((s = o.get(i)) !== void 0)
        return r(i, s), s;
    },
    set(i, s) {
      n.has(i) ? n.set(i, s) : r(i, s);
    }
  };
}
const J4 = "!";
function QL(t) {
  const e = t.separator, n = e.length === 1, o = e[0], r = e.length;
  return function(s) {
    const a = [];
    let l = 0, c = 0, d;
    for (let g = 0; g < s.length; g++) {
      let v = s[g];
      if (l === 0) {
        if (v === o && (n || s.slice(g, g + r) === e)) {
          a.push(s.slice(c, g)), c = g + r;
          continue;
        }
        if (v === "/") {
          d = g;
          continue;
        }
      }
      v === "[" ? l++ : v === "]" && l--;
    }
    const u = a.length === 0 ? s : s.substring(c), f = u.startsWith(J4), h = f ? u.substring(1) : u, m = d && d > c ? d - c : void 0;
    return {
      modifiers: a,
      hasImportantModifier: f,
      baseClassName: h,
      maybePostfixModifierPosition: m
    };
  };
}
function eN(t) {
  if (t.length <= 1)
    return t;
  const e = [];
  let n = [];
  return t.forEach((o) => {
    o[0] === "[" ? (e.push(...n.sort(), o), n = []) : n.push(o);
  }), e.push(...n.sort()), e;
}
function tN(t) {
  return {
    cache: ZL(t.cacheSize),
    splitModifiers: QL(t),
    ...qL(t)
  };
}
const nN = /\s+/;
function oN(t, e) {
  const {
    splitModifiers: n,
    getClassGroupId: o,
    getConflictingClassGroupIds: r
  } = e, i = /* @__PURE__ */ new Set();
  return t.trim().split(nN).map((s) => {
    const {
      modifiers: a,
      hasImportantModifier: l,
      baseClassName: c,
      maybePostfixModifierPosition: d
    } = n(s);
    let u = o(d ? c.substring(0, d) : c), f = !!d;
    if (!u) {
      if (!d)
        return {
          isTailwindClass: !1,
          originalClassName: s
        };
      if (u = o(c), !u)
        return {
          isTailwindClass: !1,
          originalClassName: s
        };
      f = !1;
    }
    const h = eN(a).join(":");
    return {
      isTailwindClass: !0,
      modifierId: l ? h + J4 : h,
      classGroupId: u,
      originalClassName: s,
      hasPostfixModifier: f
    };
  }).reverse().filter((s) => {
    if (!s.isTailwindClass)
      return !0;
    const {
      modifierId: a,
      classGroupId: l,
      hasPostfixModifier: c
    } = s, d = a + l;
    return i.has(d) ? !1 : (i.add(d), r(l, c).forEach((u) => i.add(a + u)), !0);
  }).reverse().map((s) => s.originalClassName).join(" ");
}
function rN() {
  let t = 0, e, n, o = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (n = Y4(e)) && (o && (o += " "), o += n);
  return o;
}
function Y4(t) {
  if (typeof t == "string")
    return t;
  let e, n = "";
  for (let o = 0; o < t.length; o++)
    t[o] && (e = Y4(t[o])) && (n && (n += " "), n += e);
  return n;
}
function iN(t, ...e) {
  let n, o, r, i = s;
  function s(l) {
    const c = e.reduce((d, u) => u(d), t());
    return n = tN(c), o = n.cache.get, r = n.cache.set, i = a, a(l);
  }
  function a(l) {
    const c = o(l);
    if (c)
      return c;
    const d = oN(l, n);
    return r(l, d), d;
  }
  return function() {
    return i(rN.apply(null, arguments));
  };
}
function rt(t) {
  const e = (n) => n[t] || [];
  return e.isThemeGetter = !0, e;
}
const X4 = /^\[(?:([a-z-]+):)?(.+)\]$/i, sN = /^\d+\/\d+$/, aN = /* @__PURE__ */ new Set(["px", "full", "screen"]), lN = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, cN = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, dN = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, uN = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, fN = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function yo(t) {
  return ni(t) || aN.has(t) || sN.test(t);
}
function tr(t) {
  return Os(t, "length", wN);
}
function ni(t) {
  return !!t && !Number.isNaN(Number(t));
}
function ac(t) {
  return Os(t, "number", ni);
}
function Xs(t) {
  return !!t && Number.isInteger(Number(t));
}
function pN(t) {
  return t.endsWith("%") && ni(t.slice(0, -1));
}
function Ce(t) {
  return X4.test(t);
}
function nr(t) {
  return lN.test(t);
}
const hN = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function mN(t) {
  return Os(t, hN, Z4);
}
function gN(t) {
  return Os(t, "position", Z4);
}
const vN = /* @__PURE__ */ new Set(["image", "url"]);
function yN(t) {
  return Os(t, vN, kN);
}
function bN(t) {
  return Os(t, "", xN);
}
function Zs() {
  return !0;
}
function Os(t, e, n) {
  const o = X4.exec(t);
  return o ? o[1] ? typeof e == "string" ? o[1] === e : e.has(o[1]) : n(o[2]) : !1;
}
function wN(t) {
  return cN.test(t) && !dN.test(t);
}
function Z4() {
  return !1;
}
function xN(t) {
  return uN.test(t);
}
function kN(t) {
  return fN.test(t);
}
function CN() {
  const t = rt("colors"), e = rt("spacing"), n = rt("blur"), o = rt("brightness"), r = rt("borderColor"), i = rt("borderRadius"), s = rt("borderSpacing"), a = rt("borderWidth"), l = rt("contrast"), c = rt("grayscale"), d = rt("hueRotate"), u = rt("invert"), f = rt("gap"), h = rt("gradientColorStops"), m = rt("gradientColorStopPositions"), g = rt("inset"), v = rt("margin"), y = rt("opacity"), x = rt("padding"), C = rt("saturate"), b = rt("scale"), S = rt("sepia"), A = rt("skew"), I = rt("space"), z = rt("translate"), N = () => ["auto", "contain", "none"], M = () => ["auto", "hidden", "clip", "visible", "scroll"], $ = () => ["auto", Ce, e], L = () => [Ce, e], Y = () => ["", yo, tr], J = () => ["auto", ni, Ce], ne = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], F = () => ["solid", "dashed", "dotted", "double", "none"], R = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], H = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], K = () => ["", "0", Ce], Q = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], Z = () => [ni, ac], ue = () => [ni, Ce];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Zs],
      spacing: [yo, tr],
      blur: ["none", "", nr, Ce],
      brightness: Z(),
      borderColor: [t],
      borderRadius: ["none", "", "full", nr, Ce],
      borderSpacing: L(),
      borderWidth: Y(),
      contrast: Z(),
      grayscale: K(),
      hueRotate: ue(),
      invert: K(),
      gap: L(),
      gradientColorStops: [t],
      gradientColorStopPositions: [pN, tr],
      inset: $(),
      margin: $(),
      opacity: Z(),
      padding: L(),
      saturate: Z(),
      scale: Z(),
      sepia: K(),
      skew: ue(),
      space: L(),
      translate: L()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Ce]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [nr]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": Q()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": Q()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...ne(), Ce]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: M()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": M()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": M()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: N()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": N()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": N()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Xs, Ce]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: $()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Ce]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: K()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: K()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Xs, Ce]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Zs]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Xs, Ce]
        }, Ce]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": J()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": J()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Zs]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Xs, Ce]
        }, Ce]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": J()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": J()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Ce]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Ce]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...H()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...H(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...H(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [x]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [x]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [x]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [x]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [x]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [x]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [x]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [x]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [x]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [v]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [v]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [v]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [v]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [v]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [v]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [v]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [v]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [v]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [I]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [I]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ce, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Ce, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Ce, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [nr]
        }, nr]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Ce, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Ce, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Ce, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Ce, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", nr, tr]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", ac]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Zs]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Ce]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", ni, ac]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", yo, Ce]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ce]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Ce]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [y]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [y]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...F(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", yo, tr]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", yo, Ce]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: L()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ce]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ce]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [y]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...ne(), gN]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", mN]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, yN]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [m]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [m]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [m]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [y]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...F(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [y]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: F()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [r]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [r]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [r]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [r]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [r]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [r]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [r]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [r]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...F()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [yo, Ce]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [yo, tr]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: Y()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [y]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [yo, tr]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", nr, bN]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Zs]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [y]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...R(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": R()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [o]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", nr, Ce]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [u]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [C]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [S]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [o]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [u]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [y]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [C]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [S]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [s]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [s]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [s]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Ce]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: ue()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Ce]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: ue()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Ce]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [b]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [b]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [b]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Xs, Ce]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [z]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [z]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [A]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [A]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Ce]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ce]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": L()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": L()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": L()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": L()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": L()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": L()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": L()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": L()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": L()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": L()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": L()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": L()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": L()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": L()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": L()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": L()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": L()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": L()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ce]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [yo, tr, ac]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
const SN = /* @__PURE__ */ iN(CN);
function fe(...t) {
  return SN(KL(t));
}
const Bo = /* @__PURE__ */ T({
  __name: "Separator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(zP), j(n.value, {
      class: p(fe)("shrink-0 bg-border", e.orientation === "vertical" ? "w-px h-full" : "h-px w-full", e.class)
    }), null, 16, ["class"]));
  }
}), AN = { class: "border border-neutral-200 dark:border-neutral-800 px-3 py-2 transition-all select-none pointer-events-auto shadow-sm rounded-sm bg-background w-auto max-w-[calc(-68px_+_100vw)] overflow-x-auto" }, EN = { class: "flex items-center flex-nowrap whitespace-nowrap h-[26px] justify-start relative gap-0.5" }, _N = /* @__PURE__ */ T({
  __name: "BasicBubbleMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, n = pn(), { t: o } = et(), r = zn({
      maxWidth: "auto",
      zIndex: 20,
      appendTo: "parent",
      moveTransition: "transform 0.15s ease-out"
    }), i = P(() => {
      var f;
      const l = e.editor.state.selection, c = e.editor.isActive("link"), d = ((f = l.node) == null ? void 0 : f.type.name) === "video", u = l instanceof le;
      if (c)
        return "link";
      if (d)
        return "video";
      if (u)
        return "text";
    }), s = P(() => {
      var f;
      const { extensions: l = [] } = e.editor.extensionManager, c = l.find((h) => h.name === "base-kit");
      if (!c)
        return {};
      const { button: d } = ((f = c.options) == null ? void 0 : f.bubble) ?? {};
      return d ? d({
        editor: e.editor,
        extension: c,
        t: p(o)
      }) : {};
    }), a = P(() => {
      var l;
      return i.value ? ((l = p(s)) == null ? void 0 : l[i.value]) ?? [] : [];
    });
    return (l, c) => {
      var d;
      return Sn((k(), _(p(As), {
        editor: l.editor,
        "tippy-options": r
      }, {
        default: w(() => [
          B("div", AN, [
            B("div", EN, [
              (k(!0), U(ve, null, Fe(a.value, (u, f) => {
                var h;
                return k(), U(ve, { key: f }, [
                  u.type === "divider" ? (k(), _(p(Bo), {
                    key: 0,
                    orientation: "vertical",
                    class: "mx-1 me-1 h-[16px]"
                  })) : (k(), _(_n(u.component), j({
                    key: 1,
                    ref_for: !0
                  }, u.componentProps, {
                    editor: l.editor,
                    disabled: l.disabled || ((h = u.componentProps) == null ? void 0 : h.disabled)
                  }), Ib({ _: 2 }, [
                    Fe(u.componentSlots, (m, g, v) => ({
                      name: `${g}`,
                      fn: w((y) => [
                        (k(), _(_n(m), j({ ref_for: !0 }, y == null ? void 0 : y.props), null, 16))
                      ])
                    }))
                  ]), 1040, ["editor", "disabled"]))
                ], 64);
              }), 128))
            ])
          ])
        ]),
        _: 1
      }, 8, ["editor", "tippy-options"])), [
        [Jn, a.value.length && !((d = p(n)) != null && d.state.AIMenu)]
      ]);
    };
  }
});
function MN(t, e) {
  return k(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    B("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
      fill: "currentColor"
    })
  ]);
}
function Vu(t, e) {
  return k(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    B("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
      fill: "currentColor"
    })
  ]);
}
function TN(t, e) {
  return k(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    B("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
      fill: "currentColor"
    })
  ]);
}
function ON(t, e) {
  return k(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    B("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
      fill: "currentColor"
    })
  ]);
}
function IN(t, e) {
  return k(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    B("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.13523 8.84197C3.3241 9.04343 3.64052 9.05363 3.84197 8.86477L7.5 5.43536L11.158 8.86477C11.3595 9.05363 11.6759 9.04343 11.8648 8.84197C12.0536 8.64051 12.0434 8.32409 11.842 8.13523L7.84197 4.38523C7.64964 4.20492 7.35036 4.20492 7.15803 4.38523L3.15803 8.13523C2.95657 8.32409 2.94637 8.64051 3.13523 8.84197Z",
      fill: "currentColor"
    })
  ]);
}
function Q4(t, e) {
  return k(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    B("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
      fill: "currentColor"
    })
  ]);
}
function DN(t, e) {
  return k(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    B("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.5 4.625C6.12132 4.625 6.625 4.12132 6.625 3.5C6.625 2.87868 6.12132 2.375 5.5 2.375C4.87868 2.375 4.375 2.87868 4.375 3.5C4.375 4.12132 4.87868 4.625 5.5 4.625ZM9.5 4.625C10.1213 4.625 10.625 4.12132 10.625 3.5C10.625 2.87868 10.1213 2.375 9.5 2.375C8.87868 2.375 8.375 2.87868 8.375 3.5C8.375 4.12132 8.87868 4.625 9.5 4.625ZM10.625 7.5C10.625 8.12132 10.1213 8.625 9.5 8.625C8.87868 8.625 8.375 8.12132 8.375 7.5C8.375 6.87868 8.87868 6.375 9.5 6.375C10.1213 6.375 10.625 6.87868 10.625 7.5ZM5.5 8.625C6.12132 8.625 6.625 8.12132 6.625 7.5C6.625 6.87868 6.12132 6.375 5.5 6.375C4.87868 6.375 4.375 6.87868 4.375 7.5C4.375 8.12132 4.87868 8.625 5.5 8.625ZM10.625 11.5C10.625 12.1213 10.1213 12.625 9.5 12.625C8.87868 12.625 8.375 12.1213 8.375 11.5C8.375 10.8787 8.87868 10.375 9.5 10.375C10.1213 10.375 10.625 10.8787 10.625 11.5ZM5.5 12.625C6.12132 12.625 6.625 12.1213 6.625 11.5C6.625 10.8787 6.12132 10.375 5.5 10.375C4.87868 10.375 4.375 10.8787 4.375 11.5C4.375 12.1213 4.87868 12.625 5.5 12.625Z",
      fill: "currentColor"
    })
  ]);
}
const e3 = /* @__PURE__ */ T({
  __name: "Checkbox",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    value: {},
    id: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:checked"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(qD), j(p(i), {
      class: p(fe)(
        "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        n.class
      )
    }), {
      default: w(() => [
        E(p(GD), { class: "flex h-full w-full items-center justify-center text-current" }, {
          default: w(() => [
            D(s.$slots, "default", {}, () => [
              E(p(Vu), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), RN = {
  Bold: "lucide:bold",
  LoaderCircle: "lucide:loader-circle",
  Italic: "lucide:italic",
  Underline: "lucide:underline",
  Quote: "lucide:quote",
  TextQuote: "lucide:text-quote",
  Strikethrough: "lucide:strikethrough",
  Minus: "lucide:minus",
  Eraser: "lucide:eraser",
  PaintRoller: "lucide:paint-roller",
  Redo2: "lucide:redo-2",
  Undo2: "lucide:undo-2",
  AlignCenter: "radix-icons:text-align-center",
  AlignJustify: "radix-icons:text-align-justify",
  AlignLeft: "radix-icons:text-align-left",
  AlignRight: "radix-icons:text-align-right",
  ChevronUp: "lucide:chevron-up",
  ChevronDown: "lucide:chevron-down",
  Subscript: "lucide:subscript",
  Superscript: "lucide:superscript",
  Code: "lucide:code",
  Code2: "lucide:code-2",
  Type: "lucide:type",
  IndentIncrease: "lucide:indent-increase",
  IndentDecrease: "lucide:indent-decrease",
  List: "lucide:list",
  ListOrdered: "lucide:list-ordered",
  ListTodo: "lucide:list-todo",
  Link: "lucide:link",
  ImageUp: "lucide:image-up",
  Video: "lucide:video",
  Maximize: "lucide:maximize",
  Minimize: "lucide:minimize",
  Table: "lucide:table",
  Sparkles: "lucide:sparkles",
  Magic: "mdi:magic",
  Pencil: "lucide:pencil",
  Unlink: "lucide:unlink",
  BetweenHorizonalEnd: "lucide:between-horizontal-end",
  BetweenHorizonalStart: "lucide:between-horizontal-start",
  ColumnDelete: "hugeicons:column-delete",
  BetweenVerticalStart: "lucide:between-vertical-start",
  BetweenVerticalEnd: "lucide:between-vertical-end",
  RowDelete: "hugeicons:row-delete",
  TableCellsMerge: "lucide:table-cells-merge",
  TableCellsSplit: "lucide:table-cells-split",
  Trash2: "lucide:trash-2",
  Trash: "lucide:trash",
  Replace: "lucide:replace",
  ChevronsUpDown: "lucide:chevrons-up-down",
  LineHeight: "mdi:format-line-height",
  Word: "mdi:file-word-outline",
  Paragraph: "ci:text",
  Heading1: "lucide:heading-1",
  Heading2: "lucide:heading-2",
  Heading3: "lucide:heading-3",
  Columns2: "lucide:columns-2",
  Columns3: "lucide:columns-3",
  Columns4: "lucide:columns-4",
  Plus: "lucide:plus",
  Grip: "lucide:grip-vertical",
  Copy: "lucide:copy",
  Clipboard: "lucide:clipboard",
  MenuDown: "icon-park-solid:down-one",
  SizeS: "mdi:size-s",
  SizeM: "mdi:size-m",
  SizeL: "mdi:size-l",
  AspectRatio: "mdi:aspect-ratio",
  Gaode: "echo-gaode",
  Baidu: "echo-baidu",
  Youku: "echo-youku",
  BiliBili: "echo-bilibili",
  Modao: "echo-modao",
  Lanhu: "echo-lanhu",
  QQVideo: "echo-qqvideo",
  Figma: "echo-figma",
  Canva: "echo-canva",
  Processon: "echo-processon",
  Codepen: "echo-codepen",
  Jinshuju: "echo-jinshuju",
  PanelLeft: "lucide:panel-left",
  PanelRight: "lucide:panel-right",
  Columns: "lucide:columns",
  AI: "meteocons:star-fill",
  ChevronRight: "lucide:chevron-right",
  ArrowUp: "lucide:arrow-up",
  Paste: "lucide:clipboard-paste",
  Cut: "lucide:scissors",
  File: "lucide:file",
  Refresh: "lucide:refresh-ccw",
  Eye: "lucide:eye",
  Printer: "lucide:printer",
  Tablet: "lucide:tablet",
  Phone: "lucide:smartphone",
  Monitor: "lucide:monitor",
  TextSelect: "lucide:text-select",
  SpellCheck: "lucide:spell-check-2",
  DocSearch: "lucide:text-search",
  Close: "lucide:x",
  ImageSize: "fluent:resize-image-24-filled",
  FlipVertical: "lucide:flip-vertical",
  FlipHorizontal: "lucide:flip-horizontal"
}, va = /^[a-z0-9]+(-[a-z0-9]+)*$/, ju = (t, e, n, o = "") => {
  const r = t.split(":");
  if (t.slice(0, 1) === "@") {
    if (r.length < 2 || r.length > 3)
      return null;
    o = r.shift().slice(1);
  }
  if (r.length > 3 || !r.length)
    return null;
  if (r.length > 1) {
    const a = r.pop(), l = r.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: r.length > 0 ? r[0] : o,
      prefix: l,
      name: a
    };
    return e && !Ic(c) ? null : c;
  }
  const i = r[0], s = i.split("-");
  if (s.length > 1) {
    const a = {
      provider: o,
      prefix: s.shift(),
      name: s.join("-")
    };
    return e && !Ic(a) ? null : a;
  }
  if (n && o === "") {
    const a = {
      provider: o,
      prefix: "",
      name: i
    };
    return e && !Ic(a, n) ? null : a;
  }
  return null;
}, Ic = (t, e) => t ? !!((t.provider === "" || t.provider.match(va)) && (e && t.prefix === "" || t.prefix.match(va)) && t.name.match(va)) : !1, t3 = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), md = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), Uu = Object.freeze({
  ...t3,
  ...md
}), Ch = Object.freeze({
  ...Uu,
  body: "",
  hidden: !1
});
function PN(t, e) {
  const n = {};
  !t.hFlip != !e.hFlip && (n.hFlip = !0), !t.vFlip != !e.vFlip && (n.vFlip = !0);
  const o = ((t.rotate || 0) + (e.rotate || 0)) % 4;
  return o && (n.rotate = o), n;
}
function Uv(t, e) {
  const n = PN(t, e);
  for (const o in Ch)
    o in md ? o in t && !(o in n) && (n[o] = md[o]) : o in e ? n[o] = e[o] : o in t && (n[o] = t[o]);
  return n;
}
function LN(t, e) {
  const n = t.icons, o = t.aliases || /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  function i(s) {
    if (n[s])
      return r[s] = [];
    if (!(s in r)) {
      r[s] = null;
      const a = o[s] && o[s].parent, l = a && i(a);
      l && (r[s] = [a].concat(l));
    }
    return r[s];
  }
  return Object.keys(n).concat(Object.keys(o)).forEach(i), r;
}
function NN(t, e, n) {
  const o = t.icons, r = t.aliases || /* @__PURE__ */ Object.create(null);
  let i = {};
  function s(a) {
    i = Uv(
      o[a] || r[a],
      i
    );
  }
  return s(e), n.forEach(s), Uv(t, i);
}
function n3(t, e) {
  const n = [];
  if (typeof t != "object" || typeof t.icons != "object")
    return n;
  t.not_found instanceof Array && t.not_found.forEach((r) => {
    e(r, null), n.push(r);
  });
  const o = LN(t);
  for (const r in o) {
    const i = o[r];
    i && (e(r, NN(t, r, i)), n.push(r));
  }
  return n;
}
const BN = {
  provider: "",
  aliases: {},
  not_found: {},
  ...t3
};
function Uf(t, e) {
  for (const n in e)
    if (n in t && typeof t[n] != typeof e[n])
      return !1;
  return !0;
}
function o3(t) {
  if (typeof t != "object" || t === null)
    return null;
  const e = t;
  if (typeof e.prefix != "string" || !t.icons || typeof t.icons != "object" || !Uf(t, BN))
    return null;
  const n = e.icons;
  for (const r in n) {
    const i = n[r];
    if (!r.match(va) || typeof i.body != "string" || !Uf(
      i,
      Ch
    ))
      return null;
  }
  const o = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const r in o) {
    const i = o[r], s = i.parent;
    if (!r.match(va) || typeof s != "string" || !n[s] && !o[s] || !Uf(
      i,
      Ch
    ))
      return null;
  }
  return e;
}
const Wv = /* @__PURE__ */ Object.create(null);
function $N(t, e) {
  return {
    provider: t,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function bi(t, e) {
  const n = Wv[t] || (Wv[t] = /* @__PURE__ */ Object.create(null));
  return n[e] || (n[e] = $N(t, e));
}
function _g(t, e) {
  return o3(e) ? n3(e, (n, o) => {
    o ? t.icons[n] = o : t.missing.add(n);
  }) : [];
}
function zN(t, e, n) {
  try {
    if (typeof n.body == "string")
      return t.icons[e] = { ...n }, !0;
  } catch {
  }
  return !1;
}
let Qa = !1;
function r3(t) {
  return typeof t == "boolean" && (Qa = t), Qa;
}
function FN(t) {
  const e = typeof t == "string" ? ju(t, !0, Qa) : t;
  if (e) {
    const n = bi(e.provider, e.prefix), o = e.name;
    return n.icons[o] || (n.missing.has(o) ? null : void 0);
  }
}
function HN(t, e) {
  const n = ju(t, !0, Qa);
  if (!n)
    return !1;
  const o = bi(n.provider, n.prefix);
  return zN(o, n.name, e);
}
function i3(t, e) {
  if (typeof t != "object")
    return !1;
  if (typeof e != "string" && (e = t.provider || ""), Qa && !e && !t.prefix) {
    let r = !1;
    return o3(t) && (t.prefix = "", n3(t, (i, s) => {
      s && HN(i, s) && (r = !0);
    })), r;
  }
  const n = t.prefix;
  if (!Ic({
    provider: e,
    prefix: n,
    name: "a"
  }))
    return !1;
  const o = bi(e, n);
  return !!_g(o, t);
}
const s3 = Object.freeze({
  width: null,
  height: null
}), a3 = Object.freeze({
  // Dimensions
  ...s3,
  // Transformations
  ...md
}), VN = /(-?[0-9.]*[0-9]+[0-9.]*)/g, jN = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Kv(t, e, n) {
  if (e === 1)
    return t;
  if (n = n || 100, typeof t == "number")
    return Math.ceil(t * e * n) / n;
  if (typeof t != "string")
    return t;
  const o = t.split(VN);
  if (o === null || !o.length)
    return t;
  const r = [];
  let i = o.shift(), s = jN.test(i);
  for (; ; ) {
    if (s) {
      const a = parseFloat(i);
      isNaN(a) ? r.push(i) : r.push(Math.ceil(a * e * n) / n);
    } else
      r.push(i);
    if (i = o.shift(), i === void 0)
      return r.join("");
    s = !s;
  }
}
function UN(t, e = "defs") {
  let n = "";
  const o = t.indexOf("<" + e);
  for (; o >= 0; ) {
    const r = t.indexOf(">", o), i = t.indexOf("</" + e);
    if (r === -1 || i === -1)
      break;
    const s = t.indexOf(">", i);
    if (s === -1)
      break;
    n += t.slice(r + 1, i).trim(), t = t.slice(0, o).trim() + t.slice(s + 1);
  }
  return {
    defs: n,
    content: t
  };
}
function WN(t, e) {
  return t ? "<defs>" + t + "</defs>" + e : e;
}
function KN(t, e, n) {
  const o = UN(t);
  return WN(o.defs, e + o.content + n);
}
const qN = (t) => t === "unset" || t === "undefined" || t === "none";
function GN(t, e) {
  const n = {
    ...Uu,
    ...t
  }, o = {
    ...a3,
    ...e
  }, r = {
    left: n.left,
    top: n.top,
    width: n.width,
    height: n.height
  };
  let i = n.body;
  [n, o].forEach((g) => {
    const v = [], y = g.hFlip, x = g.vFlip;
    let C = g.rotate;
    y ? x ? C += 2 : (v.push(
      "translate(" + (r.width + r.left).toString() + " " + (0 - r.top).toString() + ")"
    ), v.push("scale(-1 1)"), r.top = r.left = 0) : x && (v.push(
      "translate(" + (0 - r.left).toString() + " " + (r.height + r.top).toString() + ")"
    ), v.push("scale(1 -1)"), r.top = r.left = 0);
    let b;
    switch (C < 0 && (C -= Math.floor(C / 4) * 4), C = C % 4, C) {
      case 1:
        b = r.height / 2 + r.top, v.unshift(
          "rotate(90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
      case 2:
        v.unshift(
          "rotate(180 " + (r.width / 2 + r.left).toString() + " " + (r.height / 2 + r.top).toString() + ")"
        );
        break;
      case 3:
        b = r.width / 2 + r.left, v.unshift(
          "rotate(-90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
    }
    C % 2 === 1 && (r.left !== r.top && (b = r.left, r.left = r.top, r.top = b), r.width !== r.height && (b = r.width, r.width = r.height, r.height = b)), v.length && (i = KN(
      i,
      '<g transform="' + v.join(" ") + '">',
      "</g>"
    ));
  });
  const s = o.width, a = o.height, l = r.width, c = r.height;
  let d, u;
  s === null ? (u = a === null ? "1em" : a === "auto" ? c : a, d = Kv(u, l / c)) : (d = s === "auto" ? l : s, u = a === null ? Kv(d, c / l) : a === "auto" ? c : a);
  const f = {}, h = (g, v) => {
    qN(v) || (f[g] = v.toString());
  };
  h("width", d), h("height", u);
  const m = [r.left, r.top, l, c];
  return f.viewBox = m.join(" "), {
    attributes: f,
    viewBox: m,
    body: i
  };
}
const JN = /\sid="(\S+)"/g, YN = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let XN = 0;
function ZN(t, e = YN) {
  const n = [];
  let o;
  for (; o = JN.exec(t); )
    n.push(o[1]);
  if (!n.length)
    return t;
  const r = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return n.forEach((i) => {
    const s = typeof e == "function" ? e(i) : e + (XN++).toString(), a = i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t = t.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + a + ')([")]|\\.[a-z])', "g"),
      "$1" + s + r + "$3"
    );
  }), t = t.replace(new RegExp(r, "g"), ""), t;
}
const Sh = /* @__PURE__ */ Object.create(null);
function QN(t, e) {
  Sh[t] = e;
}
function Ah(t) {
  return Sh[t] || Sh[""];
}
function Mg(t) {
  let e;
  if (typeof t.resources == "string")
    e = [t.resources];
  else if (e = t.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    // API hosts
    resources: e,
    // Root path
    path: t.path || "/",
    // URL length limit
    maxURL: t.maxURL || 500,
    // Timeout before next host is used.
    rotate: t.rotate || 750,
    // Timeout before failing query.
    timeout: t.timeout || 5e3,
    // Randomise default API end point.
    random: t.random === !0,
    // Start index
    index: t.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: t.dataAfterTimeout !== !1
  };
}
const Tg = /* @__PURE__ */ Object.create(null), Qs = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], Dc = [];
for (; Qs.length > 0; )
  Qs.length === 1 || Math.random() > 0.5 ? Dc.push(Qs.shift()) : Dc.push(Qs.pop());
Tg[""] = Mg({
  resources: ["https://api.iconify.design"].concat(Dc)
});
function eB(t, e) {
  const n = Mg(e);
  return n === null ? !1 : (Tg[t] = n, !0);
}
function Og(t) {
  return Tg[t];
}
const tB = () => {
  let t;
  try {
    if (t = fetch, typeof t == "function")
      return t;
  } catch {
  }
};
let qv = tB();
function nB(t, e) {
  const n = Og(t);
  if (!n)
    return 0;
  let o;
  if (!n.maxURL)
    o = 0;
  else {
    let r = 0;
    n.resources.forEach((s) => {
      r = Math.max(r, s.length);
    });
    const i = e + ".json?icons=";
    o = n.maxURL - r - n.path.length - i.length;
  }
  return o;
}
function oB(t) {
  return t === 404;
}
const rB = (t, e, n) => {
  const o = [], r = nB(t, e), i = "icons";
  let s = {
    type: i,
    provider: t,
    prefix: e,
    icons: []
  }, a = 0;
  return n.forEach((l, c) => {
    a += l.length + 1, a >= r && c > 0 && (o.push(s), s = {
      type: i,
      provider: t,
      prefix: e,
      icons: []
    }, a = l.length), s.icons.push(l);
  }), o.push(s), o;
};
function iB(t) {
  if (typeof t == "string") {
    const e = Og(t);
    if (e)
      return e.path;
  }
  return "/";
}
const sB = (t, e, n) => {
  if (!qv) {
    n("abort", 424);
    return;
  }
  let o = iB(e.provider);
  switch (e.type) {
    case "icons": {
      const i = e.prefix, a = e.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      o += i + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const i = e.uri;
      o += i.slice(0, 1) === "/" ? i.slice(1) : i;
      break;
    }
    default:
      n("abort", 400);
      return;
  }
  let r = 503;
  qv(t + o).then((i) => {
    const s = i.status;
    if (s !== 200) {
      setTimeout(() => {
        n(oB(s) ? "abort" : "next", s);
      });
      return;
    }
    return r = 501, i.json();
  }).then((i) => {
    if (typeof i != "object" || i === null) {
      setTimeout(() => {
        i === 404 ? n("abort", i) : n("next", r);
      });
      return;
    }
    setTimeout(() => {
      n("success", i);
    });
  }).catch(() => {
    n("next", r);
  });
}, aB = {
  prepare: rB,
  send: sB
};
function lB(t) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, n = /* @__PURE__ */ Object.create(null);
  t.sort((r, i) => r.provider !== i.provider ? r.provider.localeCompare(i.provider) : r.prefix !== i.prefix ? r.prefix.localeCompare(i.prefix) : r.name.localeCompare(i.name));
  let o = {
    provider: "",
    prefix: "",
    name: ""
  };
  return t.forEach((r) => {
    if (o.name === r.name && o.prefix === r.prefix && o.provider === r.provider)
      return;
    o = r;
    const i = r.provider, s = r.prefix, a = r.name, l = n[i] || (n[i] = /* @__PURE__ */ Object.create(null)), c = l[s] || (l[s] = bi(i, s));
    let d;
    a in c.icons ? d = e.loaded : s === "" || c.missing.has(a) ? d = e.missing : d = e.pending;
    const u = {
      provider: i,
      prefix: s,
      name: a
    };
    d.push(u);
  }), e;
}
function l3(t, e) {
  t.forEach((n) => {
    const o = n.loaderCallbacks;
    o && (n.loaderCallbacks = o.filter((r) => r.id !== e));
  });
}
function cB(t) {
  t.pendingCallbacksFlag || (t.pendingCallbacksFlag = !0, setTimeout(() => {
    t.pendingCallbacksFlag = !1;
    const e = t.loaderCallbacks ? t.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let n = !1;
    const o = t.provider, r = t.prefix;
    e.forEach((i) => {
      const s = i.icons, a = s.pending.length;
      s.pending = s.pending.filter((l) => {
        if (l.prefix !== r)
          return !0;
        const c = l.name;
        if (t.icons[c])
          s.loaded.push({
            provider: o,
            prefix: r,
            name: c
          });
        else if (t.missing.has(c))
          s.missing.push({
            provider: o,
            prefix: r,
            name: c
          });
        else
          return n = !0, !0;
        return !1;
      }), s.pending.length !== a && (n || l3([t], i.id), i.callback(
        s.loaded.slice(0),
        s.missing.slice(0),
        s.pending.slice(0),
        i.abort
      ));
    });
  }));
}
let dB = 0;
function uB(t, e, n) {
  const o = dB++, r = l3.bind(null, n, o);
  if (!e.pending.length)
    return r;
  const i = {
    id: o,
    icons: e,
    callback: t,
    abort: r
  };
  return n.forEach((s) => {
    (s.loaderCallbacks || (s.loaderCallbacks = [])).push(i);
  }), r;
}
function fB(t, e = !0, n = !1) {
  const o = [];
  return t.forEach((r) => {
    const i = typeof r == "string" ? ju(r, e, n) : r;
    i && o.push(i);
  }), o;
}
var pB = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function hB(t, e, n, o) {
  const r = t.resources.length, i = t.random ? Math.floor(Math.random() * r) : t.index;
  let s;
  if (t.random) {
    let A = t.resources.slice(0);
    for (s = []; A.length > 1; ) {
      const I = Math.floor(Math.random() * A.length);
      s.push(A[I]), A = A.slice(0, I).concat(A.slice(I + 1));
    }
    s = s.concat(A);
  } else
    s = t.resources.slice(i).concat(t.resources.slice(0, i));
  const a = Date.now();
  let l = "pending", c = 0, d, u = null, f = [], h = [];
  typeof o == "function" && h.push(o);
  function m() {
    u && (clearTimeout(u), u = null);
  }
  function g() {
    l === "pending" && (l = "aborted"), m(), f.forEach((A) => {
      A.status === "pending" && (A.status = "aborted");
    }), f = [];
  }
  function v(A, I) {
    I && (h = []), typeof A == "function" && h.push(A);
  }
  function y() {
    return {
      startTime: a,
      payload: e,
      status: l,
      queriesSent: c,
      queriesPending: f.length,
      subscribe: v,
      abort: g
    };
  }
  function x() {
    l = "failed", h.forEach((A) => {
      A(void 0, d);
    });
  }
  function C() {
    f.forEach((A) => {
      A.status === "pending" && (A.status = "aborted");
    }), f = [];
  }
  function b(A, I, z) {
    const N = I !== "success";
    switch (f = f.filter((M) => M !== A), l) {
      case "pending":
        break;
      case "failed":
        if (N || !t.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (I === "abort") {
      d = z, x();
      return;
    }
    if (N) {
      d = z, f.length || (s.length ? S() : x());
      return;
    }
    if (m(), C(), !t.random) {
      const M = t.resources.indexOf(A.resource);
      M !== -1 && M !== t.index && (t.index = M);
    }
    l = "completed", h.forEach((M) => {
      M(z);
    });
  }
  function S() {
    if (l !== "pending")
      return;
    m();
    const A = s.shift();
    if (A === void 0) {
      if (f.length) {
        u = setTimeout(() => {
          m(), l === "pending" && (C(), x());
        }, t.timeout);
        return;
      }
      x();
      return;
    }
    const I = {
      status: "pending",
      resource: A,
      callback: (z, N) => {
        b(I, z, N);
      }
    };
    f.push(I), c++, u = setTimeout(S, t.rotate), n(A, e, I.callback);
  }
  return setTimeout(S), y;
}
function c3(t) {
  const e = {
    ...pB,
    ...t
  };
  let n = [];
  function o() {
    n = n.filter((a) => a().status === "pending");
  }
  function r(a, l, c) {
    const d = hB(
      e,
      a,
      l,
      (u, f) => {
        o(), c && c(u, f);
      }
    );
    return n.push(d), d;
  }
  function i(a) {
    return n.find((l) => a(l)) || null;
  }
  return {
    query: r,
    find: i,
    setIndex: (a) => {
      e.index = a;
    },
    getIndex: () => e.index,
    cleanup: o
  };
}
function Gv() {
}
const Wf = /* @__PURE__ */ Object.create(null);
function mB(t) {
  if (!Wf[t]) {
    const e = Og(t);
    if (!e)
      return;
    const n = c3(e), o = {
      config: e,
      redundancy: n
    };
    Wf[t] = o;
  }
  return Wf[t];
}
function gB(t, e, n) {
  let o, r;
  if (typeof t == "string") {
    const i = Ah(t);
    if (!i)
      return n(void 0, 424), Gv;
    r = i.send;
    const s = mB(t);
    s && (o = s.redundancy);
  } else {
    const i = Mg(t);
    if (i) {
      o = c3(i);
      const s = t.resources ? t.resources[0] : "", a = Ah(s);
      a && (r = a.send);
    }
  }
  return !o || !r ? (n(void 0, 424), Gv) : o.query(e, r, n)().abort;
}
const Jv = "iconify2", el = "iconify", d3 = el + "-count", Yv = el + "-version", u3 = 36e5, vB = 168, yB = 50;
function Eh(t, e) {
  try {
    return t.getItem(e);
  } catch {
  }
}
function Ig(t, e, n) {
  try {
    return t.setItem(e, n), !0;
  } catch {
  }
}
function Xv(t, e) {
  try {
    t.removeItem(e);
  } catch {
  }
}
function _h(t, e) {
  return Ig(t, d3, e.toString());
}
function Mh(t) {
  return parseInt(Eh(t, d3)) || 0;
}
const Wu = {
  local: !0,
  session: !0
}, f3 = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let Dg = !1;
function bB(t) {
  Dg = t;
}
let lc = typeof window > "u" ? {} : window;
function p3(t) {
  const e = t + "Storage";
  try {
    if (lc && lc[e] && typeof lc[e].length == "number")
      return lc[e];
  } catch {
  }
  Wu[t] = !1;
}
function h3(t, e) {
  const n = p3(t);
  if (!n)
    return;
  const o = Eh(n, Yv);
  if (o !== Jv) {
    if (o) {
      const a = Mh(n);
      for (let l = 0; l < a; l++)
        Xv(n, el + l.toString());
    }
    Ig(n, Yv, Jv), _h(n, 0);
    return;
  }
  const r = Math.floor(Date.now() / u3) - vB, i = (a) => {
    const l = el + a.toString(), c = Eh(n, l);
    if (typeof c == "string") {
      try {
        const d = JSON.parse(c);
        if (typeof d == "object" && typeof d.cached == "number" && d.cached > r && typeof d.provider == "string" && typeof d.data == "object" && typeof d.data.prefix == "string" && // Valid item: run callback
        e(d, a))
          return !0;
      } catch {
      }
      Xv(n, l);
    }
  };
  let s = Mh(n);
  for (let a = s - 1; a >= 0; a--)
    i(a) || (a === s - 1 ? (s--, _h(n, s)) : f3[t].add(a));
}
function m3() {
  if (!Dg) {
    bB(!0);
    for (const t in Wu)
      h3(t, (e) => {
        const n = e.data, o = e.provider, r = n.prefix, i = bi(
          o,
          r
        );
        if (!_g(i, n).length)
          return !1;
        const s = n.lastModified || -1;
        return i.lastModifiedCached = i.lastModifiedCached ? Math.min(i.lastModifiedCached, s) : s, !0;
      });
  }
}
function wB(t, e) {
  const n = t.lastModifiedCached;
  if (
    // Matches or newer
    n && n >= e
  )
    return n === e;
  if (t.lastModifiedCached = e, n)
    for (const o in Wu)
      h3(o, (r) => {
        const i = r.data;
        return r.provider !== t.provider || i.prefix !== t.prefix || i.lastModified === e;
      });
  return !0;
}
function xB(t, e) {
  Dg || m3();
  function n(o) {
    let r;
    if (!Wu[o] || !(r = p3(o)))
      return;
    const i = f3[o];
    let s;
    if (i.size)
      i.delete(s = Array.from(i).shift());
    else if (s = Mh(r), s >= yB || !_h(r, s + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / u3),
      provider: t.provider,
      data: e
    };
    return Ig(
      r,
      el + s.toString(),
      JSON.stringify(a)
    );
  }
  e.lastModified && !wB(t, e.lastModified) || Object.keys(e.icons).length && (e.not_found && (e = Object.assign({}, e), delete e.not_found), n("local") || n("session"));
}
function Zv() {
}
function kB(t) {
  t.iconsLoaderFlag || (t.iconsLoaderFlag = !0, setTimeout(() => {
    t.iconsLoaderFlag = !1, cB(t);
  }));
}
function CB(t, e) {
  t.iconsToLoad ? t.iconsToLoad = t.iconsToLoad.concat(e).sort() : t.iconsToLoad = e, t.iconsQueueFlag || (t.iconsQueueFlag = !0, setTimeout(() => {
    t.iconsQueueFlag = !1;
    const { provider: n, prefix: o } = t, r = t.iconsToLoad;
    delete t.iconsToLoad;
    let i;
    if (!r || !(i = Ah(n)))
      return;
    i.prepare(n, o, r).forEach((a) => {
      gB(n, a, (l) => {
        if (typeof l != "object")
          a.icons.forEach((c) => {
            t.missing.add(c);
          });
        else
          try {
            const c = _g(
              t,
              l
            );
            if (!c.length)
              return;
            const d = t.pendingIcons;
            d && c.forEach((u) => {
              d.delete(u);
            }), xB(t, l);
          } catch (c) {
            console.error(c);
          }
        kB(t);
      });
    });
  }));
}
const SB = (t, e) => {
  const n = fB(t, !0, r3()), o = lB(n);
  if (!o.pending.length) {
    let l = !0;
    return e && setTimeout(() => {
      l && e(
        o.loaded,
        o.missing,
        o.pending,
        Zv
      );
    }), () => {
      l = !1;
    };
  }
  const r = /* @__PURE__ */ Object.create(null), i = [];
  let s, a;
  return o.pending.forEach((l) => {
    const { provider: c, prefix: d } = l;
    if (d === a && c === s)
      return;
    s = c, a = d, i.push(bi(c, d));
    const u = r[c] || (r[c] = /* @__PURE__ */ Object.create(null));
    u[d] || (u[d] = []);
  }), o.pending.forEach((l) => {
    const { provider: c, prefix: d, name: u } = l, f = bi(c, d), h = f.pendingIcons || (f.pendingIcons = /* @__PURE__ */ new Set());
    h.has(u) || (h.add(u), r[c][d].push(u));
  }), i.forEach((l) => {
    const { provider: c, prefix: d } = l;
    r[c][d].length && CB(l, r[c][d]);
  }), e ? uB(e, o, i) : Zv;
};
function AB(t, e) {
  const n = {
    ...t
  };
  for (const o in e) {
    const r = e[o], i = typeof r;
    o in s3 ? (r === null || r && (i === "string" || i === "number")) && (n[o] = r) : i === typeof n[o] && (n[o] = o === "rotate" ? r % 4 : r);
  }
  return n;
}
const EB = /[\s,]+/;
function _B(t, e) {
  e.split(EB).forEach((n) => {
    switch (n.trim()) {
      case "horizontal":
        t.hFlip = !0;
        break;
      case "vertical":
        t.vFlip = !0;
        break;
    }
  });
}
function MB(t, e = 0) {
  const n = t.replace(/^-?[0-9.]*/, "");
  function o(r) {
    for (; r < 0; )
      r += 4;
    return r % 4;
  }
  if (n === "") {
    const r = parseInt(t);
    return isNaN(r) ? 0 : o(r);
  } else if (n !== t) {
    let r = 0;
    switch (n) {
      case "%":
        r = 25;
        break;
      case "deg":
        r = 90;
    }
    if (r) {
      let i = parseFloat(t.slice(0, t.length - n.length));
      return isNaN(i) ? 0 : (i = i / r, i % 1 === 0 ? o(i) : 0);
    }
  }
  return e;
}
function TB(t, e) {
  let n = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const o in e)
    n += " " + o + '="' + e[o] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + t + "</svg>";
}
function OB(t) {
  return t.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function IB(t) {
  return "data:image/svg+xml," + OB(t);
}
function DB(t) {
  return 'url("' + IB(t) + '")';
}
const Qv = {
  ...a3,
  inline: !1
}, RB = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, PB = {
  display: "inline-block"
}, Th = {
  backgroundColor: "currentColor"
}, g3 = {
  backgroundColor: "transparent"
}, ey = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, ty = {
  webkitMask: Th,
  mask: Th,
  background: g3
};
for (const t in ty) {
  const e = ty[t];
  for (const n in ey)
    e[t + n] = ey[n];
}
const Rc = {};
["horizontal", "vertical"].forEach((t) => {
  const e = t.slice(0, 1) + "Flip";
  Rc[t + "-flip"] = e, Rc[t.slice(0, 1) + "-flip"] = e, Rc[t + "Flip"] = e;
});
function ny(t) {
  return t + (t.match(/^[-0-9.]+$/) ? "px" : "");
}
const oy = (t, e) => {
  const n = AB(Qv, e), o = { ...RB }, r = e.mode || "svg", i = {}, s = e.style, a = typeof s == "object" && !(s instanceof Array) ? s : {};
  for (let g in e) {
    const v = e[g];
    if (v !== void 0)
      switch (g) {
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          n[g] = v === !0 || v === "true" || v === 1;
          break;
        case "flip":
          typeof v == "string" && _B(n, v);
          break;
        case "color":
          i.color = v;
          break;
        case "rotate":
          typeof v == "string" ? n[g] = MB(v) : typeof v == "number" && (n[g] = v);
          break;
        case "ariaHidden":
        case "aria-hidden":
          v !== !0 && v !== "true" && delete o["aria-hidden"];
          break;
        default: {
          const y = Rc[g];
          y ? (v === !0 || v === "true" || v === 1) && (n[y] = !0) : Qv[g] === void 0 && (o[g] = v);
        }
      }
  }
  const l = GN(t, n), c = l.attributes;
  if (n.inline && (i.verticalAlign = "-0.125em"), r === "svg") {
    o.style = {
      ...i,
      ...a
    }, Object.assign(o, c);
    let g = 0, v = e.id;
    return typeof v == "string" && (v = v.replace(/-/g, "_")), o.innerHTML = ZN(l.body, v ? () => v + "ID" + g++ : "iconifyVue"), jt("svg", o);
  }
  const { body: d, width: u, height: f } = t, h = r === "mask" || (r === "bg" ? !1 : d.indexOf("currentColor") !== -1), m = TB(d, {
    ...c,
    width: u + "",
    height: f + ""
  });
  return o.style = {
    ...i,
    "--svg": DB(m),
    width: ny(c.width),
    height: ny(c.height),
    ...PB,
    ...h ? Th : g3,
    ...a
  }, jt("span", o);
};
r3(!0);
QN("", aB);
if (typeof document < "u" && typeof window < "u") {
  m3();
  const t = window;
  if (t.IconifyPreload !== void 0) {
    const e = t.IconifyPreload, n = "Invalid IconifyPreload syntax.";
    typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((o) => {
      try {
        // Check if item is an object and not null/array
        (typeof o != "object" || o === null || o instanceof Array || // Check for 'icons' and 'prefix'
        typeof o.icons != "object" || typeof o.prefix != "string" || // Add icon set
        !i3(o)) && console.error(n);
      } catch {
        console.error(n);
      }
    });
  }
  if (t.IconifyProviders !== void 0) {
    const e = t.IconifyProviders;
    if (typeof e == "object" && e !== null)
      for (let n in e) {
        const o = "IconifyProviders[" + n + "] is invalid.";
        try {
          const r = e[n];
          if (typeof r != "object" || !r || r.resources === void 0)
            continue;
          eB(n, r) || console.error(o);
        } catch {
          console.error(o);
        }
      }
  }
}
const LB = {
  ...Uu,
  body: ""
}, NB = T({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: !1,
  // Set initial data
  data() {
    return {
      // Current icon name
      _name: "",
      // Loading
      _loadingIcon: null,
      // Mounted status
      iconMounted: !1,
      // Callback counter to trigger re-render
      counter: 0
    };
  },
  mounted() {
    this.iconMounted = !0;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      this._loadingIcon && (this._loadingIcon.abort(), this._loadingIcon = null);
    },
    // Get data for icon to render or null
    getIcon(t, e) {
      if (typeof t == "object" && t !== null && typeof t.body == "string")
        return this._name = "", this.abortLoading(), {
          data: t
        };
      let n;
      if (typeof t != "string" || (n = ju(t, !1, !0)) === null)
        return this.abortLoading(), null;
      const o = FN(n);
      if (!o)
        return (!this._loadingIcon || this._loadingIcon.name !== t) && (this.abortLoading(), this._name = "", o !== null && (this._loadingIcon = {
          name: t,
          abort: SB([n], () => {
            this.counter++;
          })
        })), null;
      this.abortLoading(), this._name !== t && (this._name = t, e && e(t));
      const r = ["iconify"];
      return n.prefix !== "" && r.push("iconify--" + n.prefix), n.provider !== "" && r.push("iconify--" + n.provider), { data: o, classes: r };
    }
  },
  // Render icon
  render() {
    this.counter;
    const t = this.$attrs, e = this.iconMounted || t.ssr ? this.getIcon(t.icon, t.onLoad) : null;
    if (!e)
      return oy(LB, t);
    let n = t;
    return e.classes && (n = {
      ...t,
      class: (typeof t.class == "string" ? t.class + " " : "") + e.classes.join(" ")
    }), oy({
      ...Uu,
      ...e.data
    }, n);
  }
}), xe = /* @__PURE__ */ T({
  __name: "Icon",
  props: {
    name: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => RN[e.name]);
    return n.value || console.error(`Icon ${e.name} not found`), (o, r) => (k(), _(p(NB), {
      icon: n.value,
      class: Ze(p(fe)("w-4 h-4", e.class))
    }, null, 8, ["icon", "class"]));
  }
}), Rr = /* @__PURE__ */ T({
  __name: "Input",
  props: {
    defaultValue: {},
    modelValue: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, r = wO(n, "modelValue", e, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (i, s) => Sn((k(), U("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (a) => ri(r) ? r.value = a : null),
      class: Ze(
        p(fe)(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          n.class
        )
      )
    }, null, 2)), [
      [s8, p(r)]
    ]);
  }
}), ya = /* @__PURE__ */ T({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(MR), j(n.value, {
      class: p(fe)("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70", e.class)
    }), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
function v3(t) {
  var e, n, o = "";
  if (typeof t == "string" || typeof t == "number")
    o += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (n = v3(t[e])) && (o && (o += " "), o += n);
    else
      for (e in t)
        t[e] && (o && (o += " "), o += e);
  return o;
}
function BB() {
  for (var t, e, n = 0, o = ""; n < arguments.length; )
    (t = arguments[n++]) && (e = v3(t)) && (o && (o += " "), o += e);
  return o;
}
const ry = (t) => typeof t == "boolean" ? "".concat(t) : t === 0 ? "0" : t, iy = BB, Rg = (t, e) => (n) => {
  var o;
  if ((e == null ? void 0 : e.variants) == null)
    return iy(t, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: r, defaultVariants: i } = e, s = Object.keys(r).map((c) => {
    const d = n == null ? void 0 : n[c], u = i == null ? void 0 : i[c];
    if (d === null)
      return null;
    const f = ry(d) || ry(u);
    return r[c][f];
  }), a = n && Object.entries(n).reduce((c, d) => {
    let [u, f] = d;
    return f === void 0 || (c[u] = f), c;
  }, {}), l = e == null || (o = e.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((c, d) => {
    let { class: u, className: f, ...h } = d;
    return Object.entries(h).every((m) => {
      let [g, v] = m;
      return Array.isArray(v) ? v.includes({
        ...i,
        ...a
      }[g]) : {
        ...i,
        ...a
      }[g] === v;
    }) ? [
      ...c,
      u,
      f
    ] : c;
  }, []);
  return iy(t, s, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
}, Pt = /* @__PURE__ */ T({
  __name: "Button",
  props: {
    variant: {},
    size: {},
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(se), {
      as: n.as,
      "as-child": n.asChild,
      class: Ze(p(fe)(p($B)({ variant: n.variant, size: n.size }), e.class))
    }, {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), $B = Rg(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        xs: "h-7 rounded px-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), zB = { class: "flex w-full max-w-sm items-center gap-1.5" }, FB = { class: "relative w-full max-w-sm items-center" }, HB = { class: "flex w-full max-w-sm items-center gap-1.5" }, VB = { class: "relative w-full max-w-sm items-center" }, jB = { class: "absolute start-0 inset-y-0 flex items-center justify-center px-2" }, UB = { class: "flex items-center space-x-2 mt-1" }, y3 = /* @__PURE__ */ T({
  __name: "LinkEditBlock",
  props: {
    editor: {}
  },
  emits: ["onSetLink", "onClickOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, { t: r } = et();
    let i = zn({
      text: "",
      link: ""
    });
    const s = O(null), { focused: a } = Ym(s), l = O(!1), c = O(null);
    nO(c, (u) => o("onClickOutside", u)), Pe(() => {
      const { href: u, target: f } = n.editor.getAttributes("link"), { from: h, to: m } = n.editor.state.selection, g = n.editor.state.doc.textBetween(h, m, " ");
      i = {
        link: u,
        text: g
      }, l.value = f === "_blank";
    });
    function d() {
      o("onSetLink", i.link, i.text, l.value);
    }
    return _e(() => {
      a.value = !0;
    }), (u, f) => {
      const h = e3;
      return k(), U("div", {
        ref_key: "target",
        ref: c,
        class: "p-2 bg-white rounded-lg dark:bg-black shadow-sm border border-neutral-200 dark:border-neutral-800"
      }, [
        B("form", {
          onSubmit: yt(d, ["prevent"]),
          class: "flex flex-col gap-2"
        }, [
          E(p(ya), null, {
            default: w(() => [
              he(q(p(r)("editor.link.dialog.text")), 1)
            ]),
            _: 1
          }),
          B("div", zB, [
            B("div", FB, [
              E(p(Rr), {
                type: "text",
                modelValue: p(i).text,
                "onUpdate:modelValue": f[0] || (f[0] = (m) => p(i).text = m),
                required: "",
                class: "w-80",
                placeholder: "输入文本"
              }, null, 8, ["modelValue"])
            ])
          ]),
          E(p(ya), null, {
            default: w(() => [
              he(q(p(r)("editor.link.dialog.link")), 1)
            ]),
            _: 1
          }),
          B("div", HB, [
            B("div", VB, [
              E(p(Rr), {
                type: "url",
                ref_key: "inputRef",
                ref: s,
                modelValue: p(i).link,
                "onUpdate:modelValue": f[1] || (f[1] = (m) => p(i).link = m),
                required: "",
                class: "pl-10"
              }, null, 8, ["modelValue"]),
              B("span", jB, [
                E(p(xe), {
                  class: "size-5 text-muted-foreground",
                  name: "Link"
                })
              ])
            ])
          ]),
          B("div", UB, [
            E(h, {
              checked: l.value,
              "onUpdate:checked": f[2] || (f[2] = (m) => l.value = m),
              id: "openInNewTab"
            }, null, 8, ["checked"]),
            E(p(ya), { for: "openInNewTab" }, {
              default: w(() => [
                he(q(p(r)("editor.link.dialog.openInNewTab")), 1)
              ]),
              _: 1
            })
          ]),
          E(p(Pt), {
            type: "submit",
            class: "mt-2 self-end"
          }, {
            default: w(() => [
              he(q(p(r)("editor.link.dialog.button.apply")), 1)
            ]),
            _: 1
          })
        ], 32)
      ], 512);
    };
  }
});
let Kf;
function qf() {
  return Kf === void 0 && (Kf = navigator.platform.includes("Mac")), Kf;
}
function Ku(t) {
  return t.toLowerCase() === "mod" ? qf() ? "⌘" : "Ctrl" : t.toLowerCase() === "alt" ? qf() ? "⌥" : "Alt" : t.toLowerCase() === "shift" ? qf() ? "⇧" : "Shift" : t;
}
function To(t) {
  return t.map(Ku).join(" ");
}
const b3 = /* @__PURE__ */ T({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: { default: "default" },
    size: { default: "default" }
  },
  emits: ["update:pressed"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, size: a, variant: l, ...c } = n;
      return c;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(U4), j(p(i), {
      class: p(fe)(p(w3)({ variant: s.variant, size: s.size }), n.class)
    }), {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), w3 = Rg(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-9 px-3",
        sm: "h-8 px-2",
        lg: "h-10 px-3"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Is = /* @__PURE__ */ T({
  __name: "Tooltip",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = De(t, e);
    return (i, s) => (k(), _(p(HL), Oe(Le(p(r))), {
      default: w(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ds = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "TooltipContent",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(WL), null, {
      default: w(() => [
        E(p(UL), j({ ...p(i), ...s.$attrs }, {
          class: p(fe)(
            "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            n.class
          )
        }), {
          default: w(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Rs = /* @__PURE__ */ T({
  __name: "TooltipTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(VL), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ps = /* @__PURE__ */ T({
  __name: "TooltipProvider",
  props: {
    delayDuration: {},
    skipDelayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(zL), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), WB = { key: 0 }, KB = {
  key: 1,
  class: "flex gap-1 items-center"
}, qB = {
  key: 2,
  class: "ml-1 font-normal"
}, GB = { class: "max-w-24 text-center flex flex-col items-center" }, JB = {
  key: 0,
  style: { display: "flex", gap: "4px" }
}, ye = /* @__PURE__ */ T({
  __name: "ActionButton",
  props: {
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    shortcutKeys: { default: void 0 },
    customClass: { default: "" },
    loading: { type: Boolean, default: !1 },
    tooltipOptions: { default: void 0 },
    color: { default: void 0 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 },
    editor: {},
    class: {}
  },
  setup(t) {
    return (e, n) => (k(), _(p(Ps), null, {
      default: w(() => [
        E(p(Is), { "delay-duration": 0 }, {
          default: w(() => [
            E(p(Rs), null, {
              default: w(() => {
                var o;
                return [
                  E(p(b3), {
                    size: "sm",
                    class: Ze(["h-[32px]", [e.customClass, e.title ? "w-auto" : "w-[32px]"]]),
                    pressed: ((o = e.isActive) == null ? void 0 : o.call(e)) || !1,
                    disabled: e.disabled,
                    onClick: e.action
                  }, {
                    default: w(() => [
                      e.loading ? (k(), U("div", WB, [
                        E(p(xe), {
                          class: "animate-spin",
                          name: "LoaderCircle"
                        })
                      ])) : (k(), U("div", KB, [
                        e.icon ? (k(), _(p(xe), {
                          key: 0,
                          name: e.icon
                        }, null, 8, ["name"])) : ae("", !0),
                        D(e.$slots, "icon")
                      ])),
                      e.title ? (k(), U("div", qB, q(e.title), 1)) : ae("", !0),
                      D(e.$slots, "default")
                    ]),
                    _: 3
                  }, 8, ["pressed", "disabled", "class", "onClick"])
                ];
              }),
              _: 3
            }),
            e.tooltip ? (k(), _(p(Ds), Oe(j({ key: 0 }, e.tooltipOptions)), {
              default: w(() => [
                B("div", GB, [
                  B("div", null, q(e.tooltip), 1),
                  e.shortcutKeys && e.shortcutKeys.length ? (k(), U("div", JB, [
                    (k(!0), U(ve, null, Fe(e.shortcutKeys, (o, r) => (k(), U("span", { key: r }, q(p(Ku)(o)), 1))), 128))
                  ])) : ae("", !0)
                ])
              ]),
              _: 1
            }, 16)) : ae("", !0)
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), YB = { class: "flex items-center gap-2 p-2 bg-white rounded-lg dark:bg-black shadow-sm border border-neutral-200 dark:border-neutral-800" }, XB = ["href"], ZB = { class: "flex flex-nowrap" }, QB = /* @__PURE__ */ T({
  __name: "LinkViewBlock",
  props: {
    editor: {},
    link: { default: void 0 }
  },
  emits: ["clear", "edit"],
  setup(t, { emit: e }) {
    const { t: n } = et(), o = e;
    function r() {
      o("clear");
    }
    function i() {
      o("edit");
    }
    return (s, a) => (k(), U("div", YB, [
      B("a", {
        href: s.link,
        target: "_blank",
        rel: "noopener noreferrer",
        class: "text-sm underline break-all"
      }, q(p(T9)(s.link, {
        length: 50,
        omission: "…"
      })), 9, XB),
      s.link ? (k(), _(p(Bo), {
        key: 0,
        orientation: "vertical",
        class: "h-4"
      })) : ae("", !0),
      B("div", ZB, [
        E(ye, {
          icon: "Pencil",
          tooltip: p(n)("editor.link.edit.tooltip"),
          action: i,
          "tooltip-options": { sideOffset: 15 }
        }, null, 8, ["tooltip"]),
        E(ye, {
          icon: "Unlink",
          tooltip: p(n)("editor.link.unlink.tooltip"),
          action: r,
          "tooltip-options": { sideOffset: 15 }
        }, null, 8, ["tooltip"])
      ])
    ]));
  }
}), e$ = /* @__PURE__ */ T({
  __name: "LinkBubbleMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, n = O(!1), o = P(() => {
      const { href: l } = e.editor.getAttributes("link");
      return l;
    }), r = P(() => e.editor.isActive("link"));
    function i(l, c, d) {
      e.editor.chain().extendMarkRange("link").insertContent({
        type: "text",
        text: c,
        marks: [
          {
            type: "link",
            attrs: {
              href: l,
              target: d ? "_blank" : ""
            }
          }
        ]
      }).setLink({ href: l }).focus().run(), n.value = !1;
    }
    function s() {
      e.editor.chain().extendMarkRange("link").unsetLink().focus().run(), n.value = !1;
    }
    function a() {
      const { state: l, view: c } = e.editor, { tr: d, selection: u } = l, f = d.setSelection(le.create(l.doc, u.from));
      c.dispatch(f), n.value = !1;
    }
    return (l, c) => Sn((k(), _(p(As), {
      editor: l.editor,
      "update-delay": 0,
      "tippy-options": {
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        appendTo: "parent",
        placement: "bottom-start",
        offset: [-2, 16],
        zIndex: 99,
        onHidden: () => {
          n.value = !1;
        }
      }
    }, {
      default: w(() => [
        n.value ? (k(), _(y3, {
          key: 0,
          onOnSetLink: i,
          onOnClickOutside: a,
          editor: l.editor
        }, null, 8, ["editor"])) : (k(), _(QB, {
          key: 1,
          editor: l.editor,
          onClear: s,
          onEdit: c[0] || (c[0] = (d) => n.value = !0),
          link: o.value
        }, null, 8, ["editor", "link"]))
      ]),
      _: 1
    }, 8, ["editor", "tippy-options"])), [
      [Jn, r.value]
    ]);
  }
}), Ls = /* @__PURE__ */ T({
  __name: "Popover",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = De(t, e);
    return (i, s) => (k(), _(p(HR), Oe(Le(p(r))), {
      default: w(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ns = /* @__PURE__ */ T({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(VR), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Bs = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(jR), null, {
      default: w(() => [
        E(p(KR), j({ ...p(i), ...s.$attrs }, {
          class: p(fe)(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            n.class
          )
        }), {
          default: w(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), t$ = { class: "flex flex-col" }, n$ = { class: "w-6 h-6 p-0.5 inline-block rounded-sm border cursor-pointer hover:border-border hover:shadow-sm relative after:border-b-2 after:border-b-red-500 after:top-[10px] after:h-0 after:left-0 after:w-6 after:absolute after:block after:rotate-[45deg]" }, o$ = { style: { "background-color": "transparent" } }, r$ = {
  viewBox: "0 0 18 18",
  style: { fill: "rgba(0, 0, 0, 0.4)", display: "none" }
}, i$ = /* @__PURE__ */ B("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1), s$ = [
  i$
], a$ = { class: "text-sm ml-1" }, l$ = { class: "w-6 h-6 p-0.5 inline-block rounded-sm border border-transparent cursor-pointer" }, c$ = {
  viewBox: "0 0 18 18",
  style: { fill: "rgb(255, 255, 255)", display: "none" }
}, d$ = /* @__PURE__ */ B("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1), u$ = [
  d$
], f$ = { class: "text-sm ml-1" }, p$ = ["onClick"], h$ = {
  key: 0,
  viewBox: "0 0 18 18",
  style: { fill: "rgb(255, 255, 255)", display: "none" }
}, m$ = /* @__PURE__ */ B("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1), g$ = [
  m$
], v$ = {
  key: 1,
  class: "absolute top-[-1px] left-[1px] w-3 h-3",
  viewBox: "0 0 18 18",
  style: { fill: "rgb(255, 255, 255)", display: "block" }
}, y$ = /* @__PURE__ */ B("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1), b$ = [
  y$
], w$ = { class: "text-sm my-1" }, x$ = { class: "flex p-0 w-full h-auto relative last:pb-2" }, k$ = ["onClick"], C$ = {
  viewBox: "0 0 18 18",
  style: { fill: "rgb(255, 255, 255)", display: "none" }
}, S$ = /* @__PURE__ */ B("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" }, null, -1), A$ = [
  S$
], E$ = { class: "relative" }, x3 = /* @__PURE__ */ T({
  __name: "ColorPicker",
  props: {
    modelValue: { default: "" },
    highlight: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "change"],
  setup(t, { emit: e }) {
    const { t: n } = et(), o = j7.reduce((f, h, m) => {
      const g = Math.floor(m / 10);
      return f[g] || (f[g] = []), f[g].push(h), f;
    }, []), r = t, i = O(null), s = bO(r.highlight ? "recentColorsHighlight" : "recentColors", []), a = e;
    function l(f) {
      const h = s.value.indexOf(f);
      h !== -1 && s.value.splice(h, 1), s.value.unshift(f), s.value.length > 10 && s.value.pop();
    }
    const c = P(() => s.value.slice(0, 10));
    function d(f) {
      if (f === void 0) {
        a("update:modelValue", f), a("change", f);
        return;
      }
      /^#([0-9A-F]{3}){1,2}$/i.test(f) && (a("update:modelValue", f), a("change", f), l(f));
    }
    const u = () => {
      var f;
      (f = i.value) == null || f.click();
    };
    return (f, h) => (k(), _(p(Ls), null, {
      default: w(() => [
        E(p(Ns), { disabled: f.disabled }, {
          default: w(() => [
            D(f.$slots, "default")
          ]),
          _: 3
        }, 8, ["disabled"]),
        E(p(Bs), {
          hideWhenDetached: "",
          class: "p-2 w-full h-full",
          align: "start",
          side: "bottom"
        }, {
          default: w(() => [
            B("div", t$, [
              f.highlight ? (k(), U("div", {
                key: 0,
                class: "flex items-center p-1 rd-1 cursor-pointer hover:bg-accent",
                onClick: h[0] || (h[0] = (m) => d(void 0))
              }, [
                B("span", n$, [
                  B("span", o$, [
                    (k(), U("svg", r$, s$))
                  ])
                ]),
                B("span", a$, q(p(n)("editor.nofill")), 1)
              ])) : (k(), U("div", {
                key: 1,
                class: "flex items-center p-1 rd-1 cursor-pointer hover:bg-accent",
                onClick: h[1] || (h[1] = (m) => d(void 0))
              }, [
                B("span", l$, [
                  B("span", {
                    style: ct({ backgroundColor: p(V7) }),
                    class: "relative w-[18px] h-[18px] block rounded-[2px] border-transparent"
                  }, [
                    (k(), U("svg", c$, u$))
                  ], 4)
                ]),
                B("span", f$, q(p(n)("editor.default")), 1)
              ])),
              (k(!0), U(ve, null, Fe(p(o), (m, g) => (k(), U("span", {
                class: "flex p-0 w-full h-auto relative last:pb-2",
                key: g
              }, [
                (k(!0), U(ve, null, Fe(m, (v, y) => (k(), U("span", {
                  class: "w-6 h-6 p-0.5 inline-block rounded-sm border border-transparent flex-[0 0 auto] cursor-pointer hover:border-border hover:shadow-sm",
                  key: y,
                  onClick: (x) => d(v)
                }, [
                  B("span", {
                    style: ct({ backgroundColor: v }),
                    class: "relative w-[18px] h-[18px] block rounded-[2px] border-transparent"
                  }, [
                    v !== f.modelValue ? (k(), U("svg", h$, g$)) : (k(), U("svg", v$, b$))
                  ], 4)
                ], 8, p$))), 128))
              ]))), 128)),
              Sn(B("div", null, [
                B("div", w$, q(p(n)("editor.recent")), 1),
                B("span", x$, [
                  (k(!0), U(ve, null, Fe(c.value, (m, g) => (k(), U("span", {
                    class: "w-6 h-6 p-0.5 inline-block rounded-sm border border-transparent flex-[0 0 auto] cursor-pointer hover:border-border hover:shadow-sm",
                    key: g,
                    onClick: (v) => d(m)
                  }, [
                    B("span", {
                      class: "relative w-[18px] h-[18px] block rounded-[2px] border-transparent",
                      style: ct({ backgroundColor: m })
                    }, [
                      (k(), U("svg", C$, A$))
                    ], 4)
                  ], 8, k$))), 128))
                ])
              ], 512), [
                [Jn, c.value.length]
              ]),
              B("div", E$, [
                B("div", {
                  class: "text-sm hover:cursor-pointer hover:bg-accent py-1.5 px-1.5",
                  onClick: u
                }, q(p(n)("editor.color.more")) + "... ", 1),
                B("input", {
                  type: "color",
                  ref_key: "html5Color",
                  ref: i,
                  onChange: h[2] || (h[2] = (m) => {
                    d(m.target.value);
                  }),
                  class: "absolute left-0 top-4",
                  style: { visibility: "hidden" }
                }, null, 544)
              ])
            ])
          ]),
          _: 1
        })
      ]),
      _: 3
    }));
  }
}), _$ = { class: "flex items-center h-[32px] hover:bg-muted rounded-md" }, M$ = { class: "text-sm flex items-center justify-center" }, T$ = {
  width: "18px",
  height: "18px",
  viewBox: "0 0 256 256",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, O$ = {
  id: "icon/填充色",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, I$ = { id: "icon/背景颜色" }, D$ = /* @__PURE__ */ B("g", {
  id: "编组",
  fill: "currentColor"
}, [
  /* @__PURE__ */ B("g", {
    transform: "translate(119.502295, 137.878331) rotate(-135.000000) translate(-119.502295, -137.878331) translate(48.002295, 31.757731)",
    id: "矩形"
  }, [
    /* @__PURE__ */ B("path", {
      d: "M100.946943,60.8084699 L43.7469427,60.8084699 C37.2852111,60.8084699 32.0469427,66.0467383 32.0469427,72.5084699 L32.0469427,118.70847 C32.0469427,125.170201 37.2852111,130.40847 43.7469427,130.40847 L100.946943,130.40847 C107.408674,130.40847 112.646943,125.170201 112.646943,118.70847 L112.646943,72.5084699 C112.646943,66.0467383 107.408674,60.8084699 100.946943,60.8084699 Z M93.646,79.808 L93.646,111.408 L51.046,111.408 L51.046,79.808 L93.646,79.808 Z",
      "fill-rule": "nonzero"
    }),
    /* @__PURE__ */ B("path", {
      d: "M87.9366521,16.90916 L87.9194966,68.2000001 C87.9183543,69.4147389 86.9334998,70.399264 85.7187607,70.4 L56.9423078,70.4 C55.7272813,70.4 54.7423078,69.4150264 54.7423078,68.2 L54.7423078,39.4621057 C54.7423078,37.2523513 55.5736632,35.1234748 57.0711706,33.4985176 L76.4832996,12.4342613 C78.9534987,9.75382857 83.1289108,9.5834005 85.8093436,12.0535996 C87.1658473,13.303709 87.9372691,15.0644715 87.9366521,16.90916 Z",
      "fill-rule": "evenodd"
    }),
    /* @__PURE__ */ B("path", {
      d: "M131.3,111.241199 L11.7,111.241199 C5.23826843,111.241199 0,116.479467 0,122.941199 L0,200.541199 C0,207.002931 5.23826843,212.241199 11.7,212.241199 L131.3,212.241199 C137.761732,212.241199 143,207.002931 143,200.541199 L143,122.941199 C143,116.479467 137.761732,111.241199 131.3,111.241199 Z M124,130.241 L124,193.241 L19,193.241 L19,130.241 L124,130.241 Z",
      "fill-rule": "nonzero"
    })
  ])
], -1), R$ = ["fill"], k3 = /* @__PURE__ */ T({
  __name: "HighlightActionButton",
  props: {
    editor: {},
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 },
    tooltipOptions: { default: void 0 }
  },
  setup(t) {
    const e = t, n = O(void 0), { state: o } = pn();
    function r(s) {
      var a;
      (a = e.action) == null || a.call(e, s);
    }
    function i(s) {
      var a;
      (a = e.action) == null || a.call(e, n.value);
    }
    return Pe(() => {
      const { color: s } = e.editor.getAttributes("highlight");
      o.highlight = s;
    }), (s, a) => (k(), U("div", _$, [
      E(ye, {
        tooltip: s.tooltip,
        disabled: s.disabled,
        action: i,
        "tooltip-options": s.tooltipOptions
      }, {
        icon: w(() => [
          B("span", M$, [
            (k(), U("svg", T$, [
              B("g", O$, [
                B("g", I$, [
                  D$,
                  B("path", {
                    d: "M51,218 L205,218 C211.075132,218 216,222.924868 216,229 C216,235.075132 211.075132,240 205,240 L51,240 C44.9248678,240 40,235.075132 40,229 C40,222.924868 44.9248678,218 51,218 Z",
                    id: "矩形",
                    fill: n.value || "#FBDE28"
                  }, null, 8, R$)
                ])
              ])
            ]))
          ])
        ]),
        _: 1
      }, 8, ["tooltip", "disabled", "tooltip-options"]),
      E(x3, {
        modelValue: n.value,
        "onUpdate:modelValue": a[0] || (a[0] = (l) => n.value = l),
        onChange: r,
        highlight: "",
        disabled: s.disabled
      }, {
        default: w(() => [
          E(p(Pt), {
            variant: "ghost",
            size: "icon",
            class: "w-3 h-[32px] rounded-l-none hover:bg-muted-foreground/20",
            disabled: s.disabled
          }, {
            default: w(() => [
              E(p(xe), {
                class: "w-3 h-3 text-zinc-500",
                name: "MenuDown"
              })
            ]),
            _: 1
          }, 8, ["disabled"])
        ]),
        _: 1
      }, 8, ["modelValue", "disabled"])
    ]));
  }
}), P$ = { class: "min-w-32 flex flex-row h-full items-center leading-none gap-0.5 p-2 w-full bg-background rounded-lg shadow-sm border border-border" }, L$ = /* @__PURE__ */ T({
  __name: "TableBubbleMenu",
  props: {
    editor: {}
  },
  setup(t) {
    const e = t, n = ({ editor: g }) => pu(g.view.state, "table"), { t: o } = et();
    function r() {
      e.editor.chain().focus().addColumnBefore().run();
    }
    function i() {
      e.editor.chain().focus().addColumnAfter().run();
    }
    function s() {
      e.editor.chain().focus().deleteColumn().run();
    }
    function a() {
      e.editor.chain().focus().addRowBefore().run();
    }
    function l() {
      e.editor.chain().focus().addRowAfter().run();
    }
    function c() {
      e.editor.chain().focus().deleteRow().run();
    }
    function d() {
      e.editor.chain().focus().mergeCells().run();
    }
    function u() {
      var g;
      (g = e.editor) == null || g.chain().focus().splitCell().run();
    }
    function f() {
      e.editor.chain().focus().deleteTable().run();
    }
    function h(g) {
      e.editor.chain().focus().setTableCellBackground(g).run();
    }
    const m = () => {
      const {
        view: g,
        state: {
          selection: { from: v }
        }
      } = e.editor, y = g.domAtPos(v).node;
      if (!y)
        return new DOMRect(-1e3, -1e3, 0, 0);
      const x = y == null ? void 0 : y.closest(".tableWrapper");
      return x ? x.getBoundingClientRect() : new DOMRect(-1e3, -1e3, 0, 0);
    };
    return (g, v) => (k(), _(p(As), {
      editor: g.editor,
      pluginKey: "table",
      shouldShow: n,
      updateDelay: 0,
      "tippy-options": {
        offset: [0, 8],
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        maxWidth: "auto",
        getReferenceClientRect: m,
        plugins: [p(Fm)],
        sticky: "popper"
      }
    }, {
      default: w(() => {
        var y, x, C, b, S, A, I, z, N;
        return [
          B("div", P$, [
            E(ye, {
              icon: "BetweenHorizonalEnd",
              tooltip: p(o)("editor.table.menu.insertColumnBefore"),
              action: r,
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((y = g.editor) != null && y.can().addColumnBefore())
            }, null, 8, ["tooltip", "disabled"]),
            E(ye, {
              icon: "BetweenHorizonalStart",
              tooltip: p(o)("editor.table.menu.insertColumnAfter"),
              action: i,
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((x = g.editor) != null && x.can().addColumnAfter())
            }, null, 8, ["tooltip", "disabled"]),
            E(ye, {
              icon: "ColumnDelete",
              action: s,
              tooltip: p(o)("editor.table.menu.deleteColumn"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((C = g.editor) != null && C.can().deleteColumn())
            }, null, 8, ["tooltip", "disabled"]),
            E(p(Bo), {
              orientation: "vertical",
              class: "mx-1 me-2 h-[16px]"
            }),
            E(ye, {
              icon: "BetweenVerticalEnd",
              action: a,
              tooltip: p(o)("editor.table.menu.insertRowAbove"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((b = g.editor) != null && b.can().addRowBefore())
            }, null, 8, ["tooltip", "disabled"]),
            E(ye, {
              icon: "BetweenVerticalStart",
              action: l,
              tooltip: p(o)("editor.table.menu.insertRowBelow"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((S = g.editor) != null && S.can().addRowAfter())
            }, null, 8, ["tooltip", "disabled"]),
            E(ye, {
              icon: "RowDelete",
              action: c,
              tooltip: p(o)("editor.table.menu.deleteRow"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((A = g.editor) != null && A.can().deleteRow())
            }, null, 8, ["tooltip", "disabled"]),
            E(p(Bo), {
              orientation: "vertical",
              class: "mx-1 me-2 h-[16px]"
            }),
            E(ye, {
              icon: "TableCellsMerge",
              action: d,
              tooltip: p(o)("editor.table.menu.mergeCells"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((I = g.editor) != null && I.can().mergeCells())
            }, null, 8, ["tooltip", "disabled"]),
            E(ye, {
              icon: "TableCellsSplit",
              action: u,
              tooltip: p(o)("editor.table.menu.splitCells"),
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((z = g.editor) != null && z.can().splitCell())
            }, null, 8, ["tooltip", "disabled"]),
            E(p(Bo), {
              orientation: "vertical",
              class: "mx-1 me-2 h-[16px]"
            }),
            E(k3, {
              editor: g.editor,
              tooltip: p(o)("editor.table.menu.setCellsBgColor"),
              action: h,
              "tooltip-options": {
                sideOffset: 15
              }
            }, null, 8, ["editor", "tooltip"]),
            E(ye, {
              icon: "Trash2",
              tooltip: p(o)("editor.table.menu.deleteTable"),
              action: f,
              "tooltip-options": {
                sideOffset: 15
              },
              disabled: !((N = g.editor) != null && N.can().deleteTable())
            }, null, 8, ["tooltip", "disabled"])
          ])
        ];
      }),
      _: 1
    }, 8, ["editor", "tippy-options"]));
  }
}), to = () => /* @__PURE__ */ new Map(), Oh = (t) => {
  const e = to();
  return t.forEach((n, o) => {
    e.set(o, n);
  }), e;
}, $s = (t, e, n) => {
  let o = t.get(e);
  return o === void 0 && t.set(e, o = n()), o;
}, N$ = (t, e) => {
  const n = [];
  for (const [o, r] of t)
    n.push(e(r, o));
  return n;
}, B$ = (t, e) => {
  for (const [n, o] of t)
    if (e(o, n))
      return !0;
  return !1;
}, gs = () => /* @__PURE__ */ new Set(), Gf = (t) => t[t.length - 1], vs = Array.from, $$ = Array.isArray;
class z$ {
  constructor() {
    this._observers = to();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, n) {
    return $s(
      this._observers,
      /** @type {string} */
      e,
      gs
    ).add(n), n;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, n) {
    const o = (...r) => {
      this.off(
        e,
        /** @type {any} */
        o
      ), n(...r);
    };
    this.on(
      e,
      /** @type {any} */
      o
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, n) {
    const o = this._observers.get(e);
    o !== void 0 && (o.delete(n), o.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, n) {
    return vs((this._observers.get(e) || to()).values()).forEach((o) => o(...n));
  }
  destroy() {
    this._observers = to();
  }
}
const wi = Math.floor, Pc = Math.abs, C3 = (t, e) => t < e ? t : e, zs = (t, e) => t > e ? t : e, F$ = (t) => t !== 0 ? t < 0 : 1 / t < 0, sy = 1, ay = 2, Jf = 4, Yf = 8, H$ = 32, S3 = 64, gd = 128, V$ = 31, ly = 63, ba = 127, j$ = 2147483647, U$ = Number.isInteger || ((t) => typeof t == "number" && isFinite(t) && wi(t) === t), W$ = (t) => t.toLowerCase(), K$ = /^\s*/g, q$ = (t) => t.replace(K$, ""), G$ = /([A-Z])/g, cy = (t, e) => q$(t.replace(G$, (n) => `${e}${W$(n)}`)), J$ = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, o = new Uint8Array(n);
  for (let r = 0; r < n; r++)
    o[r] = /** @type {number} */
    e.codePointAt(r);
  return o;
}, tl = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), Y$ = (t) => tl.encode(t), X$ = tl ? Y$ : J$;
let Xf = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
Xf && Xf.decode(new Uint8Array()).length === 1 && (Xf = null);
class Rl {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const Pg = () => new Rl(), Z$ = (t) => {
  let e = t.cpos;
  for (let n = 0; n < t.bufs.length; n++)
    e += t.bufs[n].length;
  return e;
}, Do = (t) => {
  const e = new Uint8Array(Z$(t));
  let n = 0;
  for (let o = 0; o < t.bufs.length; o++) {
    const r = t.bufs[o];
    e.set(r, n), n += r.length;
  }
  return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
}, Q$ = (t, e) => {
  const n = t.cbuf.length;
  n - t.cpos < e && (t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)), t.cbuf = new Uint8Array(zs(n, e) * 2), t.cpos = 0);
}, wt = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, Ih = wt, Ye = (t, e) => {
  for (; e > ba; )
    wt(t, gd | ba & e), e = wi(e / 128);
  wt(t, ba & e);
}, Lg = (t, e) => {
  const n = F$(e);
  for (n && (e = -e), wt(t, (e > ly ? gd : 0) | (n ? S3 : 0) | ly & e), e = wi(e / 64); e > 0; )
    wt(t, (e > ba ? gd : 0) | ba & e), e = wi(e / 128);
}, Dh = new Uint8Array(3e4), ez = Dh.length / 3, tz = (t, e) => {
  if (e.length < ez) {
    const n = tl.encodeInto(e, Dh).written || 0;
    Ye(t, n);
    for (let o = 0; o < n; o++)
      wt(t, Dh[o]);
  } else
    nn(t, X$(e));
}, nz = (t, e) => {
  const n = unescape(encodeURIComponent(e)), o = n.length;
  Ye(t, o);
  for (let r = 0; r < o; r++)
    wt(
      t,
      /** @type {number} */
      n.codePointAt(r)
    );
}, ns = tl && /** @type {any} */
tl.encodeInto ? tz : nz, Ng = (t, e) => {
  const n = t.cbuf.length, o = t.cpos, r = C3(n - o, e.length), i = e.length - r;
  t.cbuf.set(e.subarray(0, r), o), t.cpos += r, i > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(zs(n * 2, i)), t.cbuf.set(e.subarray(r)), t.cpos = i);
}, nn = (t, e) => {
  Ye(t, e.byteLength), Ng(t, e);
}, Bg = (t, e) => {
  Q$(t, e);
  const n = new DataView(t.cbuf.buffer, t.cpos, e);
  return t.cpos += e, n;
}, oz = (t, e) => Bg(t, 4).setFloat32(0, e, !1), rz = (t, e) => Bg(t, 8).setFloat64(0, e, !1), iz = (t, e) => (
  /** @type {any} */
  Bg(t, 8).setBigInt64(0, e, !1)
), dy = new DataView(new ArrayBuffer(4)), sz = (t) => (dy.setFloat32(0, t), dy.getFloat32(0) === t), nl = (t, e) => {
  switch (typeof e) {
    case "string":
      wt(t, 119), ns(t, e);
      break;
    case "number":
      U$(e) && Pc(e) <= j$ ? (wt(t, 125), Lg(t, e)) : sz(e) ? (wt(t, 124), oz(t, e)) : (wt(t, 123), rz(t, e));
      break;
    case "bigint":
      wt(t, 122), iz(t, e);
      break;
    case "object":
      if (e === null)
        wt(t, 126);
      else if ($$(e)) {
        wt(t, 117), Ye(t, e.length);
        for (let n = 0; n < e.length; n++)
          nl(t, e[n]);
      } else if (e instanceof Uint8Array)
        wt(t, 116), nn(t, e);
      else {
        wt(t, 118);
        const n = Object.keys(e);
        Ye(t, n.length);
        for (let o = 0; o < n.length; o++) {
          const r = n[o];
          ns(t, r), nl(t, e[r]);
        }
      }
      break;
    case "boolean":
      wt(t, e ? 120 : 121);
      break;
    default:
      wt(t, 127);
  }
};
class uy extends Rl {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && Ye(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const fy = (t) => {
  t.count > 0 && (Lg(t.encoder, t.count === 1 ? t.s : -t.s), t.count > 1 && Ye(t.encoder, t.count - 2));
};
class Lc {
  constructor() {
    this.encoder = new Rl(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (fy(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return fy(this), Do(this.encoder);
  }
}
const py = (t) => {
  if (t.count > 0) {
    const e = t.diff * 2 + (t.count === 1 ? 0 : 1);
    Lg(t.encoder, e), t.count > 1 && Ye(t.encoder, t.count - 2);
  }
};
class Zf {
  constructor() {
    this.encoder = new Rl(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (py(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return py(this), Do(this.encoder);
  }
}
class az {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new Lc();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new Rl();
    return this.sarr.push(this.s), this.s = "", ns(e, this.sarr.join("")), Ng(e, this.lensE.toUint8Array()), Do(e);
  }
}
const ys = (t) => new Error(t), no = () => {
  throw ys("Method unimplemented");
}, Pr = () => {
  throw ys("Unexpected case");
}, lz = crypto.getRandomValues.bind(crypto), A3 = () => lz(new Uint32Array(1))[0], cz = "10000000-1000-4000-8000" + -1e11, dz = () => cz.replace(
  /[018]/g,
  /** @param {number} c */
  (t) => (t ^ A3() & 15 >> t / 4).toString(16)
), hy = (t) => (
  /** @type {Promise<T>} */
  new Promise(t)
);
Promise.all.bind(Promise);
const my = (t) => t === void 0 ? null : t;
class uz {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, n) {
    this.map.set(e, n);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let E3 = new uz(), fz = !0;
try {
  typeof localStorage < "u" && localStorage && (E3 = localStorage, fz = !1);
} catch {
}
const pz = E3, hz = Object.assign, mz = Object.keys, gz = (t, e) => {
  for (const n in t)
    e(t[n], n);
}, gy = (t) => mz(t).length, vz = (t) => {
  for (const e in t)
    return !1;
  return !0;
}, yz = (t, e) => {
  for (const n in t)
    if (!e(t[n], n))
      return !1;
  return !0;
}, bz = (t, e) => Object.prototype.hasOwnProperty.call(t, e), wz = (t, e) => t === e || gy(t) === gy(e) && yz(t, (n, o) => (n !== void 0 || bz(e, o)) && e[o] === n), $g = (t, e, n = 0) => {
  try {
    for (; n < t.length; n++)
      t[n](...e);
  } finally {
    n < t.length && $g(t, e, n + 1);
  }
}, xz = (t, e) => e.includes(t), ol = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
let jn;
const kz = () => {
  if (jn === void 0)
    if (ol) {
      jn = to();
      const t = process.argv;
      let e = null;
      for (let n = 0; n < t.length; n++) {
        const o = t[n];
        o[0] === "-" ? (e !== null && jn.set(e, ""), e = o) : e !== null && (jn.set(e, o), e = null);
      }
      e !== null && jn.set(e, "");
    } else
      typeof location == "object" ? (jn = to(), (location.search || "?").slice(1).split("&").forEach((t) => {
        if (t.length !== 0) {
          const [e, n] = t.split("=");
          jn.set(`--${cy(e, "-")}`, n), jn.set(`-${cy(e, "-")}`, n);
        }
      })) : jn = to();
  return jn;
}, Rh = (t) => kz().has(t), Ph = (t) => my(ol ? process.env[t.toUpperCase().replaceAll("-", "_")] : pz.getItem(t)), Cz = (t) => Rh("--" + t) || Ph(t) !== null;
Cz("production");
const vy = ol && xz(process.env.FORCE_COLOR, ["true", "1", "2"]), Sz = !Rh("--no-colors") && (!ol || process.stdout.isTTY || vy) && (!ol || Rh("--color") || vy || Ph("COLORTERM") !== null || (Ph("TERM") || "").includes("color"));
class Az {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, n) {
    this.left = e, this.right = n;
  }
}
const bo = (t, e) => new Az(t, e);
typeof DOMParser < "u" && new DOMParser();
const Ez = (t) => N$(t, (e, n) => `${n}:${e};`).join(""), Jo = Symbol, _3 = Jo(), M3 = Jo(), _z = Jo(), Mz = Jo(), Tz = Jo(), T3 = Jo(), Oz = Jo(), O3 = Jo(), Iz = Jo(), Dz = (t) => {
  var o;
  t.length === 1 && ((o = t[0]) == null ? void 0 : o.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [];
  let n = 0;
  for (; n < t.length; n++) {
    const r = t[n];
    r === void 0 || r.constructor === String || r.constructor === Number || r.constructor === Object && e.push(JSON.stringify(r));
  }
  return e;
}, Rz = {
  [_3]: bo("font-weight", "bold"),
  [M3]: bo("font-weight", "normal"),
  [_z]: bo("color", "blue"),
  [Tz]: bo("color", "green"),
  [Mz]: bo("color", "grey"),
  [T3]: bo("color", "red"),
  [Oz]: bo("color", "purple"),
  [O3]: bo("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [Iz]: bo("color", "black")
}, Pz = (t) => {
  var s;
  t.length === 1 && ((s = t[0]) == null ? void 0 : s.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [], o = to();
  let r = [], i = 0;
  for (; i < t.length; i++) {
    const a = t[i], l = Rz[a];
    if (l !== void 0)
      o.set(l.left, l.right);
    else {
      if (a === void 0)
        break;
      if (a.constructor === String || a.constructor === Number) {
        const c = Ez(o);
        i > 0 || c.length > 0 ? (e.push("%c" + a), n.push(c)) : e.push(a);
      } else
        break;
    }
  }
  for (i > 0 && (r = n, r.unshift(e.join(""))); i < t.length; i++) {
    const a = t[i];
    a instanceof Symbol || r.push(a);
  }
  return r;
}, Lz = Sz ? Pz : Dz, Nz = (...t) => {
  console.log(...Lz(t)), Bz.forEach((e) => e.print(t));
}, Bz = gs(), I3 = (t) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: t
}), $z = (t, e) => I3(() => {
  let n;
  do
    n = t.next();
  while (!n.done && !e(n.value));
  return n;
}), Qf = (t, e) => I3(() => {
  const { done: n, value: o } = t.next();
  return { done: n, value: n ? void 0 : e(o) };
});
class zz {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, n) {
    this.clock = e, this.len = n;
  }
}
class Fz {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const D3 = (t, e, n) => e.clients.forEach((o, r) => {
  const i = (
    /** @type {Array<GC|Item>} */
    t.doc.store.clients.get(r)
  );
  for (let s = 0; s < o.length; s++) {
    const a = o[s];
    z3(t, i, a.clock, a.len, n);
  }
}), Hz = (t, e) => {
  let n = 0, o = t.length - 1;
  for (; n <= o; ) {
    const r = wi((n + o) / 2), i = t[r], s = i.clock;
    if (s <= e) {
      if (e < s + i.len)
        return r;
      n = r + 1;
    } else
      o = r - 1;
  }
  return null;
}, R3 = (t, e) => {
  const n = t.clients.get(e.client);
  return n !== void 0 && Hz(n, e.clock) !== null;
}, P3 = (t) => {
  t.clients.forEach((e) => {
    e.sort((r, i) => r.clock - i.clock);
    let n, o;
    for (n = 1, o = 1; n < e.length; n++) {
      const r = e[o - 1], i = e[n];
      r.clock + r.len >= i.clock ? r.len = zs(r.len, i.clock + i.len - r.clock) : (o < n && (e[o] = i), o++);
    }
    e.length = o;
  });
}, L3 = (t, e, n, o) => {
  $s(t.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new zz(n, o));
}, Vz = (t, e) => {
  Ye(t.restEncoder, e.clients.size), vs(e.clients.entries()).sort((n, o) => o[0] - n[0]).forEach(([n, o]) => {
    t.resetDsCurVal(), Ye(t.restEncoder, n);
    const r = o.length;
    Ye(t.restEncoder, r);
    for (let i = 0; i < r; i++) {
      const s = o[i];
      t.writeDsClock(s.clock), t.writeDsLen(s.len);
    }
  });
}, N3 = A3;
class Pl extends z$ {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = dz(), collectionid: n = null, gc: o = !0, gcFilter: r = () => !0, meta: i = null, autoLoad: s = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = o, this.gcFilter = r, this.clientID = N3(), this.guid = e, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new Xz(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = s, this.meta = i, this.isLoaded = !1, this.isSynced = !1, this.whenLoaded = hy((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const l = () => hy((c) => {
      const d = (u) => {
        (u === void 0 || u === !0) && (this.off("sync", d), c());
      };
      this.on("sync", d);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && at(
      /** @type {any} */
      e.parent.doc,
      (n) => {
        n.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(vs(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, n = null) {
    return at(this, e, n);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, n = (
    /** @type {any} */
    Dt
  )) {
    const o = $s(this.share, e, () => {
      const i = new n();
      return i._integrate(this, null), i;
    }), r = o.constructor;
    if (n !== Dt && r !== n)
      if (r === Dt) {
        const i = new n();
        i._map = o._map, o._map.forEach(
          /** @param {Item?} n */
          (s) => {
            for (; s !== null; s = s.left)
              s.parent = i;
          }
        ), i._start = o._start;
        for (let s = i._start; s !== null; s = s.right)
          s.parent = i;
        return i._length = o._length, this.share.set(e, i), i._integrate(this, null), /** @type {InstanceType<Type>} */
        i;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      o
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, wa)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, al);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, wd)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, ll)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, bs);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((n, o) => {
      e[o] = n.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    vs(this.subdocs).forEach((n) => n.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const n = (
        /** @type {ContentDoc} */
        e.content
      );
      n.doc = new Pl({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = e, at(
        /** @type {any} */
        e.parent.doc,
        (o) => {
          const r = n.doc;
          e.deleted || o.subdocsAdded.add(r), o.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class jz {
  constructor() {
    this.restEncoder = Pg();
  }
  toUint8Array() {
    return Do(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    Ye(this.restEncoder, e);
  }
}
class Uz extends jz {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    Ye(this.restEncoder, e.client), Ye(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    Ye(this.restEncoder, e.client), Ye(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    Ih(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    ns(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    Ye(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    Ye(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    nl(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    nn(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    ns(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    ns(this.restEncoder, e);
  }
}
class Wz {
  constructor() {
    this.restEncoder = Pg(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Do(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const n = e - this.dsCurrVal;
    this.dsCurrVal = e, Ye(this.restEncoder, n);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && Pr(), Ye(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class Kz extends Wz {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new Zf(), this.clientEncoder = new Lc(), this.leftClockEncoder = new Zf(), this.rightClockEncoder = new Zf(), this.infoEncoder = new uy(Ih), this.stringEncoder = new az(), this.parentInfoEncoder = new uy(Ih), this.typeRefEncoder = new Lc(), this.lenEncoder = new Lc();
  }
  toUint8Array() {
    const e = Pg();
    return Ye(e, 0), nn(e, this.keyClockEncoder.toUint8Array()), nn(e, this.clientEncoder.toUint8Array()), nn(e, this.leftClockEncoder.toUint8Array()), nn(e, this.rightClockEncoder.toUint8Array()), nn(e, Do(this.infoEncoder)), nn(e, this.stringEncoder.toUint8Array()), nn(e, Do(this.parentInfoEncoder)), nn(e, this.typeRefEncoder.toUint8Array()), nn(e, this.lenEncoder.toUint8Array()), Ng(e, Do(this.restEncoder)), Do(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    nl(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    nn(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    nl(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const n = this.keyMap.get(e);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(n);
  }
}
const qz = (t, e, n, o) => {
  o = zs(o, e[0].id.clock);
  const r = Ho(e, o);
  Ye(t.restEncoder, e.length - r), t.writeClient(n), Ye(t.restEncoder, o);
  const i = e[r];
  i.write(t, o - i.id.clock);
  for (let s = r + 1; s < e.length; s++)
    e[s].write(t, 0);
}, Gz = (t, e, n) => {
  const o = /* @__PURE__ */ new Map();
  n.forEach((r, i) => {
    Gt(e, i) > r && o.set(i, r);
  }), zg(e).forEach((r, i) => {
    n.has(i) || o.set(i, 0);
  }), Ye(t.restEncoder, o.size), vs(o.entries()).sort((r, i) => i[0] - r[0]).forEach(([r, i]) => {
    qz(
      t,
      /** @type {Array<GC|Item>} */
      e.clients.get(r),
      r,
      i
    );
  });
}, Jz = (t, e) => Gz(t, e.doc.store, e.beforeState);
class Yz {
  constructor() {
    this.l = [];
  }
}
const yy = () => new Yz(), by = (t, e) => t.l.push(e), wy = (t, e) => {
  const n = t.l, o = n.length;
  t.l = n.filter((r) => e !== r), o === t.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, B3 = (t, e, n) => $g(t.l, [e, n]);
class Nc {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, n) {
    this.client = e, this.clock = n;
  }
}
const cc = (t, e) => t === e || t !== null && e !== null && t.client === e.client && t.clock === e.clock, lt = (t, e) => new Nc(t, e), rl = (t) => {
  for (const [e, n] of t.doc.share.entries())
    if (n === t)
      return e;
  throw Pr();
};
class vd {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(e, n, o, r = 0) {
    this.type = e, this.tname = n, this.item = o, this.assoc = r;
  }
}
const dc = (t, e, n) => {
  let o = null, r = null;
  return t._item === null ? r = rl(t) : o = lt(t._item.id.client, t._item.id.clock), new vd(o, r, e, n);
}, ep = (t, e, n = 0) => {
  let o = t._start;
  if (n < 0) {
    if (e === 0)
      return dc(t, null, n);
    e--;
  }
  for (; o !== null; ) {
    if (!o.deleted && o.countable) {
      if (o.length > e)
        return dc(t, lt(o.id.client, o.id.clock + e), n);
      e -= o.length;
    }
    if (o.right === null && n < 0)
      return dc(t, o.lastId, n);
    o = o.right;
  }
  return dc(t, null, n);
}, Ki = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && (e.sv.get(t.id.client) || 0) > t.id.clock && !R3(e.ds, t.id), Lh = (t, e) => {
  const n = $s(t.meta, Lh, gs), o = t.doc.store;
  n.has(e) || (e.sv.forEach((r, i) => {
    r < Gt(o, i) && Lr(t, lt(i, r));
  }), D3(t, e.ds, (r) => {
  }), n.add(e));
};
class Xz {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const zg = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.clients.forEach((n, o) => {
    const r = n[n.length - 1];
    e.set(o, r.id.clock + r.length);
  }), e;
}, Gt = (t, e) => {
  const n = t.clients.get(e);
  if (n === void 0)
    return 0;
  const o = n[n.length - 1];
  return o.id.clock + o.length;
}, $3 = (t, e) => {
  let n = t.clients.get(e.id.client);
  if (n === void 0)
    n = [], t.clients.set(e.id.client, n);
  else {
    const o = n[n.length - 1];
    if (o.id.clock + o.length !== e.id.clock)
      throw Pr();
  }
  n.push(e);
}, Ho = (t, e) => {
  let n = 0, o = t.length - 1, r = t[o], i = r.id.clock;
  if (i === e)
    return o;
  let s = wi(e / (i + r.length - 1) * o);
  for (; n <= o; ) {
    if (r = t[s], i = r.id.clock, i <= e) {
      if (e < i + r.length)
        return s;
      n = s + 1;
    } else
      o = s - 1;
    s = wi((n + o) / 2);
  }
  throw Pr();
}, Zz = (t, e) => {
  const n = t.clients.get(e.client);
  return n[Ho(n, e.clock)];
}, tp = (
  /** @type {function(StructStore,ID):Item} */
  Zz
), Nh = (t, e, n) => {
  const o = Ho(e, n), r = e[o];
  return r.id.clock < n && r instanceof cn ? (e.splice(o + 1, 0, o6(t, r, n - r.id.clock)), o + 1) : o;
}, Lr = (t, e) => {
  const n = (
    /** @type {Array<Item>} */
    t.doc.store.clients.get(e.client)
  );
  return n[Nh(t, n, e.clock)];
}, xy = (t, e, n) => {
  const o = e.clients.get(n.client), r = Ho(o, n.clock), i = o[r];
  return n.clock !== i.id.clock + i.length - 1 && i.constructor !== fr && o.splice(r + 1, 0, o6(t, i, n.clock - i.id.clock + 1)), i;
}, Qz = (t, e, n) => {
  const o = (
    /** @type {Array<GC|Item>} */
    t.clients.get(e.id.client)
  );
  o[Ho(o, e.id.clock)] = n;
}, z3 = (t, e, n, o, r) => {
  if (o === 0)
    return;
  const i = n + o;
  let s = Nh(t, e, n), a;
  do
    a = e[s++], i < a.id.clock + a.length && Nh(t, e, i), r(a);
  while (s < e.length && e[s].id.clock < i);
};
class eF {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, n, o) {
    this.doc = e, this.deleteSet = new Fz(), this.beforeState = zg(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = o, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const ky = (t, e) => e.deleteSet.clients.size === 0 && !B$(e.afterState, (n, o) => e.beforeState.get(o) !== n) ? !1 : (P3(e.deleteSet), Jz(t, e), Vz(t, e.deleteSet), !0), Cy = (t, e, n) => {
  const o = e._item;
  (o === null || o.id.clock < (t.beforeState.get(o.id.client) || 0) && !o.deleted) && $s(t.changed, e, gs).add(n);
}, Bc = (t, e) => {
  let n = t[e], o = t[e - 1], r = e;
  for (; r > 0; n = o, o = t[--r - 1]) {
    if (o.deleted === n.deleted && o.constructor === n.constructor && o.mergeWith(n)) {
      n instanceof cn && n.parentSub !== null && /** @type {AbstractType<any>} */
      n.parent._map.get(n.parentSub) === n && n.parent._map.set(
        n.parentSub,
        /** @type {Item} */
        o
      );
      continue;
    }
    break;
  }
  const i = e - r;
  return i && t.splice(e + 1 - i, i), i;
}, tF = (t, e, n) => {
  for (const [o, r] of t.clients.entries()) {
    const i = (
      /** @type {Array<GC|Item>} */
      e.clients.get(o)
    );
    for (let s = r.length - 1; s >= 0; s--) {
      const a = r[s], l = a.clock + a.len;
      for (let c = Ho(i, a.clock), d = i[c]; c < i.length && d.id.clock < l; d = i[++c]) {
        const u = i[c];
        if (a.clock + a.len <= u.id.clock)
          break;
        u instanceof cn && u.deleted && !u.keep && n(u) && u.gc(e, !1);
      }
    }
  }
}, nF = (t, e) => {
  t.clients.forEach((n, o) => {
    const r = (
      /** @type {Array<GC|Item>} */
      e.clients.get(o)
    );
    for (let i = n.length - 1; i >= 0; i--) {
      const s = n[i], a = C3(r.length - 1, 1 + Ho(r, s.clock + s.len - 1));
      for (let l = a, c = r[l]; l > 0 && c.id.clock >= s.clock; c = r[l])
        l -= 1 + Bc(r, l);
    }
  });
}, F3 = (t, e) => {
  if (e < t.length) {
    const n = t[e], o = n.doc, r = o.store, i = n.deleteSet, s = n._mergeStructs;
    try {
      P3(i), n.afterState = zg(n.doc.store), o.emit("beforeObserverCalls", [n, o]);
      const a = [];
      n.changed.forEach(
        (l, c) => a.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(n, l);
        })
      ), a.push(() => {
        n.changedParentTypes.forEach((l, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (l = l.filter(
            (d) => d.target._item === null || !d.target._item.deleted
          ), l.forEach((d) => {
            d.currentTarget = c, d._path = null;
          }), l.sort((d, u) => d.path.length - u.path.length), B3(c._dEH, l, n));
        });
      }), a.push(() => o.emit("afterTransaction", [n, o])), $g(a, []), n._needFormattingCleanup && hF(n);
    } finally {
      o.gc && tF(i, r, o.gcFilter), nF(i, r), n.afterState.forEach((d, u) => {
        const f = n.beforeState.get(u) || 0;
        if (f !== d) {
          const h = (
            /** @type {Array<GC|Item>} */
            r.clients.get(u)
          ), m = zs(Ho(h, f), 1);
          for (let g = h.length - 1; g >= m; )
            g -= 1 + Bc(h, g);
        }
      });
      for (let d = s.length - 1; d >= 0; d--) {
        const { client: u, clock: f } = s[d].id, h = (
          /** @type {Array<GC|Item>} */
          r.clients.get(u)
        ), m = Ho(h, f);
        m + 1 < h.length && Bc(h, m + 1) > 1 || m > 0 && Bc(h, m);
      }
      if (!n.local && n.afterState.get(o.clientID) !== n.beforeState.get(o.clientID) && (Nz(O3, _3, "[yjs] ", M3, T3, "Changed the client-id because another client seems to be using it."), o.clientID = N3()), o.emit("afterTransactionCleanup", [n, o]), o._observers.has("update")) {
        const d = new Uz();
        ky(d, n) && o.emit("update", [d.toUint8Array(), n.origin, o, n]);
      }
      if (o._observers.has("updateV2")) {
        const d = new Kz();
        ky(d, n) && o.emit("updateV2", [d.toUint8Array(), n.origin, o, n]);
      }
      const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: c } = n;
      (a.size > 0 || c.size > 0 || l.size > 0) && (a.forEach((d) => {
        d.clientID = o.clientID, d.collectionid == null && (d.collectionid = o.collectionid), o.subdocs.add(d);
      }), c.forEach((d) => o.subdocs.delete(d)), o.emit("subdocs", [{ loaded: l, added: a, removed: c }, o, n]), c.forEach((d) => d.destroy())), t.length <= e + 1 ? (o._transactionCleanups = [], o.emit("afterAllTransactions", [o, t])) : F3(t, e + 1);
    }
  }
}, at = (t, e, n = null, o = !0) => {
  const r = t._transactionCleanups;
  let i = !1, s = null;
  t._transaction === null && (i = !0, t._transaction = new eF(t, n, o), r.push(t._transaction), r.length === 1 && t.emit("beforeAllTransactions", [t]), t.emit("beforeTransaction", [t._transaction, t]));
  try {
    s = e(t._transaction);
  } finally {
    if (i) {
      const a = t._transaction === r[0];
      t._transaction = null, a && F3(r, 0);
    }
  }
  return s;
}, Sy = "You must not compute changes after the event-handler fired.";
class qu {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, n) {
    this.target = e, this.currentTarget = e, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = oF(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return R3(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw ys(Sy);
      const e = /* @__PURE__ */ new Map(), n = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(n).forEach((r) => {
        if (r !== null) {
          const i = (
            /** @type {Item} */
            n._map.get(r)
          );
          let s, a;
          if (this.adds(i)) {
            let l = i.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(i))
              if (l !== null && this.deletes(l))
                s = "delete", a = Gf(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (s = "update", a = Gf(l.content.getContent())) : (s = "add", a = void 0);
          } else if (this.deletes(i))
            s = "delete", a = Gf(
              /** @type {Item} */
              i.content.getContent()
            );
          else
            return;
          e.set(r, { action: s, oldValue: a });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw ys(Sy);
      const n = this.target, o = gs(), r = gs(), i = [];
      if (e = {
        added: o,
        deleted: r,
        delta: i,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(n).has(null)) {
        let a = null;
        const l = () => {
          a && i.push(a);
        };
        for (let c = n._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((a === null || a.delete === void 0) && (l(), a = { delete: 0 }), a.delete += c.length, r.add(c)) : this.adds(c) ? ((a === null || a.insert === void 0) && (l(), a = { insert: [] }), a.insert = a.insert.concat(c.content.getContent()), o.add(c)) : ((a === null || a.retain === void 0) && (l(), a = { retain: 0 }), a.retain += c.length);
        a !== null && a.retain === void 0 && l();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const oF = (t, e) => {
  const n = [];
  for (; e._item !== null && e !== t; ) {
    if (e._item.parentSub !== null)
      n.unshift(e._item.parentSub);
    else {
      let o = 0, r = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; r !== e._item && r !== null; )
        r.deleted || o++, r = r.right;
      n.unshift(o);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return n;
}, H3 = 80;
let Fg = 0;
class rF {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, n) {
    e.marker = !0, this.p = e, this.index = n, this.timestamp = Fg++;
  }
}
const iF = (t) => {
  t.timestamp = Fg++;
}, V3 = (t, e, n) => {
  t.p.marker = !1, t.p = e, e.marker = !0, t.index = n, t.timestamp = Fg++;
}, sF = (t, e, n) => {
  if (t.length >= H3) {
    const o = t.reduce((r, i) => r.timestamp < i.timestamp ? r : i);
    return V3(o, e, n), o;
  } else {
    const o = new rF(e, n);
    return t.push(o), o;
  }
}, Gu = (t, e) => {
  if (t._start === null || e === 0 || t._searchMarker === null)
    return null;
  const n = t._searchMarker.length === 0 ? null : t._searchMarker.reduce((i, s) => Pc(e - i.index) < Pc(e - s.index) ? i : s);
  let o = t._start, r = 0;
  for (n !== null && (o = n.p, r = n.index, iF(n)); o.right !== null && r < e; ) {
    if (!o.deleted && o.countable) {
      if (e < r + o.length)
        break;
      r += o.length;
    }
    o = o.right;
  }
  for (; o.left !== null && r > e; )
    o = o.left, !o.deleted && o.countable && (r -= o.length);
  for (; o.left !== null && o.left.id.client === o.id.client && o.left.id.clock + o.left.length === o.id.clock; )
    o = o.left, !o.deleted && o.countable && (r -= o.length);
  return n !== null && Pc(n.index - r) < /** @type {YText|YArray<any>} */
  o.parent.length / H3 ? (V3(n, o, r), n) : sF(t._searchMarker, o, r);
}, il = (t, e, n) => {
  for (let o = t.length - 1; o >= 0; o--) {
    const r = t[o];
    if (n > 0) {
      let i = r.p;
      for (i.marker = !1; i && (i.deleted || !i.countable); )
        i = i.left, i && !i.deleted && i.countable && (r.index -= i.length);
      if (i === null || i.marker === !0) {
        t.splice(o, 1);
        continue;
      }
      r.p = i, i.marker = !0;
    }
    (e < r.index || n > 0 && e === r.index) && (r.index = zs(e, r.index + n));
  }
}, Ju = (t, e, n) => {
  const o = t, r = e.changedParentTypes;
  for (; $s(r, t, () => []).push(n), t._item !== null; )
    t = /** @type {AbstractType<any>} */
    t._item.parent;
  B3(o._eH, n, e);
};
class Dt {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = yy(), this._dEH = yy(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, n) {
    this.doc = e, this._item = n;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw no();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw no();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    by(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    by(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    wy(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    wy(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const j3 = (t, e, n) => {
  e < 0 && (e = t._length + e), n < 0 && (n = t._length + n);
  let o = n - e;
  const r = [];
  let i = t._start;
  for (; i !== null && o > 0; ) {
    if (i.countable && !i.deleted) {
      const s = i.content.getContent();
      if (s.length <= e)
        e -= s.length;
      else {
        for (let a = e; a < s.length && o > 0; a++)
          r.push(s[a]), o--;
        e = 0;
      }
    }
    i = i.right;
  }
  return r;
}, U3 = (t) => {
  const e = [];
  let n = t._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const o = n.content.getContent();
      for (let r = 0; r < o.length; r++)
        e.push(o[r]);
    }
    n = n.right;
  }
  return e;
}, sl = (t, e) => {
  let n = 0, o = t._start;
  for (; o !== null; ) {
    if (o.countable && !o.deleted) {
      const r = o.content.getContent();
      for (let i = 0; i < r.length; i++)
        e(r[i], n++, t);
    }
    o = o.right;
  }
}, W3 = (t, e) => {
  const n = [];
  return sl(t, (o, r) => {
    n.push(e(o, r, t));
  }), n;
}, aF = (t) => {
  let e = t._start, n = null, o = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        n = e.content.getContent(), o = 0, e = e.right;
      }
      const r = n[o++];
      return n.length <= o && (n = null), {
        done: !1,
        value: r
      };
    }
  };
}, K3 = (t, e) => {
  const n = Gu(t, e);
  let o = t._start;
  for (n !== null && (o = n.p, e -= n.index); o !== null; o = o.right)
    if (!o.deleted && o.countable) {
      if (e < o.length)
        return o.content.getContent()[e];
      e -= o.length;
    }
}, yd = (t, e, n, o) => {
  let r = n;
  const i = t.doc, s = i.clientID, a = i.store, l = n === null ? e._start : n.right;
  let c = [];
  const d = () => {
    c.length > 0 && (r = new cn(lt(s, Gt(a, s)), r, r && r.lastId, l, l && l.id, e, null, new ws(c)), r.integrate(t, 0), c = []);
  };
  o.forEach((u) => {
    if (u === null)
      c.push(u);
    else
      switch (u.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(u);
          break;
        default:
          switch (d(), u.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              r = new cn(lt(s, Gt(a, s)), r, r && r.lastId, l, l && l.id, e, null, new Yu(new Uint8Array(
                /** @type {Uint8Array} */
                u
              ))), r.integrate(t, 0);
              break;
            case Pl:
              r = new cn(lt(s, Gt(a, s)), r, r && r.lastId, l, l && l.id, e, null, new Xu(
                /** @type {Doc} */
                u
              )), r.integrate(t, 0);
              break;
            default:
              if (u instanceof Dt)
                r = new cn(lt(s, Gt(a, s)), r, r && r.lastId, l, l && l.id, e, null, new jr(u)), r.integrate(t, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), d();
}, q3 = () => ys("Length exceeded!"), G3 = (t, e, n, o) => {
  if (n > e._length)
    throw q3();
  if (n === 0)
    return e._searchMarker && il(e._searchMarker, n, o.length), yd(t, e, null, o);
  const r = n, i = Gu(e, n);
  let s = e._start;
  for (i !== null && (s = i.p, n -= i.index, n === 0 && (s = s.prev, n += s && s.countable && !s.deleted ? s.length : 0)); s !== null; s = s.right)
    if (!s.deleted && s.countable) {
      if (n <= s.length) {
        n < s.length && Lr(t, lt(s.id.client, s.id.clock + n));
        break;
      }
      n -= s.length;
    }
  return e._searchMarker && il(e._searchMarker, r, o.length), yd(t, e, s, o);
}, lF = (t, e, n) => {
  let r = (e._searchMarker || []).reduce((i, s) => s.index > i.index ? s : i, { index: 0, p: e._start }).p;
  if (r)
    for (; r.right; )
      r = r.right;
  return yd(t, e, r, n);
}, J3 = (t, e, n, o) => {
  if (o === 0)
    return;
  const r = n, i = o, s = Gu(e, n);
  let a = e._start;
  for (s !== null && (a = s.p, n -= s.index); a !== null && n > 0; a = a.right)
    !a.deleted && a.countable && (n < a.length && Lr(t, lt(a.id.client, a.id.clock + n)), n -= a.length);
  for (; o > 0 && a !== null; )
    a.deleted || (o < a.length && Lr(t, lt(a.id.client, a.id.clock + o)), a.delete(t), o -= a.length), a = a.right;
  if (o > 0)
    throw q3();
  e._searchMarker && il(
    e._searchMarker,
    r,
    -i + o
    /* in case we remove the above exception */
  );
}, bd = (t, e, n) => {
  const o = e._map.get(n);
  o !== void 0 && o.delete(t);
}, Hg = (t, e, n, o) => {
  const r = e._map.get(n) || null, i = t.doc, s = i.clientID;
  let a;
  if (o == null)
    a = new ws([o]);
  else
    switch (o.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        a = new ws([o]);
        break;
      case Uint8Array:
        a = new Yu(
          /** @type {Uint8Array} */
          o
        );
        break;
      case Pl:
        a = new Xu(
          /** @type {Doc} */
          o
        );
        break;
      default:
        if (o instanceof Dt)
          a = new jr(o);
        else
          throw new Error("Unexpected content type");
    }
  new cn(lt(s, Gt(i.store, s)), r, r && r.lastId, null, null, e, n, a).integrate(t, 0);
}, Vg = (t, e) => {
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, Y3 = (t) => {
  const e = {};
  return t._map.forEach((n, o) => {
    n.deleted || (e[o] = n.content.getContent()[n.length - 1]);
  }), e;
}, X3 = (t, e) => {
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted;
}, cF = (t, e) => {
  const n = {};
  return t._map.forEach((o, r) => {
    let i = o;
    for (; i !== null && (!e.sv.has(i.id.client) || i.id.clock >= (e.sv.get(i.id.client) || 0)); )
      i = i.left;
    i !== null && Ki(i, e) && (n[r] = i.content.getContent()[i.length - 1]);
  }), n;
}, uc = (t) => $z(
  t.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
);
class dF extends qu {
  /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */
  constructor(e, n) {
    super(e, n), this._transaction = n;
  }
}
class wa extends Dt {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const n = new wa();
    return n.push(e), n;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new wa();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const e = new wa();
    return e.insert(0, this.toArray().map(
      (n) => n instanceof Dt ? (
        /** @type {typeof el} */
        n.clone()
      ) : n
    )), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n), Ju(this, e, new dF(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? at(this.doc, (o) => {
      G3(
        o,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? at(this.doc, (n) => {
      lF(
        n,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? at(this.doc, (o) => {
      J3(o, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return K3(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return U3(this);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, n = this.length) {
    return j3(this, e, n);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof Dt ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return W3(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    sl(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return aF(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(bF);
  }
}
class uF extends qu {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, n, o) {
    super(e, n), this.keysChanged = o;
  }
}
class wd extends Dt {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this._prelimContent.forEach((o, r) => {
      this.set(r, o);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new wd();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new wd();
    return this.forEach((n, o) => {
      e.set(o, n instanceof Dt ? (
        /** @type {typeof value} */
        n.clone()
      ) : n);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    Ju(this, e, new uF(this, e, n));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const e = {};
    return this._map.forEach((n, o) => {
      if (!n.deleted) {
        const r = n.content.getContent()[n.length - 1];
        e[o] = r instanceof Dt ? r.toJSON() : r;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...uc(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return Qf(
      uc(this._map),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return Qf(
      uc(this._map),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return Qf(
      uc(this._map),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this._map.forEach((n, o) => {
      n.deleted || e(n.content.getContent()[n.length - 1], o, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? at(this.doc, (n) => {
      bd(n, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, n) {
    return this.doc !== null ? at(this.doc, (o) => {
      Hg(
        o,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.set(e, n), n;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      Vg(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return X3(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? at(this.doc, (e) => {
      this.forEach(function(n, o, r) {
        bd(e, r, o);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(wF);
  }
}
const yr = (t, e) => t === e || typeof t == "object" && typeof e == "object" && t && e && wz(t, e);
class Bh {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, n, o, r) {
    this.left = e, this.right = n, this.index = o, this.currentAttributes = r;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && Pr(), this.right.content.constructor) {
      case Et:
        this.right.deleted || Fs(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const Ay = (t, e, n) => {
  for (; e.right !== null && n > 0; ) {
    switch (e.right.content.constructor) {
      case Et:
        e.right.deleted || Fs(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (n < e.right.length && Lr(t, lt(e.right.id.client, e.right.id.clock + n)), e.index += e.right.length, n -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, fc = (t, e, n, o) => {
  const r = /* @__PURE__ */ new Map(), i = o ? Gu(e, n) : null;
  if (i) {
    const s = new Bh(i.p.left, i.p, i.index, r);
    return Ay(t, s, n - i.index);
  } else {
    const s = new Bh(null, e._start, 0, r);
    return Ay(t, s, n);
  }
}, Z3 = (t, e, n, o) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === Et && yr(
    o.get(
      /** @type {ContentFormat} */
      n.right.content.key
    ),
    /** @type {ContentFormat} */
    n.right.content.value
  )); )
    n.right.deleted || o.delete(
      /** @type {ContentFormat} */
      n.right.content.key
    ), n.forward();
  const r = t.doc, i = r.clientID;
  o.forEach((s, a) => {
    const l = n.left, c = n.right, d = new cn(lt(i, Gt(r.store, i)), l, l && l.lastId, c, c && c.id, e, null, new Et(a, s));
    d.integrate(t, 0), n.right = d, n.forward();
  });
}, Fs = (t, e) => {
  const { key: n, value: o } = e;
  o === null ? t.delete(n) : t.set(n, o);
}, Q3 = (t, e) => {
  for (; t.right !== null; ) {
    if (!(t.right.deleted || t.right.content.constructor === Et && yr(
      e[
        /** @type {ContentFormat} */
        t.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      t.right.content.value
    )))
      break;
    t.forward();
  }
}, e6 = (t, e, n, o) => {
  const r = t.doc, i = r.clientID, s = /* @__PURE__ */ new Map();
  for (const a in o) {
    const l = o[a], c = n.currentAttributes.get(a) ?? null;
    if (!yr(c, l)) {
      s.set(a, c);
      const { left: d, right: u } = n;
      n.right = new cn(lt(i, Gt(r.store, i)), d, d && d.lastId, u, u && u.id, e, null, new Et(a, l)), n.right.integrate(t, 0), n.forward();
    }
  }
  return s;
}, np = (t, e, n, o, r) => {
  n.currentAttributes.forEach((f, h) => {
    r[h] === void 0 && (r[h] = null);
  });
  const i = t.doc, s = i.clientID;
  Q3(n, r);
  const a = e6(t, e, n, r), l = o.constructor === String ? new Vo(
    /** @type {string} */
    o
  ) : o instanceof Dt ? new jr(o) : new Hs(o);
  let { left: c, right: d, index: u } = n;
  e._searchMarker && il(e._searchMarker, n.index, l.getLength()), d = new cn(lt(s, Gt(i.store, s)), c, c && c.lastId, d, d && d.id, e, null, l), d.integrate(t, 0), n.right = d, n.index = u, n.forward(), Z3(t, e, n, a);
}, Ey = (t, e, n, o, r) => {
  const i = t.doc, s = i.clientID;
  Q3(n, r);
  const a = e6(t, e, n, r);
  e:
    for (; n.right !== null && (o > 0 || a.size > 0 && (n.right.deleted || n.right.content.constructor === Et)); ) {
      if (!n.right.deleted)
        switch (n.right.content.constructor) {
          case Et: {
            const { key: l, value: c } = (
              /** @type {ContentFormat} */
              n.right.content
            ), d = r[l];
            if (d !== void 0) {
              if (yr(d, c))
                a.delete(l);
              else {
                if (o === 0)
                  break e;
                a.set(l, c);
              }
              n.right.delete(t);
            } else
              n.currentAttributes.set(l, c);
            break;
          }
          default:
            o < n.right.length && Lr(t, lt(n.right.id.client, n.right.id.clock + o)), o -= n.right.length;
            break;
        }
      n.forward();
    }
  if (o > 0) {
    let l = "";
    for (; o > 0; o--)
      l += `
`;
    n.right = new cn(lt(s, Gt(i.store, s)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, e, null, new Vo(l)), n.right.integrate(t, 0), n.forward();
  }
  Z3(t, e, n, a);
}, t6 = (t, e, n, o, r) => {
  let i = e;
  const s = to();
  for (; i && (!i.countable || i.deleted); ) {
    if (!i.deleted && i.content.constructor === Et) {
      const c = (
        /** @type {ContentFormat} */
        i.content
      );
      s.set(c.key, c);
    }
    i = i.right;
  }
  let a = 0, l = !1;
  for (; e !== i; ) {
    if (n === e && (l = !0), !e.deleted) {
      const c = e.content;
      switch (c.constructor) {
        case Et: {
          const { key: d, value: u } = (
            /** @type {ContentFormat} */
            c
          ), f = o.get(d) ?? null;
          (s.get(d) !== c || f === u) && (e.delete(t), a++, !l && (r.get(d) ?? null) === u && f !== u && (f === null ? r.delete(d) : r.set(d, f))), !l && !e.deleted && Fs(
            r,
            /** @type {ContentFormat} */
            c
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return a;
}, fF = (t, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const n = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === Et) {
      const o = (
        /** @type {ContentFormat} */
        e.content.key
      );
      n.has(o) ? e.delete(t) : n.add(o);
    }
    e = e.left;
  }
}, pF = (t) => {
  let e = 0;
  return at(
    /** @type {Doc} */
    t.doc,
    (n) => {
      let o = (
        /** @type {Item} */
        t._start
      ), r = t._start, i = to();
      const s = Oh(i);
      for (; r; ) {
        if (r.deleted === !1)
          switch (r.content.constructor) {
            case Et:
              Fs(
                s,
                /** @type {ContentFormat} */
                r.content
              );
              break;
            default:
              e += t6(n, o, r, i, s), i = Oh(s), o = r;
              break;
          }
        r = r.right;
      }
    }
  ), e;
}, hF = (t) => {
  const e = /* @__PURE__ */ new Set(), n = t.doc;
  for (const [o, r] of t.afterState.entries()) {
    const i = t.beforeState.get(o) || 0;
    r !== i && z3(
      t,
      /** @type {Array<Item|GC>} */
      n.store.clients.get(o),
      i,
      r,
      (s) => {
        !s.deleted && /** @type {Item} */
        s.content.constructor === Et && s.constructor !== fr && e.add(
          /** @type {any} */
          s.parent
        );
      }
    );
  }
  at(n, (o) => {
    D3(t, t.deleteSet, (r) => {
      if (r instanceof fr || !/** @type {YText} */
      r.parent._hasFormatting || e.has(
        /** @type {YText} */
        r.parent
      ))
        return;
      const i = (
        /** @type {YText} */
        r.parent
      );
      r.content.constructor === Et ? e.add(i) : fF(o, r);
    });
    for (const r of e)
      pF(r);
  });
}, _y = (t, e, n) => {
  const o = n, r = Oh(e.currentAttributes), i = e.right;
  for (; n > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case jr:
        case Hs:
        case Vo:
          n < e.right.length && Lr(t, lt(e.right.id.client, e.right.id.clock + n)), n -= e.right.length, e.right.delete(t);
          break;
      }
    e.forward();
  }
  i && t6(t, i, e.right, r, e.currentAttributes);
  const s = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return s._searchMarker && il(s._searchMarker, e.index, -o + n), e;
};
class mF extends qu {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, n, o) {
    super(e, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), o.forEach((r) => {
      r === null ? this.childListChanged = !0 : this.keysChanged.add(r);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), n = [];
      at(e, (o) => {
        const r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
        let s = this.target._start, a = null;
        const l = {};
        let c = "", d = 0, u = 0;
        const f = () => {
          if (a !== null) {
            let h = null;
            switch (a) {
              case "delete":
                u > 0 && (h = { delete: u }), u = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (h = { insert: c }, r.size > 0 && (h.attributes = {}, r.forEach((m, g) => {
                  m !== null && (h.attributes[g] = m);
                }))), c = "";
                break;
              case "retain":
                d > 0 && (h = { retain: d }, vz(l) || (h.attributes = hz({}, l))), d = 0;
                break;
            }
            h && n.push(h), a = null;
          }
        };
        for (; s !== null; ) {
          switch (s.content.constructor) {
            case jr:
            case Hs:
              this.adds(s) ? this.deletes(s) || (f(), a = "insert", c = s.content.getContent()[0], f()) : this.deletes(s) ? (a !== "delete" && (f(), a = "delete"), u += 1) : s.deleted || (a !== "retain" && (f(), a = "retain"), d += 1);
              break;
            case Vo:
              this.adds(s) ? this.deletes(s) || (a !== "insert" && (f(), a = "insert"), c += /** @type {ContentString} */
              s.content.str) : this.deletes(s) ? (a !== "delete" && (f(), a = "delete"), u += s.length) : s.deleted || (a !== "retain" && (f(), a = "retain"), d += s.length);
              break;
            case Et: {
              const { key: h, value: m } = (
                /** @type {ContentFormat} */
                s.content
              );
              if (this.adds(s)) {
                if (!this.deletes(s)) {
                  const g = r.get(h) ?? null;
                  yr(g, m) ? m !== null && s.delete(o) : (a === "retain" && f(), yr(m, i.get(h) ?? null) ? delete l[h] : l[h] = m);
                }
              } else if (this.deletes(s)) {
                i.set(h, m);
                const g = r.get(h) ?? null;
                yr(g, m) || (a === "retain" && f(), l[h] = g);
              } else if (!s.deleted) {
                i.set(h, m);
                const g = l[h];
                g !== void 0 && (yr(g, m) ? g !== null && s.delete(o) : (a === "retain" && f(), m === null ? delete l[h] : l[h] = m));
              }
              s.deleted || (a === "insert" && f(), Fs(
                r,
                /** @type {ContentFormat} */
                s.content
              ));
              break;
            }
          }
          s = s.right;
        }
        for (f(); n.length > 0; ) {
          const h = n[n.length - 1];
          if (h.retain !== void 0 && h.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class al extends Dt {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n);
    try {
      this._pending.forEach((o) => o());
    } catch (o) {
      console.error(o);
    }
    this._pending = null;
  }
  _copy() {
    return new al();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const e = new al();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n);
    const o = new mF(this, e, n);
    Ju(this, e, o), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let e = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === Vo && (e += /** @type {ContentString} */
      n.content.str), n = n.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: n = !0 } = {}) {
    this.doc !== null ? at(this.doc, (o) => {
      const r = new Bh(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        if (s.insert !== void 0) {
          const a = !n && typeof s.insert == "string" && i === e.length - 1 && r.right === null && s.insert.slice(-1) === `
` ? s.insert.slice(0, -1) : s.insert;
          (typeof a != "string" || a.length > 0) && np(o, this, r, a, s.attributes || {});
        } else
          s.retain !== void 0 ? Ey(o, this, r, s.retain, s.attributes || {}) : s.delete !== void 0 && _y(o, r, s.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, n, o) {
    const r = [], i = /* @__PURE__ */ new Map(), s = (
      /** @type {Doc} */
      this.doc
    );
    let a = "", l = this._start;
    function c() {
      if (a.length > 0) {
        const u = {};
        let f = !1;
        i.forEach((m, g) => {
          f = !0, u[g] = m;
        });
        const h = { insert: a };
        f && (h.attributes = u), r.push(h), a = "";
      }
    }
    const d = () => {
      for (; l !== null; ) {
        if (Ki(l, e) || n !== void 0 && Ki(l, n))
          switch (l.content.constructor) {
            case Vo: {
              const u = i.get("ychange");
              e !== void 0 && !Ki(l, e) ? (u === void 0 || u.user !== l.id.client || u.type !== "removed") && (c(), i.set("ychange", o ? o("removed", l.id) : { type: "removed" })) : n !== void 0 && !Ki(l, n) ? (u === void 0 || u.user !== l.id.client || u.type !== "added") && (c(), i.set("ychange", o ? o("added", l.id) : { type: "added" })) : u !== void 0 && (c(), i.delete("ychange")), a += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case jr:
            case Hs: {
              c();
              const u = {
                insert: l.content.getContent()[0]
              };
              if (i.size > 0) {
                const f = (
                  /** @type {Object<string,any>} */
                  {}
                );
                u.attributes = f, i.forEach((h, m) => {
                  f[m] = h;
                });
              }
              r.push(u);
              break;
            }
            case Et:
              Ki(l, e) && (c(), Fs(
                i,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      c();
    };
    return e || n ? at(s, (u) => {
      e && Lh(u, e), n && Lh(u, n), d();
    }, "cleanup") : d(), r;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, n, o) {
    if (n.length <= 0)
      return;
    const r = this.doc;
    r !== null ? at(r, (i) => {
      const s = fc(i, this, e, !o);
      o || (o = {}, s.currentAttributes.forEach((a, l) => {
        o[l] = a;
      })), np(i, this, s, n, o);
    }) : this._pending.push(() => this.insert(e, n, o));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, n, o) {
    const r = this.doc;
    r !== null ? at(r, (i) => {
      const s = fc(i, this, e, !o);
      np(i, this, s, n, o || {});
    }) : this._pending.push(() => this.insertEmbed(e, n, o || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, n) {
    if (n === 0)
      return;
    const o = this.doc;
    o !== null ? at(o, (r) => {
      _y(r, fc(r, this, e, !0), n);
    }) : this._pending.push(() => this.delete(e, n));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, n, o) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? at(r, (i) => {
      const s = fc(i, this, e, !1);
      s.right !== null && Ey(i, this, s, n, o);
    }) : this._pending.push(() => this.format(e, n, o));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? at(this.doc, (n) => {
      bd(n, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? at(this.doc, (o) => {
      Hg(o, this, e, n);
    }) : this._pending.push(() => this.setAttribute(e, n));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      Vg(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return Y3(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(xF);
  }
}
class op {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, n = () => !0) {
    this._filter = n, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, n = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(n)))
      do
        if (n = /** @type {any} */
        e.content.type, !e.deleted && (n.constructor === ll || n.constructor === bs) && n._start !== null)
          e = n._start;
        else
          for (; e !== null; )
            if (e.right !== null) {
              e = e.right;
              break;
            } else
              e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
              e.parent._item;
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class bs extends Dt {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new bs();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const e = new bs();
    return e.insert(0, this.toArray().map((n) => n instanceof Dt ? n.clone() : n)), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new op(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const o = new op(this, (r) => r.nodeName && r.nodeName.toUpperCase() === e).next();
    return o.done ? null : o.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), vs(new op(this, (n) => n.nodeName && n.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    Ju(this, e, new gF(this, n, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return W3(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, o) {
    const r = e.createDocumentFragment();
    return o !== void 0 && o._createAssociation(r, this), sl(this, (i) => {
      r.insertBefore(i.toDOM(e, n, o), null);
    }), r;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? at(this.doc, (o) => {
      G3(o, this, e, n);
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, n) {
    if (this.doc !== null)
      at(this.doc, (o) => {
        const r = e && e instanceof Dt ? e._item : e;
        yd(o, this, r, n);
      });
    else {
      const o = (
        /** @type {Array<any>} */
        this._prelimContent
      ), r = e === null ? 0 : o.findIndex((i) => i === e) + 1;
      if (r === 0 && e !== null)
        throw ys("Reference item not found");
      o.splice(r, 0, ...n);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? at(this.doc, (o) => {
      J3(o, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return U3(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return K3(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, n = this.length) {
    return j3(this, e, n);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    sl(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(CF);
  }
}
class ll extends bs {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((o, r) => {
      this.setAttribute(r, o);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new ll(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new ll(this.nodeName), n = this.getAttributes();
    return gz(n, (o, r) => {
      typeof o == "string" && e.setAttribute(r, o);
    }), e.insert(0, this.toArray().map((o) => o instanceof Dt ? o.clone() : o)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), n = [], o = [];
    for (const a in e)
      o.push(a);
    o.sort();
    const r = o.length;
    for (let a = 0; a < r; a++) {
      const l = o[a];
      n.push(l + '="' + e[l] + '"');
    }
    const i = this.nodeName.toLocaleLowerCase(), s = n.length > 0 ? " " + n.join(" ") : "";
    return `<${i}${s}>${super.toString()}</${i}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? at(this.doc, (n) => {
      bd(n, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? at(this.doc, (o) => {
      Hg(o, this, e, n);
    }) : this._prelimAttrs.set(e, n);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      Vg(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      X3(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? cF(this, e) : Y3(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, o) {
    const r = e.createElement(this.nodeName), i = this.getAttributes();
    for (const s in i) {
      const a = i[s];
      typeof a == "string" && r.setAttribute(s, a);
    }
    return sl(this, (s) => {
      r.appendChild(s.toDOM(e, n, o));
    }), o !== void 0 && o._createAssociation(r, this), r;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(kF), e.writeKey(this.nodeName);
  }
}
class gF extends qu {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(e, n, o) {
    super(e, o), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((r) => {
      r === null ? this.childListChanged = !0 : this.attributesChanged.add(r);
    });
  }
}
class cl extends al {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  _copy() {
    return new cl();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const e = new cl();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n, o) {
    const r = e.createTextNode(this.toString());
    return o !== void 0 && o._createAssociation(r, this), r;
  }
  toString() {
    return this.toDelta().map((e) => {
      const n = [];
      for (const r in e.attributes) {
        const i = [];
        for (const s in e.attributes[r])
          i.push({ key: s, value: e.attributes[r][s] });
        i.sort((s, a) => s.key < a.key ? -1 : 1), n.push({ nodeName: r, attrs: i });
      }
      n.sort((r, i) => r.nodeName < i.nodeName ? -1 : 1);
      let o = "";
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        o += `<${i.nodeName}`;
        for (let s = 0; s < i.attrs.length; s++) {
          const a = i.attrs[s];
          o += ` ${a.key}="${a.value}"`;
        }
        o += ">";
      }
      o += e.insert;
      for (let r = n.length - 1; r >= 0; r--)
        o += `</${n[r].nodeName}>`;
      return o;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(SF);
  }
}
class n6 {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, n) {
    this.id = e, this.length = n;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw no();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, n, o) {
    throw no();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    throw no();
  }
}
const vF = 0;
class fr extends n6 {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    n > 0 && (this.id.clock += n, this.length -= n), $3(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeInfo(vF), e.writeLen(this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    return null;
  }
}
class Yu {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new Yu(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw no();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
class xd {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new xd(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const n = new xd(this.len - e);
    return this.len = e, n;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    L3(e.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeLen(this.len - n);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const yF = (t, e) => new Pl({ guid: t, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class Xu {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const n = {};
    this.opts = n, e.gc || (n.gc = !1), e.autoLoad && (n.autoLoad = !0), e.meta !== null && (n.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new Xu(yF(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw no();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.doc._item = n, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
class Hs {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new Hs(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw no();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
class Et {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, n) {
    this.key = e, this.value = n;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new Et(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw no();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, n) {
    const o = (
      /** @type {YText} */
      n.parent
    );
    o._searchMarker = null, o._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
class ws {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new ws(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const n = new ws(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    const o = this.arr.length;
    e.writeLen(o - n);
    for (let r = n; r < o; r++) {
      const i = this.arr[r];
      e.writeAny(i);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
class Vo {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new Vo(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const n = new Vo(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const o = this.str.charCodeAt(e - 1);
    return o >= 55296 && o <= 56319 && (this.str = this.str.slice(0, e - 1) + "�", n.str = "�" + n.str.slice(1)), n;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const bF = 0, wF = 1, xF = 2, kF = 3, CF = 4, SF = 6;
class jr {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new jr(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw no();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.type._integrate(e.doc, n);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e), n = n.right;
    this.type._map.forEach((o) => {
      o.deleted ? o.id.clock < (e.beforeState.get(o.id.client) || 0) && e._mergeStructs.push(o) : o.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(e, !0), n = n.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (o) => {
        for (; o !== null; )
          o.gc(e, !0), o = o.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const o6 = (t, e, n) => {
  const { client: o, clock: r } = e.id, i = new cn(
    lt(o, r + n),
    e,
    lt(o, r + n - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(n)
  );
  return e.deleted && i.markDeleted(), e.keep && (i.keep = !0), e.redone !== null && (i.redone = lt(e.redone.client, e.redone.clock + n)), e.right = i, i.right !== null && (i.right.left = i), t._mergeStructs.push(i), i.parentSub !== null && i.right === null && i.parent._map.set(i.parentSub, i), e.length = n, i;
};
let cn = class $h extends n6 {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, n, o, r, i, s, a, l) {
    super(e, l.getLength()), this.origin = o, this.left = n, this.right = r, this.rightOrigin = i, this.parent = s, this.parentSub = a, this.redone = null, this.content = l, this.info = this.content.isCountable() ? ay : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & Yf) > 0 !== e && (this.info ^= Yf);
  }
  get marker() {
    return (this.info & Yf) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & sy) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= sy);
  }
  get countable() {
    return (this.info & ay) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & Jf) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= Jf);
  }
  markDeleted() {
    this.info |= Jf;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= Gt(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= Gt(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === Nc && this.id.client !== this.parent.client && this.parent.clock >= Gt(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = xy(e, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = Lr(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === fr || this.right && this.right.constructor === fr)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === $h && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === $h && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === Nc) {
      const o = tp(n, this.parent);
      o.constructor === fr ? this.parent = null : this.parent = /** @type {ContentType} */
      o.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    if (n > 0 && (this.id.clock += n, this.left = xy(e, e.doc.store, lt(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let o = this.left, r;
        if (o !== null)
          r = o.right;
        else if (this.parentSub !== null)
          for (r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = /** @type {AbstractType<any>} */
          this.parent._start;
        const i = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
        for (; r !== null && r !== this.right; ) {
          if (s.add(r), i.add(r), cc(this.origin, r.origin)) {
            if (r.id.client < this.id.client)
              o = r, i.clear();
            else if (cc(this.rightOrigin, r.rightOrigin))
              break;
          } else if (r.origin !== null && s.has(tp(e.doc.store, r.origin)))
            i.has(tp(e.doc.store, r.origin)) || (o = r, i.clear());
          else
            break;
          r = r.right;
        }
        this.left = o;
      }
      if (this.left !== null) {
        const o = this.left.right;
        this.right = o, this.left.right = this;
      } else {
        let o;
        if (this.parentSub !== null)
          for (o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; o !== null && o.left !== null; )
            o = o.left;
        else
          o = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = o;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), $3(e.doc.store, this), this.content.integrate(e, this), Cy(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new fr(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : lt(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && cc(e.origin, this.lastId) && this.right === e && cc(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return n && n.forEach((o) => {
        o.p === e && (o.p = this, !this.deleted && this.countable && (o.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), L3(e.deleteSet, this.id.client, this.id.clock, this.length), Cy(e, n, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, n) {
    if (!this.deleted)
      throw Pr();
    this.content.gc(e), n ? Qz(e, this, new fr(this.id, this.length)) : this.content = new xd(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, n) {
    const o = n > 0 ? lt(this.id.client, this.id.clock + n - 1) : this.origin, r = this.rightOrigin, i = this.parentSub, s = this.content.getRef() & V$ | (o === null ? 0 : gd) | // origin is defined
    (r === null ? 0 : S3) | // right origin is defined
    (i === null ? 0 : H$);
    if (e.writeInfo(s), o !== null && e.writeLeftID(o), r !== null && e.writeRightID(r), o === null && r === null) {
      const a = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (a._item !== void 0) {
        const l = a._item;
        if (l === null) {
          const c = rl(a);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(l.id);
      } else
        a.constructor === String ? (e.writeParentInfo(!0), e.writeString(a)) : a.constructor === Nc ? (e.writeParentInfo(!1), e.writeLeftID(a)) : Pr();
      i !== null && e.writeString(i);
    }
    this.content.write(e, n);
  }
};
const r6 = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), i6 = "__ $YJS$ __";
r6[i6] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
r6[i6] = !0;
const AF = new Be("y-sync");
new Be("y-undo");
new Be("yjs-cursor");
const EF = (t, e, n) => {
  if (t === 0)
    return ep(e, 0);
  let o = e._first === null ? null : (
    /** @type {Y.ContentType} */
    e._first.content.type
  );
  for (; o !== null && e !== o; ) {
    if (o instanceof cl) {
      if (o._length >= t)
        return ep(o, t);
      if (t -= o._length, o._item !== null && o._item.next !== null)
        o = /** @type {Y.ContentType} */
        o._item.next.content.type;
      else {
        do
          o = o._item === null ? null : o._item.parent, t--;
        while (o !== e && o !== null && o._item !== null && o._item.next === null);
        o !== null && o !== e && (o = o._item === null ? null : (
          /** @type {Y.ContentType} */
          /** @type Y.Item */
          o._item.next.content.type
        ));
      }
    } else {
      const r = (
        /** @type {any} */
        (n.get(o) || { nodeSize: 0 }).nodeSize
      );
      if (o._first !== null && t < r)
        o = /** @type {Y.ContentType} */
        o._first.content.type, t--;
      else {
        if (t === 1 && o._length === 0 && r > 1)
          return new vd(o._item === null ? null : o._item.id, o._item === null ? rl(o) : null, null);
        if (t -= r, o._item !== null && o._item.next !== null)
          o = /** @type {Y.ContentType} */
          o._item.next.content.type;
        else {
          if (t === 0)
            return o = o._item === null ? o : o._item.parent, new vd(o._item === null ? null : o._item.id, o._item === null ? rl(o) : null, null);
          do
            o = /** @type {Y.Item} */
            o._item.parent, t--;
          while (o !== e && /** @type {Y.Item} */
          o._item.next === null);
          o !== e && (o = /** @type {Y.ContentType} */
          /** @type {Y.Item} */
          /** @type {Y.Item} */
          o._item.next.content.type);
        }
      }
    }
    if (o === null)
      throw Pr();
    if (t === 0 && o.constructor !== cl && o !== e)
      return _F(o._item.parent, o._item);
  }
  return ep(e, e._length);
}, _F = (t, e) => {
  let n = null, o = null;
  return t._item === null ? o = rl(t) : n = lt(t._item.id.client, t._item.id.clock), new vd(n, o, e.id);
};
function jg(t, e, n) {
  const o = [], r = t.node(0);
  n = typeof n == "number" && n >= 0 ? n : t.sameParent(e) ? Math.max(0, t.sharedDepth(e.pos) - 1) : t.sharedDepth(e.pos);
  const i = new Oa(t, e, n), s = i.depth === 0 ? 0 : r.resolve(i.start).posAtIndex(0);
  return i.parent.forEach((a, l) => {
    const c = s + l, d = c + a.nodeSize;
    if (c < i.start || c >= i.end)
      return;
    const u = new dm(r.resolve(c), r.resolve(d));
    o.push(u);
  }), o;
}
class Ug {
  constructor(e, n) {
    Ws(this, "anchor");
    Ws(this, "head");
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new Ug(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), o = e.resolve(this.head);
    return new qn(n, o);
  }
}
class qn extends pe {
  constructor(n, o, r, i = 1) {
    const { doc: s } = n, a = n === o, l = n.pos === s.content.size && o.pos === s.content.size, c = a && !l ? s.resolve(o.pos + (i > 0 ? 1 : -1)) : o, d = a && l ? s.resolve(n.pos - (i > 0 ? 1 : -1)) : n, u = jg(d.min(c), d.max(c), r);
    super(c.pos >= n.pos ? u[0].$from : u[u.length - 1].$to, c.pos >= n.pos ? u[u.length - 1].$to : u[0].$from, u);
    Ws(this, "depth");
    this.depth = r;
  }
  get $to() {
    return this.ranges[this.ranges.length - 1].$to;
  }
  eq(n) {
    return n instanceof qn && n.$from.pos === this.$from.pos && n.$to.pos === this.$to.pos;
  }
  map(n, o) {
    const r = n.resolve(o.map(this.anchor)), i = n.resolve(o.map(this.head));
    return new qn(r, i);
  }
  toJSON() {
    return { type: "nodeRange", anchor: this.anchor, head: this.head };
  }
  get isForwards() {
    return this.head >= this.anchor;
  }
  get isBackwards() {
    return !this.isForwards;
  }
  extendBackwards() {
    const { doc: n } = this.$from;
    if (this.isForwards && this.ranges.length > 1) {
      const i = this.ranges.slice(0, -1), s = i[0].$from, a = i[i.length - 1].$to;
      return new qn(s, a, this.depth);
    }
    const o = this.ranges[0], r = n.resolve(Math.max(0, o.$from.pos - 1));
    return new qn(this.$anchor, r, this.depth);
  }
  extendForwards() {
    const { doc: n } = this.$from;
    if (this.isBackwards && this.ranges.length > 1) {
      const i = this.ranges.slice(1), s = i[0].$from, a = i[i.length - 1].$to;
      return new qn(a, s, this.depth);
    }
    const o = this.ranges[this.ranges.length - 1], r = n.resolve(Math.min(n.content.size, o.$to.pos + 1));
    return new qn(this.$anchor, r, this.depth);
  }
  static fromJSON(n, o) {
    return new qn(n.resolve(o.anchor), n.resolve(o.head));
  }
  static create(n, o, r, i, s = 1) {
    return new this(n.resolve(o), n.resolve(r), i, s);
  }
  getBookmark() {
    return new Ug(this.anchor, this.head);
  }
}
function MF(t) {
  const e = t.cloneNode(!0), n = [t, ...Array.from(t.getElementsByTagName("*"))], o = [e, ...Array.from(e.getElementsByTagName("*"))];
  return n.forEach((r, i) => {
    o[i].style.cssText = function(s) {
      let a = "";
      const l = getComputedStyle(s);
      for (let c = 0; c < l.length; c += 1)
        a += `${l[c]}:${l.getPropertyValue(l[c])};`;
      return a;
    }(r);
  }), e;
}
function pc(t, e) {
  return window.getComputedStyle(t)[e];
}
function TF(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function My(t) {
  t.parentNode !== null && t.parentNode !== void 0 && t.parentNode.removeChild(t);
}
const s6 = (t) => {
  const { x: e, y: n, direction: o, editor: r } = t;
  let i = null, s = null, a = null, l = e;
  for (; s === null && l < window.innerWidth && l > 0; ) {
    const c = document.elementsFromPoint(l, n), d = c.findIndex((f) => f.classList.contains("ProseMirror")), u = c.slice(0, d);
    if (u.length > 0) {
      const f = u[0];
      if (i = f, a = r.view.posAtDOM(f, 0), a >= 0) {
        s = r.state.doc.nodeAt(Math.max(a - 1, 0)), (s === null || s.isText) && (s = r.state.doc.nodeAt(Math.max(a - 1, 0))), s || (s = r.state.doc.nodeAt(Math.max(a, 0)));
        break;
      }
    }
    o === "left" ? l -= 1 : l += 1;
  }
  return { resultElement: i, resultNode: s, pos: a !== null ? a : null };
};
function OF(t, e) {
  const { doc: n } = e.view.state, o = s6({ editor: e, x: t.clientX, y: t.clientY, direction: "right" });
  if (!o.resultNode || o.pos === null)
    return [];
  const r = t.clientX, i = function(d, u, f) {
    const h = parseInt(pc(d.dom, "paddingLeft"), 10), m = parseInt(pc(d.dom, "paddingRight"), 10), g = parseInt(pc(d.dom, "borderLeftWidth"), 10), v = parseInt(pc(d.dom, "borderLeftWidth"), 10), y = d.dom.getBoundingClientRect();
    return { left: TF(u, y.left + h + g, y.right - m - v), top: f };
  }(e.view, r, t.clientY), s = e.view.posAtCoords(i);
  if (!s)
    return [];
  const { pos: a } = s;
  if (!n.resolve(a).parent)
    return [];
  const l = n.resolve(o.pos), c = n.resolve(o.pos + 1);
  return jg(l, c, 0);
}
const Ty = (t, e) => {
  const n = t.resolve(e), { depth: o } = n;
  return o === 0 ? e : n.pos - n.parentOffset - 1;
}, Oy = (t, e) => {
  const n = t.nodeAt(e), o = t.resolve(e);
  let { depth: r } = o, i = n;
  for (; r > 0; ) {
    const s = o.node(r);
    r -= 1, r === 0 && (i = s);
  }
  return i;
}, rp = (t, e) => {
  const n = AF.getState(t);
  return n ? EF(e, n.type, n.binding.mapping) : null;
}, Iy = (t, e) => {
  let n = e;
  for (; n && n.parentNode && n.parentNode !== t.dom; )
    n = n.parentNode;
  return n;
}, IF = new Be("dragHandle"), DF = ({ pluginKey: t = IF, element: e, editor: n, tippyOptions: o, onNodeChange: r }) => {
  const i = document.createElement("div");
  let s = null, a = !1, l = null, c = -1;
  return e.addEventListener("dragstart", (d) => {
    const { view: u } = n;
    if (!d.dataTransfer)
      return;
    const { empty: f, $from: h, $to: m } = u.state.selection, g = OF(d, n), v = jg(h, m, 0), y = v.some((N) => g.find((M) => M.$from === N.$from && M.$to === N.$to)), x = f || !y ? g : v;
    if (!x.length)
      return;
    const { tr: C } = u.state, b = document.createElement("div"), S = x[0].$from.pos, A = x[x.length - 1].$to.pos, I = qn.create(u.state.doc, S, A), z = I.content();
    x.forEach((N) => {
      const M = MF(u.nodeDOM(N.$from.pos));
      b.append(M);
    }), b.style.position = "absolute", b.style.top = "-10000px", document.body.append(b), d.dataTransfer.clearData(), d.dataTransfer.setDragImage(b, 0, 0), u.dragging = { slice: z, move: !0 }, C.setSelection(I), u.dispatch(C), document.addEventListener("drop", () => My(b), { once: !0 }), setTimeout(() => {
      e && (e.style.pointerEvents = "none");
    }, 0);
  }), e.addEventListener("dragend", () => {
    e && (e.style.pointerEvents = "auto");
  }), new Ne({
    key: typeof t == "string" ? new Be(t) : t,
    state: {
      init: () => ({ locked: !1 }),
      apply(d, u, f, h) {
        const m = d.getMeta("lockDragHandle"), g = d.getMeta("hideDragHandle");
        if (m !== void 0 && (a = m), g && s)
          return s.hide(), a = !1, l = null, c = -1, r == null || r({ editor: n, node: null, pos: -1 }), u;
        if (d.docChanged && c !== -1 && e && s) {
          const v = d.mapping.map(c);
          v !== c && (c = v, rp(h, c));
        }
        return u;
      }
    },
    view: (d) => {
      var u;
      return e.draggable = !0, e.style.pointerEvents = "auto", (u = n.view.dom.parentElement) === null || u === void 0 || u.appendChild(i), i.appendChild(e), i.style.pointerEvents = "none", i.style.position = "absolute", i.style.top = "0", i.style.left = "0", s = Hr(d.dom, {
        getReferenceClientRect: null,
        interactive: !0,
        trigger: "manual",
        placement: "left-start",
        hideOnClick: !1,
        duration: 100,
        zIndex: 10,
        popperOptions: {
          modifiers: [
            { name: "flip", enabled: !1 },
            { name: "preventOverflow", options: { rootBoundary: "document", mainAxis: !1 } }
          ]
        },
        ...o,
        appendTo: i,
        content: e
      }), {
        update(f, h) {
          if (!e || !s || (e.draggable = !a, d.state.doc.eq(h.doc) || c === -1))
            return;
          let m = d.nodeDOM(c);
          if (m = Iy(d, m), m === d.dom || (m == null ? void 0 : m.nodeType) !== 1)
            return;
          const g = d.posAtDOM(m, 0), v = Oy(n.state.doc, g);
          if (v !== l) {
            const y = Ty(n.state.doc, g);
            l = v, c = y, rp(d.state, c), r == null || r({ editor: n, node: l, pos: c }), s.setProps({ getReferenceClientRect: () => m.getBoundingClientRect() }), s.show();
          }
        },
        destroy() {
          s == null || s.destroy(), e && My(i);
        }
      };
    },
    props: {
      handleDOMEvents: {
        mouseleave: (d, u) => (a || u.target && !i.contains(u.relatedTarget) && (s == null || s.hide(), l = null, c = -1, r == null || r({ editor: n, node: null, pos: -1 })), !1),
        mousemove(d, u) {
          if (!e || !s || a)
            return !1;
          const f = s6({ x: u.clientX, y: u.clientY, direction: "right", editor: n });
          if (!f.resultElement)
            return !1;
          let h = f.resultElement;
          if (h = Iy(d, h), h === d.dom || (h == null ? void 0 : h.nodeType) !== 1)
            return !1;
          const m = d.posAtDOM(h, 0), g = Oy(n.state.doc, m);
          if (g !== l) {
            const v = Ty(n.state.doc, m);
            l = g, c = v, rp(d.state, c), r == null || r({ editor: n, node: l, pos: c }), s.setProps({ getReferenceClientRect: () => h.getBoundingClientRect() }), s.show();
          }
          return !1;
        }
      }
    }
  });
}, Wg = /* @__PURE__ */ T({
  __name: "DropdownMenu",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = De(t, e);
    return (i, s) => (k(), _(p(yR), Oe(Le(p(r))), {
      default: w(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Kg = /* @__PURE__ */ T({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const n = _t(t);
    return (o, r) => (k(), _(p(bR), j({ class: "outline-none" }, p(n)), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qg = /* @__PURE__ */ T({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(yh), null, {
      default: w(() => [
        E(p(wR), j(p(i), {
          class: p(fe)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            n.class
          )
        }), {
          default: w(() => [
            D(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), xn = /* @__PURE__ */ T({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(xR), j(p(o), {
      class: p(fe)(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        r.inset && "pl-8",
        e.class
      )
    }), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), RF = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, Vs = /* @__PURE__ */ T({
  __name: "DropdownMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:checked"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(CR), j(p(i), {
      class: p(fe)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: w(() => [
        B("span", RF, [
          E(p(SR), null, {
            default: w(() => [
              E(p(Vu), { class: "w-4 h-4" })
            ]),
            _: 1
          })
        ]),
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), a6 = /* @__PURE__ */ T({
  __name: "DropdownMenuShortcut",
  props: {
    class: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), U("span", {
      class: Ze(p(fe)("ml-auto text-xs tracking-widest opacity-60", e.class))
    }, [
      D(n.$slots, "default")
    ], 2));
  }
}), Zu = /* @__PURE__ */ T({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(kR), j(n.value, {
      class: p(fe)("-mx-1 my-1 h-px bg-muted", e.class)
    }), null, 16, ["class"]));
  }
}), Dy = /* @__PURE__ */ T({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = De(t, e);
    return (i, s) => (k(), _(p(AR), Oe(Le(p(r))), {
      default: w(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ry = /* @__PURE__ */ T({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(_R), j(p(o), {
      class: p(fe)(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
        e.class
      )
    }), {
      default: w(() => [
        D(r.$slots, "default"),
        E(p(ON), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Py = /* @__PURE__ */ T({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(ER), j(p(i), {
      class: p(fe)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        n.class
      )
    }), {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var Mo = /* @__PURE__ */ ((t) => (t[t.max = 7] = "max", t[t.min = 0] = "min", t[t.more = 1] = "more", t[t.less = -1] = "less", t))(Mo || {});
function PF(t, e, n) {
  return t < e ? e : t > n ? n : t;
}
function LF(t, e, n, o) {
  const { doc: r, selection: i } = t;
  if (!r || !i || !(i instanceof le || i instanceof Jt))
    return t;
  const { from: s, to: a } = i;
  return r.nodesBetween(s, a, (l, c) => {
    const d = l.type;
    return n.includes(d.name) ? (t = zh(t, c, e), !1) : !Vp(l.type.name, o.extensionManager.extensions);
  }), t;
}
function zh(t, e, n) {
  if (!t.doc)
    return t;
  const o = t.doc.nodeAt(e);
  if (!o)
    return t;
  const s = PF((o.attrs.indent || 0) + n, 0, 7);
  if (s === o.attrs.indent)
    return t;
  const a = {
    ...o.attrs,
    indent: s
  };
  return t.setNodeMarkup(e, o.type, a, o.marks);
}
function Ly({ delta: t, types: e }) {
  return ({ state: n, dispatch: o, editor: r }) => {
    const { selection: i } = n;
    let { tr: s } = n;
    return s = s.setSelection(i), s = LF(s, t, e, r), s.docChanged ? (o && o(s), !0) : !1;
  };
}
const NF = {
  class: "flex items-center gap-0.5",
  style: { "transition-property": "top, left", "transition-timing-function": "ease-in-out", "transition-duration": "0.2s" }
}, BF = { class: "ml-auto text-xs text-neutral-400" }, $F = { class: "ml-auto text-xs text-neutral-400" }, zF = { class: "ml-auto text-xs text-neutral-400" }, FF = { class: "ml-auto text-xs text-neutral-400" }, HF = { class: "ml-auto text-xs text-neutral-400" }, VF = /* @__PURE__ */ T({
  __name: "ContentMenu",
  props: {
    className: { default: "drag-handle" },
    editor: {},
    disabled: { type: Boolean, default: !1 },
    pluginKey: { default: "ContentItemMenu" }
  },
  setup(t) {
    const e = t, { t: n } = et(), o = O(null), r = O(null), i = O(null), s = O(-1), a = O(!1);
    _e(() => {
      o.value && !e.editor.isDestroyed && (r.value = DF({
        editor: e.editor,
        element: o.value,
        pluginKey: e.pluginKey,
        tippyOptions: {
          offset: [-2, 16],
          zIndex: 9,
          moveTransition: "transform 0.15s ease-out"
        },
        onNodeChange: g
      }), e.editor.registerPlugin(r.value));
    }), en(() => {
      r.value && e.editor.unregisterPlugin(e.pluginKey);
    });
    function l() {
      var x;
      const y = e.editor.chain();
      y.setNodeSelection(s.value).unsetAllMarks(), ((x = i.value) == null ? void 0 : x.type.name) !== "paragraph" && y.setParagraph(), y.run();
    }
    function c() {
      e.editor.chain().focus().setNodeSelection(s.value).run(), document.execCommand("copy");
    }
    function d() {
      var C;
      e.editor.commands.setNodeSelection(s.value);
      const { $anchor: y } = e.editor.state.selection, x = y.node(1) || e.editor.state.selection.node;
      e.editor.chain().setMeta("hideDragHandle", !0).insertContentAt(s.value + (((C = i.value) == null ? void 0 : C.nodeSize) || 0), x.toJSON()).run();
    }
    function u(y) {
      e.editor.commands.setTextAlign(y);
    }
    function f() {
      const y = zh(e.editor.state.tr, s.value, 1);
      y.setMeta("hideDragHandle", !0), e.editor.view.dispatch && e.editor.view.dispatch(y);
    }
    function h() {
      const y = zh(e.editor.state.tr, s.value, -1);
      e.editor.view.dispatch && e.editor.view.dispatch(y);
    }
    function m() {
      e.editor.chain().setMeta("hideDragHandle", !0).setNodeSelection(s.value).deleteSelection().run();
    }
    function g(y) {
      y.node && (i.value = y.node), s.value = y.pos;
    }
    function v() {
      var y, x, C, b;
      if (e.editor.isEditable && s.value !== -1) {
        const S = ((y = i.value) == null ? void 0 : y.nodeSize) || 0, A = s.value + S, I = ((x = i.value) == null ? void 0 : x.type.name) === "paragraph" && ((b = (C = i.value) == null ? void 0 : C.content) == null ? void 0 : b.size) === 0, z = I ? s.value + 2 : A + 2;
        e.editor.chain().command(({ dispatch: N, tr: M, state: $ }) => N ? (I ? M.insertText("/", s.value, s.value + 1) : M.insert(A, $.schema.nodes.paragraph.create(null, [$.schema.text("/")])), N(M)) : !0).focus(z).run();
      }
    }
    return ce(
      () => a.value,
      (y) => {
        y ? e.editor.commands.setMeta("lockDragHandle", !0) : e.editor.commands.setMeta("lockDragHandle", !1);
      }
    ), ce(
      () => e.editor.isDestroyed,
      (y) => {
        y && r.value && (e.editor.unregisterPlugin(e.pluginKey), r.value = null);
      }
    ), (y, x) => Sn((k(), U("div", {
      class: Ze(y.className),
      ref_key: "dragElement",
      ref: o,
      style: { "transition-property": "top, left", "transition-timing-function": "ease-in-out", "transition-duration": "0.2s" }
    }, [
      B("div", NF, [
        E(p(Pt), {
          variant: "ghost",
          onClick: v,
          size: "icon",
          class: "w-7 h-7 cursor-grab rounded-sm",
          disabled: y.disabled
        }, {
          default: w(() => [
            E(p(xe), {
              name: "Plus",
              class: "text-lg text-neutral-600 dark:text-neutral-200"
            })
          ]),
          _: 1
        }, 8, ["disabled"]),
        E(p(Wg), {
          open: a.value,
          "onUpdate:open": x[3] || (x[3] = (C) => a.value = C)
        }, {
          default: w(() => [
            E(p(Kg), { disable: y.disabled }, {
              default: w(() => [
                E(p(Ps), null, {
                  default: w(() => [
                    E(p(Is), null, {
                      default: w(() => [
                        E(p(Rs), { "as-child": "" }, {
                          default: w(() => [
                            E(p(Pt), {
                              variant: "ghost",
                              size: "icon",
                              class: "w-6 h-7 cursor-grab rounded-sm",
                              disabled: y.disabled
                            }, {
                              default: w(() => [
                                E(p(xe), {
                                  name: "Grip",
                                  class: "text-sm dark:text-neutral-200 text-neutral-600"
                                })
                              ]),
                              _: 1
                            }, 8, ["disabled"])
                          ]),
                          _: 1
                        }),
                        E(p(Ds), null, {
                          default: w(() => [
                            B("p", null, q(p(n)("editor.draghandle.tooltip")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["disable"]),
            E(p(qg), {
              class: "w-48",
              align: "start",
              side: "bottom"
            }, {
              default: w(() => [
                E(p(xn), {
                  onClick: m,
                  class: "flex gap-3 focus:text-red-500 focus:bg-red-400 hover:bg-red-400 dark:hover:text-red-500 bg-opacity-10 hover:bg-opacity-20 focus:bg-opacity-30 dark:hover:bg-opacity-20"
                }, {
                  default: w(() => [
                    E(p(xe), { name: "Trash2" }),
                    B("span", null, q(p(n)("editor.remove")), 1)
                  ]),
                  _: 1
                }),
                E(p(xn), {
                  class: "flex gap-3",
                  onClick: l
                }, {
                  default: w(() => [
                    E(p(xe), { name: "PaintRoller" }),
                    B("span", null, q(p(n)("editor.clear.tooltip")), 1)
                  ]),
                  _: 1
                }),
                E(p(xn), {
                  class: "flex gap-3",
                  onClick: c
                }, {
                  default: w(() => [
                    E(p(xe), { name: "Clipboard" }),
                    B("span", null, q(p(n)("editor.copyToClipboard")), 1)
                  ]),
                  _: 1
                }),
                E(p(xn), {
                  class: "flex gap-3",
                  onClick: d
                }, {
                  default: w(() => [
                    E(p(xe), { name: "Copy" }),
                    B("span", null, q(p(n)("editor.copy")), 1)
                  ]),
                  _: 1
                }),
                E(p(Zu)),
                E(p(Dy), null, {
                  default: w(() => [
                    E(p(Ry), { class: "flex gap-3" }, {
                      default: w(() => [
                        E(p(xe), { name: "AlignCenter" }),
                        B("span", null, q(p(n)("editor.textalign.tooltip")), 1)
                      ]),
                      _: 1
                    }),
                    E(p(yh), null, {
                      default: w(() => [
                        E(p(Py), null, {
                          default: w(() => [
                            E(p(xn), {
                              class: "flex gap-3",
                              onClick: x[0] || (x[0] = (C) => u("left"))
                            }, {
                              default: w(() => [
                                E(p(xe), { name: "AlignLeft" }),
                                B("span", null, q(p(n)("editor.textalign.left.tooltip")), 1),
                                B("span", BF, q(p(To)(["Mod", "Shift", "L"])), 1)
                              ]),
                              _: 1
                            }),
                            E(p(xn), {
                              class: "flex gap-3",
                              onClick: x[1] || (x[1] = (C) => u("center"))
                            }, {
                              default: w(() => [
                                E(p(xe), { name: "AlignCenter" }),
                                B("span", null, q(p(n)("editor.textalign.center.tooltip")), 1),
                                B("span", $F, q(p(To)(["Mod", "Shift", "E"])), 1)
                              ]),
                              _: 1
                            }),
                            E(p(xn), {
                              class: "flex gap-3",
                              onClick: x[2] || (x[2] = (C) => u("right"))
                            }, {
                              default: w(() => [
                                E(p(xe), { name: "AlignRight" }),
                                B("span", null, q(p(n)("editor.textalign.right.tooltip")), 1),
                                B("span", zF, q(p(To)(["Mod", "Shift", "R"])), 1)
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                E(p(Dy), null, {
                  default: w(() => [
                    E(p(Ry), { class: "flex gap-3" }, {
                      default: w(() => [
                        E(p(xe), { name: "IndentIncrease" }),
                        B("span", null, q(p(n)("editor.indent")), 1)
                      ]),
                      _: 1
                    }),
                    E(p(yh), null, {
                      default: w(() => [
                        E(p(Py), null, {
                          default: w(() => {
                            var C, b, S, A;
                            return [
                              E(p(xn), {
                                class: "flex gap-3",
                                onClick: f,
                                disabled: ((b = (C = i.value) == null ? void 0 : C.attrs) == null ? void 0 : b.indent) >= p(Mo).max
                              }, {
                                default: w(() => [
                                  E(p(xe), { name: "IndentIncrease" }),
                                  B("span", null, q(p(n)("editor.indent.tooltip")), 1),
                                  B("span", FF, q(p(To)(["Tab"])), 1)
                                ]),
                                _: 1
                              }, 8, ["disabled"]),
                              E(p(xn), {
                                class: "flex gap-3",
                                onClick: h,
                                disabled: ((A = (S = i.value) == null ? void 0 : S.attrs) == null ? void 0 : A.indent) <= p(Mo).min
                              }, {
                                default: w(() => [
                                  E(p(xe), { name: "IndentDecrease" }),
                                  B("span", null, q(p(n)("editor.outdent.tooltip")), 1),
                                  B("span", HF, q(p(To)(["Shift", "Tab"])), 1)
                                ]),
                                _: 1
                              }, 8, ["disabled"])
                            ];
                          }),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["open"])
      ])
    ], 2)), [
      [Jn, !y.disabled]
    ]);
  }
}), jF = ot.create({
  name: "column",
  content: "block+",
  isolating: !0,
  addAttributes() {
    return {
      position: {
        default: "",
        parseHTML: (t) => t.getAttribute("data-position"),
        renderHTML: (t) => ({ "data-position": t.position })
      }
    };
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["div", He(t, { "data-type": "column" }), 0];
  },
  parseHTML() {
    return [
      {
        tag: 'div[data-type="column"]'
      }
    ];
  }
});
var Yr = /* @__PURE__ */ ((t) => (t.SidebarLeft = "sidebar-left", t.SidebarRight = "sidebar-right", t.TwoColumn = "two-column", t))(Yr || {});
const lJ = ot.create({
  name: "columns",
  group: "columns",
  content: "column+",
  defining: !0,
  isolating: !0,
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      layout: "two-column"
      /* TwoColumn */
    };
  },
  addAttributes() {
    return {
      layout: {
        default: "two-column"
        /* TwoColumn */
      }
    };
  },
  addCommands() {
    return {
      setColumns: () => ({ commands: t }) => (t.insertContent(
        '<div data-type="columns"><div data-type="column" data-position="left"><p></p></div><div data-type="column" data-position="right"><p></p></div></div>'
      ), !0),
      setLayout: (t) => ({ commands: e }) => e.updateAttributes("columns", { layout: t })
    };
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["div", { "data-type": "columns", class: `layout-${t.layout}` }, 0];
  },
  parseHTML() {
    return [
      {
        tag: 'div[data-type="columns"]'
      }
    ];
  },
  addExtensions() {
    return [jF.configure(this.options.columnOptions)];
  }
}), l6 = (t, e) => {
  const {
    view: n,
    state: {
      selection: { from: o }
    }
  } = t, r = document.querySelectorAll(".focus"), i = r.length, a = r[i - 1];
  if (a && a.getAttribute("data-type") && a.getAttribute("data-type") === e || a && a.classList && a.classList.contains(e))
    return a;
  const l = n.domAtPos(o).node;
  let c = l;
  for (c.tagName || (c = l.parentElement); c && !(c.getAttribute("data-type") && c.getAttribute("data-type") === e) && !c.classList.contains(e); )
    c = c.parentElement;
  return c;
}, UF = { class: "p-2 bg-white rounded-lg dark:bg-black shadow-sm border border-neutral-200 dark:border-neutral-800" }, WF = { class: "flex gap-1 items-center" }, KF = /* @__PURE__ */ T({
  __name: "ColumnsBubbleMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, n = ({ editor: a }) => pu(a.view.state, "columns"), o = () => {
      const a = l6(e.editor, "columns");
      return (a == null ? void 0 : a.getBoundingClientRect()) || new DOMRect(-1e3, -1e3, 0, 0);
    }, r = () => {
      e.editor.chain().focus().setLayout(Yr.SidebarLeft).run();
    }, i = () => {
      e.editor.chain().focus().setLayout(Yr.SidebarRight).run();
    }, s = () => {
      e.editor.chain().focus().setLayout(Yr.TwoColumn).run();
    };
    return (a, l) => (k(), _(p(As), {
      editor: a.editor,
      pluginKey: "columns",
      shouldShow: n,
      updateDelay: 0,
      "tippy-options": {
        offset: [0, 8],
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        getReferenceClientRect: o,
        plugins: [p(Fm)],
        sticky: "popper"
      }
    }, {
      default: w(() => [
        B("div", UF, [
          B("div", WF, [
            E(ye, {
              icon: "PanelLeft",
              tooltip: "左侧边栏",
              action: r,
              isActive: () => a.editor.isActive("columns", { layout: p(Yr).SidebarLeft }),
              "tooltip-options": { sideOffset: 15 }
            }, null, 8, ["isActive"]),
            E(ye, {
              icon: "Columns",
              tooltip: "两栏布局",
              action: s,
              isActive: () => a.editor.isActive("columns", { layout: p(Yr).TwoColumn }),
              "tooltip-options": { sideOffset: 15 }
            }, null, 8, ["isActive"]),
            E(ye, {
              icon: "PanelRight",
              tooltip: "右侧边栏",
              action: i,
              isActive: () => a.editor.isActive("columns", { layout: p(Yr).SidebarRight }),
              "tooltip-options": { sideOffset: 15 }
            }, null, 8, ["isActive"])
          ])
        ])
      ]),
      _: 1
    }, 8, ["editor", "tippy-options"]));
  }
}), Gg = /* @__PURE__ */ T({
  __name: "Tabs",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    activationMode: {},
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const r = De(t, e);
    return (i, s) => (k(), _(p(pL), Oe(Le(p(r))), {
      default: w(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Jg = /* @__PURE__ */ T({
  __name: "TabsList",
  props: {
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(hL), j(n.value, {
      class: p(fe)(
        "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
        e.class
      )
    }), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), dl = /* @__PURE__ */ T({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(gL), j(p(o), {
      class: p(fe)(
        "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
        e.class
      )
    }), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), qF = { class: "border border-neutral-200 dark:border-neutral-800 px-3 py-2 transition-all select-none pointer-events-auto shadow-sm rounded-sm w-auto bg-background" }, GF = { class: "flex items-center flex-nowrap whitespace-nowrap h-[26px] justify-start relative gap-0.5" }, JF = { class: "flex items-center gap-2" }, YF = { class: "mt-3" }, XF = /* @__PURE__ */ T({
  __name: "ImageBubbleMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, { t: n } = et(), o = O("100"), r = O(), i = O(), s = O(), a = ["left", "center", "right"], l = {
      left: "AlignLeft",
      center: "AlignCenter",
      right: "AlignRight"
    };
    function c(b) {
      b == null || b.preventDefault(), e.editor.getAttributes("image").src && e.editor.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({
        width: r.value ? `${r.value}px` : null
      }).run();
    }
    function d(b) {
      const S = Math.max(0, Math.min(100, parseInt(o.value)));
      e.editor.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({ width: `${S}%` }).run();
    }
    const u = ({ editor: b }) => pu(b.view.state, "image"), f = P(() => {
      const b = l6(e.editor, "node-image");
      return (b == null ? void 0 : b.getBoundingClientRect()) || new DOMRect(-1e3, -1e3, 0, 0);
    });
    function h(b) {
      e.editor.chain().focus().setTextAlign(b).run();
    }
    ce(o, () => {
      o.value && d();
    }), ce(
      () => e.editor.getAttributes("image"),
      (b) => {
        b && (r.value = Math.round(parseFloat(b.originWidth)), i.value = Math.round(parseFloat(b.originHeight)), s.value = b.originWidth / b.originHeight);
      }
    );
    function m() {
      i.value && s.value ? r.value = Math.max(30, Math.round(i.value * s.value)) : r.value = null;
    }
    function g() {
      r.value && s.value ? i.value = Math.max(20, Math.round(r.value / s.value)) : i.value = null;
    }
    function v(b) {
      h(b);
    }
    function y() {
      const b = e.editor.getAttributes("image"), { flipX: S } = b;
      e.editor.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({
        flipX: !S
      }).run();
    }
    function x() {
      const b = e.editor.getAttributes("image"), { flipY: S } = b;
      e.editor.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({
        flipY: !S
      }).run();
    }
    function C() {
      const { state: b, dispatch: S } = e.editor.view;
      km(b, S);
    }
    return (b, S) => {
      const A = ye, I = Bo, z = Ns, N = ya, M = Rr, $ = dl, L = Jg, Y = Gg, J = Bs, ne = Ls;
      return k(), _(p(As), {
        editor: b.editor,
        pluginKey: "image-menus-123",
        shouldShow: u,
        updateDelay: 0,
        "tippy-options": {
          offset: [0, 8],
          zIndex: 10,
          popperOptions: {
            modifiers: [{ name: "flip", enabled: !1 }]
          },
          appendTo: "parent",
          getReferenceClientRect: p(f).value,
          plugins: [p(Fm)],
          sticky: "popper"
        }
      }, {
        default: w(() => [
          B("div", qF, [
            B("div", GF, [
              E(A, {
                tooltip: p(n)("editor.image.menu.flipX"),
                icon: "FlipVertical",
                action: y
              }, null, 8, ["tooltip"]),
              E(A, {
                tooltip: p(n)("editor.image.menu.flipY"),
                icon: "FlipHorizontal",
                action: x
              }, null, 8, ["tooltip"]),
              E(I, {
                orientation: "vertical",
                class: "mx-1 me-2 h-[16px]"
              }),
              E(ne, null, {
                default: w(() => [
                  E(z, null, {
                    default: w(() => [
                      E(A, {
                        title: p(n)("editor.image.menu.size"),
                        icon: "ImageSize"
                      }, null, 8, ["title"])
                    ]),
                    _: 1
                  }),
                  E(J, { class: "w-84" }, {
                    default: w(() => [
                      B("div", JF, [
                        E(N, {
                          for: "maxWidth",
                          class: "whitespace-nowrap"
                        }, {
                          default: w(() => [
                            he(q(p(n)("editor.image.menu.size.width")), 1)
                          ]),
                          _: 1
                        }),
                        E(M, {
                          id: "maxWidth",
                          modelValue: p(r),
                          "onUpdate:modelValue": S[0] || (S[0] = (F) => ri(r) ? r.value = F : null),
                          type: "number",
                          onInput: g,
                          onKeyup: Sr(c, ["enter"]),
                          class: "w-20 h-8 [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                        }, null, 8, ["modelValue"]),
                        E(N, {
                          for: "maxWidth",
                          class: "whitespace-nowrap"
                        }, {
                          default: w(() => [
                            he(q(p(n)("editor.image.menu.size.height")), 1)
                          ]),
                          _: 1
                        }),
                        E(M, {
                          id: "maxWidth",
                          modelValue: p(i),
                          "onUpdate:modelValue": S[1] || (S[1] = (F) => ri(i) ? i.value = F : null),
                          type: "number",
                          onInput: m,
                          onKeyup: Sr(c, ["enter"]),
                          class: "w-20 h-8 [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                        }, null, 8, ["modelValue"])
                      ]),
                      B("div", YF, [
                        E(Y, {
                          "model-value": p(o),
                          "onUpdate:modelValue": [
                            S[2] || (S[2] = (F) => ri(o) ? o.value = F : null),
                            S[3] || (S[3] = (F) => {
                              o.value = F;
                            })
                          ]
                        }, {
                          default: w(() => [
                            E(L, null, {
                              default: w(() => [
                                (k(), U(ve, null, Fe(["25", "50", "75", "100"], (F) => E($, {
                                  key: F,
                                  value: F
                                }, {
                                  default: w(() => [
                                    he(q(F) + "% ", 1)
                                  ]),
                                  _: 2
                                }, 1032, ["value"])), 64))
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["model-value"])
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              E(I, {
                orientation: "vertical",
                class: "mx-1 me-2 h-[16px]"
              }),
              (k(), U(ve, null, Fe(a, (F, R) => E(A, {
                key: R,
                tooltip: p(n)(`editor.textalign.${F}.tooltip`),
                icon: l[F],
                action: () => v(F),
                disabled: !b.editor.can().setTextAlign(F),
                "is-active": () => b.editor.isActive({ textAlign: F }) || !1
              }, null, 8, ["tooltip", "icon", "action", "disabled", "is-active"])), 64)),
              E(I, {
                orientation: "vertical",
                class: "mx-1 me-2 h-[16px]"
              }),
              E(A, {
                tooltip: p(n)("editor.remove"),
                icon: "Trash2",
                action: C,
                disabled: !b.editor.isEditable
              }, null, 8, ["tooltip", "disabled"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["editor", "tippy-options"]);
    };
  }
}), Yg = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [o, r] of e)
    n[o] = r;
  return n;
}, ZF = {}, QF = { class: "flex select-none items-center p-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 hover:bg-accent rounded-sm gap-2" };
function eH(t, e) {
  return k(), U("div", QF, [
    D(t.$slots, "default")
  ]);
}
const hc = /* @__PURE__ */ Yg(ZF, [["render", eH]]), tH = { class: "bg-popover mt-3 text-foreground overflow-auto flex-wrap border rounded-md p-3 max-w-60" }, nH = { class: "flex flex-col gap-1" }, oH = /* @__PURE__ */ T({
  __name: "AiCompletion",
  props: {
    editor: {
      type: c2,
      required: !0
    },
    completion: {
      type: String,
      required: !0
    }
  },
  emits: ["generate", "close"],
  setup(t, { emit: e }) {
    const n = t, { t: o } = et(), r = e;
    function i() {
      const c = n.editor.view.state.selection;
      n.editor.chain().focus().deleteRange({
        from: c.from,
        to: c.to
      }).insertContent(n.completion).run();
    }
    function s() {
      const { to: c } = n.editor.view.state.selection;
      c && n.editor.chain().focus().insertContentAt(c + 1, n.completion).run();
    }
    function a() {
      r("generate");
    }
    function l() {
      r("close");
    }
    return (c, d) => (k(), U("div", tH, [
      B("div", nH, [
        E(hc, { onClick: i }, {
          default: w(() => [
            E(p(xe), { name: "Replace" }),
            he(" " + q(p(o)("editor.AI.replace")), 1)
          ]),
          _: 1
        }),
        E(hc, { onClick: s }, {
          default: w(() => [
            E(p(xe), { name: "TextQuote" }),
            he(" " + q(p(o)("editor.AI.insert")), 1)
          ]),
          _: 1
        }),
        E(p(Bo)),
        E(hc, { onClick: a }, {
          default: w(() => [
            E(p(xe), { name: "Redo2" }),
            he(" " + q(p(o)("editor.AI.regenerate")), 1)
          ]),
          _: 1
        }),
        E(hc, { onClick: l }, {
          default: w(() => [
            E(p(xe), { name: "Trash2" }),
            he(" " + q(p(o)("editor.AI.close")), 1)
          ]),
          _: 1
        })
      ])
    ]));
  }
}), rH = 1, iH = 1e6, Ro = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST"
};
let ip = 0;
function sH() {
  return ip = (ip + 1) % Number.MAX_VALUE, ip.toString();
}
const sp = /* @__PURE__ */ new Map();
function Ny(t) {
  if (sp.has(t))
    return;
  const e = setTimeout(() => {
    sp.delete(t), xa({
      type: Ro.REMOVE_TOAST,
      toastId: t
    });
  }, iH);
  sp.set(t, e);
}
const Ln = O({
  toasts: []
});
function xa(t) {
  switch (t.type) {
    case Ro.ADD_TOAST:
      Ln.value.toasts = [t.toast, ...Ln.value.toasts].slice(0, rH);
      break;
    case Ro.UPDATE_TOAST:
      Ln.value.toasts = Ln.value.toasts.map((e) => e.id === t.toast.id ? { ...e, ...t.toast } : e);
      break;
    case Ro.DISMISS_TOAST: {
      const { toastId: e } = t;
      e ? Ny(e) : Ln.value.toasts.forEach((n) => {
        Ny(n.id);
      }), Ln.value.toasts = Ln.value.toasts.map(
        (n) => n.id === e || e === void 0 ? {
          ...n,
          open: !1
        } : n
      );
      break;
    }
    case Ro.REMOVE_TOAST:
      t.toastId === void 0 ? Ln.value.toasts = [] : Ln.value.toasts = Ln.value.toasts.filter((e) => e.id !== t.toastId);
      break;
  }
}
function js() {
  return {
    toasts: P(() => Ln.value.toasts),
    toast: aH,
    dismiss: (t) => xa({ type: Ro.DISMISS_TOAST, toastId: t })
  };
}
function aH(t) {
  const e = sH(), n = (r) => xa({
    type: Ro.UPDATE_TOAST,
    toast: { ...r, id: e }
  }), o = () => xa({ type: Ro.DISMISS_TOAST, toastId: e });
  return xa({
    type: Ro.ADD_TOAST,
    toast: {
      ...t,
      id: e,
      open: !0,
      onOpenChange: (r) => {
        r || o();
      }
    }
  }), {
    id: e,
    dismiss: o,
    update: n
  };
}
const lH = ["onMouseenter", "onClick"], cH = {
  key: 1,
  class: "absolute left-full top-0 bg-background shadow-md rounded-sm border border-sm"
}, dH = { class: "p-1 flex flex-col gap-1 min-w-32" }, uH = ["onMouseenter", "onClick"], fH = /* @__PURE__ */ T({
  __name: "menu",
  props: {
    items: {}
  },
  emits: ["itemClick"],
  setup(t, { expose: e, emit: n }) {
    const o = t, r = n, i = O(null), s = zn([]), a = O(0), l = O(-1), c = (v) => v.map((y, x) => {
      var C;
      return {
        ...y,
        isSelected: x === 0,
        // 默认选中第一项
        children: (C = y.children) == null ? void 0 : C.map((b) => ({
          ...b,
          isSelected: !1
        }))
      };
    });
    _e(() => {
      s.splice(0, s.length, ...c(o.items)), qe(() => {
        var v;
        (v = i.value) == null || v.focus();
      });
    }), ce(
      () => o.items,
      (v) => {
        s.splice(0, s.length, ...c(v));
      },
      { deep: !0 }
    ), e({ handleKeyDown: (v) => {
      var x, C;
      const y = l.value !== -1;
      switch (v.key) {
        case "ArrowDown":
          if (v.preventDefault(), y && s[a.value].children) {
            const S = s[a.value].children;
            l.value = (l.value + 1) % S.length, f();
          } else
            a.value = (a.value + 1) % s.length, l.value = -1, u();
          break;
        case "ArrowUp":
          if (v.preventDefault(), y && s[a.value].children) {
            const S = s[a.value].children;
            l.value = (l.value - 1 + S.length) % S.length, f();
          } else
            a.value = (a.value - 1 + s.length) % s.length, l.value = -1, u();
          break;
        case "ArrowRight":
          v.preventDefault(), !y && ((x = s[a.value].children) != null && x.length) && (l.value = 0, f());
          break;
        case "ArrowLeft":
          v.preventDefault(), y && (l.value = -1, u());
          break;
        case "Enter":
          v.preventDefault();
          const b = y ? (C = s[a.value].children) == null ? void 0 : C[l.value] : s[a.value];
          b && !b.children && g(b);
          break;
      }
    } });
    const u = () => {
      s.forEach((v, y) => {
        v.isSelected = y === a.value, v.children && v.children.forEach((x) => {
          x.isSelected = !1;
        });
      });
    }, f = () => {
      const v = s[a.value];
      v.children && v.children.forEach((y, x) => {
        y.isSelected = x === l.value;
      });
    }, h = (v) => {
      a.value = v, l.value = -1, u();
    }, m = (v, y) => {
      a.value = v, l.value = y, f();
    }, g = (v) => {
      v.children || r("itemClick", v);
    };
    return (v, y) => (k(), U("div", {
      class: "p-1 bg-background rounded-sm outline-none shadow-md border flex flex-col gap-1",
      tabindex: "0",
      ref_key: "menuRef",
      ref: i
    }, [
      (k(!0), U(ve, null, Fe(s, (x, C) => (k(), U("div", {
        key: x.label,
        class: Ze([
          "relative flex items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors cursor-pointer",
          x.isSelected ? "bg-accent text-accent-foreground" : "",
          "hover:bg-accent hover:text-accent-foreground"
        ]),
        onMouseenter: (b) => h(C),
        onClick: (b) => g(x)
      }, [
        B("span", null, q(x.label), 1),
        x.children && x.isSelected ? (k(), _(p(xe), {
          key: 0,
          name: "ChevronRight",
          class: "ml-auto h-4 w-4"
        })) : ae("", !0),
        x.children && x.isSelected ? (k(), U("div", cH, [
          B("div", dH, [
            (k(!0), U(ve, null, Fe(x.children, (b, S) => (k(), U("div", {
              key: b.label,
              class: Ze([
                "flex items-center rounded-sm px-2 py-1.5 text-sm whitespace-nowrap outline-none transition-colors cursor-pointer",
                b.isSelected ? "bg-accent text-accent-foreground" : "",
                "hover:bg-accent hover:text-accent-foreground"
              ]),
              onMouseenter: (A) => m(C, S),
              onClick: (A) => g(b)
            }, [
              B("span", null, q(b.label), 1)
            ], 42, uH))), 128))
          ])
        ])) : ae("", !0)
      ], 42, lH))), 128))
    ], 512));
  }
});
function pH(t) {
  const e = O(""), n = O("init"), o = O([]), { toast: r } = js(), i = O(null);
  async function s(c, d) {
    var f, h, m;
    n.value = "generating", e.value = "";
    const u = (f = t.extensionManager.extensions.find((g) => g.name === "AI")) == null ? void 0 : f.options;
    try {
      o.value.length === 0 ? o.value.push({
        role: "user",
        content: `Question: ${d} Context:${c}`
      }) : o.value.push({
        role: "user",
        content: d
      }), i.value = new AbortController();
      const g = await u.completions(o.value, i.value.signal);
      if (!g)
        throw new Error("Failed to create stream");
      let v = "";
      for await (const y of g) {
        const x = ((m = (h = y.choices[0]) == null ? void 0 : h.delta) == null ? void 0 : m.content) || "";
        e.value += x, v += x;
      }
      return o.value.push({
        role: "assistant",
        content: v
      }), n.value = "completed", v;
    } catch (g) {
      throw g.name === "AbortError" ? n.value = "init" : r({
        title: (g == null ? void 0 : g.message) || "Failed to generate AI completion",
        variant: "destructive"
      }), g;
    }
  }
  function a() {
    e.value = "", n.value = "init", o.value = [], i.value = null;
  }
  return {
    result: e,
    status: n,
    conversationHistory: o,
    handleCompletion: s,
    resetConversation: a,
    stopGeneration: () => {
      i.value && (i.value.abort(), i.value = null);
    }
  };
}
const hH = [
  {
    label: "editor.AI.shortcuts.generate.title",
    children: [
      {
        label: "editor.AI.shortcuts.generate.improve",
        prompt: "Rewrite this content with no spelling mistakes, proper grammar, and with more descriptive language, using best writing practices without losing the original meaning."
      },
      {
        label: "editor.AI.shortcuts.generate.shorter",
        prompt: "Remove any repetitive, redundant, or non-essential writing in this content without changing the meaning or losing any key information."
      },
      {
        label: "editor.AI.shortcuts.generate.longer",
        prompt: "Expand upon this content with descriptive language and more detailed explanations, to make the writing easier to understand and increase the length of the content."
      },
      {
        label: "editor.AI.shortcuts.generate.summarize",
        prompt: "Provide the key points and concepts in this content in a succinct summary."
      },
      {
        label: "editor.AI.shortcuts.generate.continue",
        prompt: "Expand and continue this content, maintaining the original tone and style. Ensure that the continuation flows naturally from the existing writing while adding new ideas, further details, or continuing the narrative or argument in a coherent manner."
      }
    ]
  },
  {
    label: "editor.AI.shortcuts.tone.title",
    children: [
      {
        label: "editor.AI.shortcuts.tone.professional",
        prompt: "Rewrite this content using polished, formal, and respectful language to convey professional expertise and competence."
      },
      {
        label: "editor.AI.shortcuts.tone.casual",
        prompt: "Rewrite this content with casual, informal language to convey a casual conversation with a real person."
      },
      {
        label: "editor.AI.shortcuts.tone.direct",
        prompt: "Rewrite this content with direct language using only the essential information."
      },
      {
        label: "editor.AI.shortcuts.tone.confident",
        prompt: "Rewrite this content using compelling, optimistic language to convey confidence in the writing."
      },
      {
        label: "editor.AI.shortcuts.tone.friendly",
        prompt: "Rewrite this content using friendly, comforting language, to convey understanding and empathy."
      }
    ]
  },
  {
    label: "editor.AI.shortcuts.style.title",
    children: [
      {
        label: "editor.AI.shortcuts.style.business",
        prompt: "Rewrite this content as a business professional with formal language."
      },
      {
        label: "editor.AI.shortcuts.style.legal",
        prompt: "Rewrite this content as a legal professional using valid legal terminology."
      },
      {
        label: "editor.AI.shortcuts.style.journalism",
        prompt: "Rewrite this content as a journalist using engaging language to convey the importance of the information."
      },
      {
        label: "editor.AI.shortcuts.style.medical",
        prompt: "Rewrite this content as a medical professional using valid medical terminology."
      },
      {
        label: "editor.AI.shortcuts.style.poetic",
        prompt: "Rewrite this content as a poem using poetic techniques without losing the original meaning."
      }
    ]
  },
  {
    label: "editor.AI.shortcuts.translate.title",
    children: [
      {
        label: "editor.AI.shortcuts.translate.english",
        prompt: "Translate this content to English language."
      },
      {
        label: "editor.AI.shortcuts.translate.chinese",
        prompt: "Translate this content to Simplified Chinese language."
      },
      {
        label: "editor.AI.shortcuts.translate.spanish",
        prompt: "Translate this content to Spanish language."
      },
      {
        label: "editor.AI.shortcuts.translate.german",
        prompt: "Translate this content to German language."
      },
      {
        label: "editor.AI.shortcuts.translate.french",
        prompt: "Translate this content to French language."
      },
      {
        label: "editor.AI.shortcuts.translate.russian",
        prompt: "Translate this content to Russian language."
      },
      {
        label: "editor.AI.shortcuts.translate.portuguese",
        prompt: "Translate this content to Simplified Portuguese language."
      },
      {
        label: "editor.AI.shortcuts.translate.korean",
        prompt: "Translate this content to Simplified Korean language."
      },
      {
        label: "editor.AI.shortcuts.translate.japanese",
        prompt: "Translate this content to Simplified Japanese language."
      },
      {
        label: "editor.AI.shortcuts.translate.hindi",
        prompt: "Translate this content to Simplified Hindi language."
      },
      {
        label: "editor.AI.shortcuts.translate.arabic",
        prompt: "Translate this content to Simplified Arabic language."
      }
    ]
  }
], mH = { class: "border rounded-sm shadow-sm bg-background" }, gH = ["innerHTML"], vH = {
  key: 0,
  class: "text_loading_animation border w-full rounded-md pl-10 pr-20 h-12 py-1 flex items-center text-sm text-foreground"
}, yH = { class: "absolute start-0 inset-y-0 flex items-center justify-center px-2" }, bH = { class: "mt-3 max-w-56" }, wH = /* @__PURE__ */ T({
  __name: "AIMenu",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, n = pn(), o = O(""), r = O(null), i = O(null), { focused: s } = Ym(i), a = O(null), { t: l } = et(), c = O(!1), d = O(null), u = O(), { result: f, status: h, handleCompletion: m, resetConversation: g } = pH(e.editor), { toast: v } = js(), y = (L) => {
      const Y = L.state.selection.content(), ne = Nr.fromSchema(L.schema).serializeFragment(Y.content), F = document.createElement("div");
      return F.appendChild(ne), F.innerHTML;
    }, x = Z9(
      () => {
        a.value && (a.value.scrollTop = a.value.scrollHeight);
      },
      100,
      { maxWait: 200 }
    );
    async function C() {
      if (!e.editor) {
        v({
          title: l.value("editor.AI.error"),
          description: l.value("editor.AI.editorNotFound"),
          variant: "destructive"
        });
        return;
      }
      try {
        h.value = "generating";
        const L = y(e.editor);
        if (!L.trim()) {
          v({
            title: l.value("editor.AI.error"),
            description: l.value("editor.AI.noSelection"),
            variant: "destructive"
          });
          return;
        }
        await m(L, o.value), r.value = {
          context: L,
          prompt: o.value
        }, o.value = "", await qe(), s.value = !0, x();
      } catch (L) {
        v({
          title: l.value("editor.AI.error"),
          description: L instanceof Error ? L.message : l.value("editor.AI.unknownError"),
          variant: "destructive"
        }), A();
      }
    }
    const b = zn({
      maxWidth: 600,
      zIndex: 99,
      appendTo: "parent",
      placement: "bottom-start",
      onShow(L) {
        d.value = L, setTimeout(() => {
          s.value = !0;
        }, 30);
      },
      onHide() {
        A();
      },
      onDestroy() {
        d.value = null;
      },
      // hideOnClick: true,
      interactive: !0
    }), S = P(() => n == null ? void 0 : n.state.AIMenu);
    function A() {
      o.value = "", r.value = null, g(), n.state.AIMenu = !1;
    }
    function I() {
      var L, Y;
      if (!((L = r.value) != null && L.context) || !((Y = r.value) != null && Y.prompt)) {
        v({
          title: l.value("editor.AI.error"),
          description: l.value("editor.AI.noCachedPrompt"),
          variant: "destructive"
        });
        return;
      }
      try {
        h.value = "generating", g(), m(r.value.context, r.value.prompt).then(() => {
          x();
        }).catch((J) => {
          v({
            title: l.value("editor.AI.error"),
            description: J instanceof Error ? J.message : l.value("editor.AI.regenerateError"),
            variant: "destructive"
          }), A();
        });
      } catch (J) {
        v({
          title: l.value("editor.AI.error"),
          description: J instanceof Error ? J.message : l.value("editor.AI.unknownError"),
          variant: "destructive"
        }), A();
      }
    }
    function z() {
      if (h.value === "init" && o.value === "") {
        A();
        return;
      }
      c.value = !0, setTimeout(() => {
        c.value = !1;
      }, 820);
    }
    function N(L) {
      if (!e.editor) {
        v({
          title: l.value("editor.AI.error"),
          description: l.value("editor.AI.editorNotFound"),
          variant: "destructive"
        });
        return;
      }
      try {
        const Y = y(e.editor);
        r.value = {
          context: Y,
          prompt: L.prompt
        }, h.value = "generating", m(Y, L.prompt).then(() => {
          x(), s.value = !0;
        }).catch((J) => {
          v({
            title: l.value("editor.AI.error"),
            description: J instanceof Error ? J.message : l.value("editor.AI.shortcutError"),
            variant: "destructive"
          }), A();
        });
      } catch (Y) {
        v({
          title: l.value("editor.AI.error"),
          description: Y instanceof Error ? Y.message : l.value("editor.AI.unknownError"),
          variant: "destructive"
        }), A();
      }
    }
    const M = P(() => {
      var J, ne, F;
      const L = (F = (ne = (J = e.editor) == null ? void 0 : J.extensionManager.extensions.find((R) => R.name === "AI")) == null ? void 0 : ne.options) == null ? void 0 : F.shortcuts;
      return [...hH, ...L].map((R) => {
        var H;
        return {
          ...R,
          label: l.value(R.label),
          children: (H = R.children) == null ? void 0 : H.map((K) => ({
            ...K,
            label: l.value(K.label)
          }))
        };
      });
    });
    function $(L) {
      var Y;
      h.value === "init" && M.value.length && !o.value && ((Y = u.value) == null || Y.handleKeyDown(L));
    }
    return (L, Y) => Sn((k(), U("div", {
      class: "absolute left-0 right-0 top-0 bottom-0",
      style: ct({
        zIndex: p(h) === "init" && o.value === "" ? -1 : 98
      }),
      onClick: z
    }, [
      Sn(E(p(As), {
        pluginKey: "AIMenu",
        "update-delay": 0,
        editor: L.editor,
        "tippy-options": b
      }, {
        default: w(() => [
          B("div", {
            onKeydown: $,
            class: Ze(["relative w-[450px] z-[99]", { "shake-animation": c.value }])
          }, [
            Sn(B("div", mH, [
              B("div", {
                ref_key: "resultContainer",
                ref: a,
                class: "p-4 line-height-none block overflow-y-auto",
                style: { "max-height": "270px" }
              }, [
                B("div", {
                  class: "text-sm text-foreground line-height-snug ProseMirror",
                  style: {
                    padding: 0,
                    minHeight: "auto"
                  },
                  innerHTML: p(f)
                }, null, 8, gH)
              ], 512)
            ], 512), [
              [Jn, (p(h) === "generating" || p(h) === "completed") && p(f)]
            ]),
            B("form", {
              onSubmit: C,
              class: "relative w-full items-center flex bg-background mt-3 rounded-md shadow-sm"
            }, [
              p(h) === "generating" ? (k(), U("div", vH, q(p(l)("editor.AI.generating")), 1)) : (k(), _(p(Rr), {
                key: 1,
                modelValue: o.value,
                "onUpdate:modelValue": Y[0] || (Y[0] = (J) => o.value = J),
                ref_key: "inputRef",
                ref: i,
                placeholder: p(l)("editor.AI.placeholder"),
                class: "pl-10 pr-20 h-12 outline-none ring-0 focus-visible:ring-0"
              }, null, 8, ["modelValue", "placeholder"])),
              B("span", yH, [
                E(p(xe), {
                  name: "Sparkles",
                  class: "w-5 h-5"
                })
              ]),
              p(h) === "generating" ? (k(), _(p(Pt), {
                key: 2,
                variant: "secondary",
                class: "absolute end-0 inset-y-0 flex items-center justify-center px-2 h-[32px] m-2",
                onClick: A
              }, {
                default: w(() => [
                  he(q(p(l)("editor.AI.stop")), 1)
                ]),
                _: 1
              })) : (k(), _(p(Pt), {
                key: 3,
                disabled: !o.value,
                onClick: C,
                class: "absolute end-0 inset-y-0 flex items-center justify-center px-2 w-[32px] h-[32px] m-2 rounded-full"
              }, {
                default: w(() => [
                  E(p(xe), {
                    name: "ArrowUp",
                    class: "w-5 h-5 font-bold"
                  })
                ]),
                _: 1
              }, 8, ["disabled"]))
            ], 32),
            Sn(B("div", bH, [
              E(fH, {
                ref_key: "menuRef",
                ref: u,
                items: M.value,
                onItemClick: N
              }, null, 8, ["items"])
            ], 512), [
              [Jn, p(h) === "init" && M.value.length && !o.value]
            ]),
            p(h) === "completed" && o.value === "" ? (k(), _(oH, {
              key: 0,
              onClose: A,
              onGenerate: I,
              editor: L.editor,
              completion: p(f)
            }, null, 8, ["editor", "completion"])) : ae("", !0)
          ], 34)
        ]),
        _: 1
      }, 8, ["editor", "tippy-options"]), [
        [Jn, S.value]
      ])
    ], 4)), [
      [Jn, S.value]
    ]);
  }
}), xH = /* @__PURE__ */ Yg(wH, [["__scopeId", "data-v-1f0dd7e2"]]), kH = /* @__PURE__ */ T({
  __name: "Menubar",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(OR), j(p(i), {
      class: p(fe)("flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm", n.class)
    }), {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), CH = /* @__PURE__ */ T({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(NR), j(p(i), {
      class: p(fe)(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        s.inset && "pl-8",
        n.class
      )
    }), {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), SH = /* @__PURE__ */ T({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 8 },
    align: { default: "start" },
    alignOffset: { default: -4 },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(PR), null, {
      default: w(() => [
        E(p(LR), j(p(o), {
          class: p(fe)(
            "z-50 min-w-48 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            e.class
          )
        }), {
          default: w(() => [
            D(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), AH = /* @__PURE__ */ T({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(DR), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), EH = { class: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center" }, _H = /* @__PURE__ */ T({
  __name: "MenubarCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:checked"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p($R), j(p(i), {
      class: p(fe)(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pr-8 pl-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: w(() => [
        B("span", EH, [
          E(p(zR), null, {
            default: w(() => [
              E(p(Vu), { class: "w-4 h-4" })
            ]),
            _: 1
          })
        ]),
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), MH = /* @__PURE__ */ T({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(BR), j({
      class: p(fe)("-mx-1 my-1 h-px bg-muted", e.class)
    }, p(o)), null, 16, ["class"]));
  }
}), TH = /* @__PURE__ */ T({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(RR), j(p(o), {
      class: p(fe)(
        "flex cursor-default select-none items-center rounded-sm px-3 py-1 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.class
      )
    }), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), By = /* @__PURE__ */ T({
  __name: "MenubarShortcut",
  props: {
    class: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), U("span", {
      class: Ze(p(fe)("ml-auto text-xs tracking-widest text-muted-foreground", e.class))
    }, [
      D(n.$slots, "default")
    ], 2));
  }
});
function Fh(t) {
  const { from: e, to: n, empty: o } = t.state.selection;
  return o ? "" : t.state.doc.textBetween(e, n, "");
}
const mc = "echo-editor-draft", OH = /* @__PURE__ */ T({
  __name: "Menubars",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const { t: e } = et(), n = t, o = pn(), r = P(() => n.editor.extensionManager.extensions.map((v) => v.name)), i = (v) => v ? v.every((y) => r.value.includes(y)) : !0, s = P(() => f.value.map((v) => ({
      ...v,
      children: v.children.filter((y) => i(y.requiredExtensions))
    }))), a = () => {
      const v = n.editor.getHTML();
      v && !n.editor.isEmpty && localStorage.setItem(mc, v);
    }, l = () => {
      const v = localStorage.getItem(mc);
      v && n.editor.commands.setContent(v, !0);
    }, c = () => {
      n.editor.chain().clearContent(!0).focus().run();
    }, d = () => !!localStorage.getItem(mc), u = () => {
      localStorage.removeItem(mc);
    }, f = O([
      {
        title: "editor.menubar.file",
        children: [
          {
            title: "editor.menubar.menu.newDoc",
            icon: "File",
            disabled: () => !n.editor.isEditable,
            action: () => {
              a(), c();
            }
          },
          {
            title: "editor.menubar.menu.restoreLastDraft",
            icon: "Refresh",
            disabled: () => !d() || !n.editor.isEditable,
            action: () => {
              l(), u();
            }
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.preview",
            icon: "Eye",
            action: () => {
              n.editor.commands.togglePreview();
            },
            requiredExtensions: ["preview"]
          },
          {
            separator: !0
          },
          {
            title: "editor.importWord.tooltip",
            icon: "Word",
            action: () => {
              n.editor.commands.toggleImportWord();
            },
            requiredExtensions: ["importWord"]
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.print",
            icon: "Printer",
            shortcut: ["mod", "P"],
            requiredExtensions: ["printer"],
            action: () => {
              o.state.printer = !0;
            }
          }
        ]
      },
      {
        title: "editor.menubar.edit",
        children: [
          {
            title: "editor.undo.tooltip",
            icon: "Undo2",
            shortcut: ["mod", "Z"],
            disabled: () => !n.editor.can().undo() || !n.editor.isEditable,
            action: () => {
              n.editor.commands.undo();
            },
            requiredExtensions: ["history"]
          },
          {
            title: "editor.redo.tooltip",
            icon: "Redo2",
            shortcut: ["shift", "mod", "Z"],
            disabled: () => !n.editor.can().redo() || !n.editor.isEditable,
            action: () => {
              n.editor.commands.redo();
            },
            requiredExtensions: ["history"]
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.cut",
            icon: "Cut",
            shortcut: ["mod", "X"],
            disabled: () => !n.editor.isEditable,
            action: async () => {
              const v = Fh(n.editor);
              v && (await navigator.clipboard.writeText(v), n.editor.commands.deleteSelection());
            }
          },
          {
            title: "editor.menubar.menu.copy",
            icon: "Copy",
            shortcut: ["mod", "C"],
            action: async () => {
              Fh(n.editor) && document.execCommand("copy");
            }
          },
          {
            title: "editor.menubar.menu.paste",
            icon: "Paste",
            shortcut: ["mod", "V"],
            disabled: () => !n.editor.isEditable,
            action: async () => {
              try {
                const v = await navigator.clipboard.read();
                let y = "", x = "";
                for (const C of v)
                  C.types.includes("text/html") && (y = await (await C.getType("text/html")).text()), C.types.includes("text/plain") && (x = await (await C.getType("text/plain")).text());
                y ? n.editor.chain().insertContent(y).focus().run() : x && n.editor.chain().insertContent(x).focus().run();
              } catch (v) {
                console.error("读取剪贴板内容时出错: ", v);
              }
            }
          },
          {
            title: "editor.menubar.menu.pasteAsText",
            icon: "Paste",
            disabled: () => !n.editor.isEditable,
            action: async () => {
              const v = await navigator.clipboard.readText();
              v && n.editor.chain().insertContent(v).focus().run();
            }
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.selectAll",
            disabled: () => !n.editor.isEditable,
            icon: "TextSelect",
            action: () => {
              var v;
              (v = n.editor) == null || v.chain().focus().selectAll().run();
            }
          },
          {
            separator: !0
          },
          {
            title: "editor.findAndReplace.tooltip",
            icon: "DocSearch",
            action: () => {
              o.toggleFindAndReplace();
            },
            requiredExtensions: ["findAndReplace"]
          }
        ]
      },
      {
        title: "editor.menubar.view",
        children: [
          {
            title: "editor.fullscreen.tooltip.fullscreen",
            icon: "Maximize",
            action: () => {
              o.toggleFullscreen();
            },
            requiredExtensions: ["fullscreen"]
          },
          {
            title: "editor.menubar.menu.preview",
            action: () => {
              n.editor.commands.togglePreview();
            },
            icon: "Eye",
            requiredExtensions: ["preview"]
          },
          {
            separator: !0
          },
          {
            title: "editor.menubar.menu.spellCheck",
            icon: "SpellCheck",
            checked: () => o.state.spellCheck,
            action: () => {
              o.toggleSpellCheck();
            }
          }
        ]
      },
      {
        title: "editor.menubar.insert",
        children: [
          {
            title: "editor.image.tooltip",
            icon: "ImageUp",
            disabled: () => !n.editor.isEditable || !n.editor.can().setImage({}),
            action: () => {
              n.editor.commands.setImageUpload();
            },
            requiredExtensions: ["image", "imageUpload"]
          },
          {
            title: "editor.video.tooltip",
            icon: "Video",
            disabled: () => !n.editor.isEditable || !n.editor.can().setVideo({}),
            action: () => {
              n.editor.commands.setVideoUpload();
            },
            requiredExtensions: ["video", "videoUpload"]
          },
          {
            title: "editor.link.tooltip",
            icon: "Link",
            disabled: () => !n.editor.isEditable || !n.editor.can().setLink({ href: "" }),
            action: () => {
              n.editor.chain().extendMarkRange("link").insertContent({
                type: "text",
                text: "link",
                marks: [
                  {
                    type: "link",
                    attrs: {
                      href: "",
                      target: "_blank"
                    }
                  }
                ]
              }).setLink({ href: "" }).focus().run();
            },
            requiredExtensions: ["link"]
          }
        ]
      },
      {
        title: "editor.menubar.format",
        children: [
          {
            title: "editor.bold.tooltip",
            icon: "Bold",
            shortcut: ["Mod", "B"],
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleBold(),
            action: () => {
              n.editor.commands.toggleBold();
            },
            requiredExtensions: ["bold"]
          },
          {
            title: "editor.italic.tooltip",
            icon: "Italic",
            shortcut: ["Mod", "I"],
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleItalic(),
            action: () => {
              n.editor.commands.toggleItalic();
            },
            requiredExtensions: ["italic"]
          },
          {
            title: "editor.underline.tooltip",
            icon: "Underline",
            shortcut: ["Mod", "U"],
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleUnderline(),
            action: () => {
              n.editor.commands.toggleUnderline();
            },
            requiredExtensions: ["underline"]
          },
          {
            title: "editor.strike.tooltip",
            icon: "Strikethrough",
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleStrike(),
            action: () => {
              n.editor.commands.toggleStrike();
            },
            requiredExtensions: ["strike"]
          },
          {
            title: "editor.superscript.tooltip",
            icon: "Superscript",
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleSuperscript(),
            action: () => {
              n.editor.commands.toggleSuperscript();
            },
            requiredExtensions: ["superscript"]
          },
          {
            title: "editor.subscript.tooltip",
            icon: "Subscript",
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleSubscript(),
            action: () => {
              n.editor.commands.toggleSubscript();
            },
            requiredExtensions: ["subscript"]
          },
          {
            title: "editor.code.tooltip",
            icon: "Code",
            disabled: () => !n.editor.isEditable || !n.editor.can().toggleCode(),
            action: () => {
              n.editor.commands.toggleCode();
            },
            requiredExtensions: ["code"]
          }
        ]
      }
    ]), h = (v) => {
      v && v();
    }, m = (v) => v === void 0 ? !1 : typeof v == "function" ? v() : v, g = (v) => v === void 0 ? !1 : typeof v == "function" ? v() : v;
    return (v, y) => (k(), _(p(kH), { class: "rounded-b-none shadow-none border-t-transparent border-l-transparent border-r-transparent rounded-t-[0.5rem]" }, {
      default: w(() => [
        (k(!0), U(ve, null, Fe(p(s), (x, C) => (k(), _(p(AH), { key: C }, {
          default: w(() => [
            E(p(TH), null, {
              default: w(() => [
                he(q(p(e)(x.title)), 1)
              ]),
              _: 2
            }, 1024),
            E(p(SH), null, {
              default: w(() => [
                (k(!0), U(ve, null, Fe(x.children, (b, S) => (k(), U(ve, { key: S }, [
                  b != null && b.separator ? (k(), _(p(MH), { key: 0 })) : b.checked && i(b.requiredExtensions) ? (k(), _(p(_H), {
                    key: 1,
                    onClick: (A) => h(b.action),
                    checked: g(b.checked),
                    disabled: m(b.disabled),
                    class: "flex gap-3"
                  }, {
                    default: w(() => [
                      b.icon ? (k(), _(p(xe), {
                        key: 0,
                        name: b.icon
                      }, null, 8, ["name"])) : ae("", !0),
                      he(" " + q(p(e)(b.title)) + " ", 1),
                      b.shortcut ? (k(), _(p(By), { key: 1 }, {
                        default: w(() => [
                          he(q(p(To)(b.shortcut)), 1)
                        ]),
                        _: 2
                      }, 1024)) : ae("", !0)
                    ]),
                    _: 2
                  }, 1032, ["onClick", "checked", "disabled"])) : i(b.requiredExtensions) ? (k(), _(p(CH), {
                    key: 2,
                    onClick: (A) => h(b.action),
                    disabled: m(b.disabled),
                    class: "flex gap-3"
                  }, {
                    default: w(() => [
                      b.icon ? (k(), _(p(xe), {
                        key: 0,
                        name: b.icon
                      }, null, 8, ["name"])) : ae("", !0),
                      he(" " + q(p(e)(b.title)) + " ", 1),
                      b.shortcut ? (k(), _(p(By), { key: 1 }, {
                        default: w(() => [
                          he(q(p(To)(b.shortcut)), 1)
                        ]),
                        _: 2
                      }, 1024)) : ae("", !0)
                    ]),
                    _: 2
                  }, 1032, ["onClick", "disabled"])) : ae("", !0)
                ], 64))), 128))
              ]),
              _: 2
            }, 1024)
          ]),
          _: 2
        }, 1024))), 128))
      ]),
      _: 1
    }));
  }
}), IH = { class: "sticky top-0 h-auto bg-background z-10 overflow-visible rounded-t-[0.5rem]" }, DH = { class: "flex flex-nowrap overflow-x-auto sm:flex-wrap gap-y-1 gap-x-1 items-center py-0.5" }, RH = { class: "flex items-center" }, PH = /* @__PURE__ */ T({
  __name: "Toolbar",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const { t: e } = et(), n = t, o = P(() => {
      const i = [...n.editor.extensionManager.extensions].sort((a, l) => {
        const c = a.options.sort ?? -1, d = l.options.sort ?? -1;
        return c - d;
      });
      let s = [];
      for (const a of i) {
        const { button: l, divider: c = !1, spacer: d = !1, toolbar: u = !0 } = a.options;
        if (!l || !I9(l) || !u)
          continue;
        const f = l({
          editor: n.editor,
          extension: a,
          t: p(e)
        });
        if (Array.isArray(f)) {
          const h = f.map((m, g) => ({
            button: m,
            divider: g === f.length - 1 ? c : !1,
            spacer: g === 0 ? d : !1
          }));
          s = [...s, ...h];
          continue;
        }
        s.push({ button: f, divider: c, spacer: d });
      }
      return s;
    });
    return (r, i) => (k(), U("div", IH, [
      B("div", DH, [
        (k(!0), U(ve, null, Fe(o.value, (s, a) => {
          var l;
          return k(), U(ve, { key: a }, [
            B("div", RH, [
              s.spacer ? (k(), _(p(Bo), {
                key: 0,
                orientation: "vertical",
                class: "h-[16px] mx-[10px]"
              })) : ae("", !0)
            ]),
            (k(), _(_n(s.button.component), j({ ref_for: !0 }, s.button.componentProps, {
              editor: r.editor,
              disabled: r.disabled || ((l = s.button.componentProps) == null ? void 0 : l.disabled)
            }), Ib({ _: 2 }, [
              Fe(s.button.componentSlots, (c, d, u) => ({
                name: `${d}`,
                fn: w((f) => [
                  (k(), _(_n(c), j({ ref_for: !0 }, f == null ? void 0 : f.props), null, 16))
                ])
              }))
            ]), 1040, ["editor", "disabled"])),
            s.divider ? (k(), _(p(Bo), {
              key: 0,
              orientation: "vertical",
              class: "h-auto mx-2"
            })) : ae("", !0)
          ], 64);
        }), 128))
      ])
    ]));
  }
}), LH = /* @__PURE__ */ T({
  __name: "Dialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t, { emit: e }) {
    const r = De(t, e);
    return (i, s) => (k(), _(p(gD), Oe(Le(p(r))), {
      default: w(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), NH = /* @__PURE__ */ T({
  __name: "DialogHeader",
  props: {
    class: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), U("div", {
      class: Ze(p(fe)("flex flex-col gap-y-1.5 text-center sm:text-left", e.class))
    }, [
      D(n.$slots, "default")
    ], 2));
  }
}), BH = /* @__PURE__ */ T({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(jD), j(p(o), {
      class: p(fe)(
        "text-lg font-semibold leading-none tracking-tight",
        e.class
      )
    }), {
      default: w(() => [
        D(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $H = /* @__PURE__ */ B("span", { class: "sr-only" }, "Close", -1), zH = /* @__PURE__ */ T({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(vD), null, {
      default: w(() => [
        E(p(HD), { class: "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0" }),
        E(p(zD), j(p(i), {
          class: p(fe)(
            "fixed left-1/2 top-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: w(() => [
            D(s.$slots, "default"),
            E(p(VD), { class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground" }, {
              default: w(() => [
                E(p(Q4), { class: "w-4 h-4" }),
                $H
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), FH = /* @__PURE__ */ T({
  __name: "DialogFooter",
  props: {
    class: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), U("div", {
      class: Ze(
        p(fe)(
          "flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2",
          e.class
        )
      )
    }, [
      D(n.$slots, "default")
    ], 2));
  }
}), HH = /* @__PURE__ */ T({
  __name: "ResizablePanelGroup",
  props: {
    id: {},
    autoSaveId: {},
    direction: {},
    keyboardResizeBy: {},
    storage: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["layout"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(cL), j(p(i), {
      class: p(fe)("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", n.class)
    }), {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), VH = {
  key: 0,
  class: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border"
}, jH = /* @__PURE__ */ T({
  __name: "ResizableHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    withHandle: { type: Boolean }
  },
  emits: ["dragging"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(uL), j(p(i), {
      class: p(fe)("relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 [&[data-orientation=vertical]]:h-px [&[data-orientation=vertical]]:w-full [&[data-orientation=vertical]]:after:left-0 [&[data-orientation=vertical]]:after:h-1 [&[data-orientation=vertical]]:after:w-full [&[data-orientation=vertical]]:after:-translate-y-1/2 [&[data-orientation=vertical]]:after:translate-x-0 [&[data-orientation=vertical]>div]:rotate-90", n.class)
    }), {
      default: w(() => [
        n.withHandle ? (k(), U("div", VH, [
          E(p(DN), { class: "h-2.5 w-2.5" })
        ])) : ae("", !0)
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), UH = /* @__PURE__ */ T({
  __name: "ToggleGroup",
  props: {
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {},
    class: {},
    variant: {},
    size: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const n = t, o = e;
    Ma("toggleGroup", {
      variant: n.variant,
      size: n.size
    });
    const r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(NL), j(p(i), {
      class: p(fe)("flex items-center justify-center gap-1", n.class)
    }), {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ap = /* @__PURE__ */ T({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: {},
    size: {}
  },
  setup(t) {
    const e = t, n = im("toggleGroup"), o = P(() => {
      const { class: i, variant: s, size: a, ...l } = e;
      return l;
    }), r = _t(o);
    return (i, s) => {
      var a, l;
      return k(), _(p(BL), j(p(r), {
        class: p(fe)(p(w3)({
          variant: ((a = p(n)) == null ? void 0 : a.variant) || i.variant,
          size: ((l = p(n)) == null ? void 0 : l.size) || i.size
        }), e.class)
      }), {
        default: w(() => [
          D(i.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
}), WH = /* @__PURE__ */ T({
  __name: "ScrollBar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(rP), j(n.value, {
      class: p(fe)(
        "flex touch-none select-none transition-colors",
        o.orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-px",
        o.orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-px",
        e.class
      )
    }), {
      default: w(() => [
        E(p(iP), { class: "relative flex-1 rounded-full bg-border" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), c6 = /* @__PURE__ */ T({
  __name: "ScrollArea",
  props: {
    type: {},
    dir: {},
    scrollHideDelay: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(GR), j(n.value, {
      class: p(fe)("relative overflow-hidden", e.class)
    }), {
      default: w(() => [
        E(p(JR), { class: "h-full w-full rounded-[inherit]" }, {
          default: w(() => [
            D(o.$slots, "default")
          ]),
          _: 3
        }),
        E(WH),
        E(p(aP))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), KH = { class: "flex justify-center" }, qH = { class: "hidden items-center gap-1.5 rounded-md border p-[2px] shadow-sm md:flex" }, GH = { class: "relative overflow-y-auto after:absolute after:inset-0 after:right-3 after:z-0 after:rounded-lg h-[--container-height] px-4" }, JH = ["innerHTML"], YH = /* @__PURE__ */ T({
  __name: "Preview",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, { t: n } = et(), o = pn(), r = O();
    function i(l) {
      o.state.showPreview = l;
    }
    function s() {
      o.state.showPreview = !1;
    }
    const a = P(() => e.editor.getHTML());
    return (l, c) => {
      var d;
      return k(), _(p(LH), {
        open: (d = p(o)) == null ? void 0 : d.state.showPreview,
        "onUpdate:open": i
      }, {
        default: w(() => [
          E(p(zH), { class: "sm:max-w-[425px] md:max-w-[825px] lg:max-w-[1200px] grid-rows-[auto_minmax(0,1fr)_auto] p-0 max-h-[90dvh]" }, {
            default: w(() => [
              E(p(NH), { class: "p-6 pb-0" }, {
                default: w(() => [
                  E(p(BH), null, {
                    default: w(() => [
                      he(q(p(n)("editor.preview.tooltip")), 1)
                    ]),
                    _: 1
                  }),
                  B("div", KH, [
                    B("div", qH, [
                      E(p(UH), {
                        type: "single",
                        "default-value": "100",
                        "onUpdate:modelValue": c[0] || (c[0] = (u) => {
                          var f;
                          (f = p(r)) == null || f.resize(parseInt(u));
                        })
                      }, {
                        default: w(() => [
                          E(p(ap), {
                            value: "100",
                            class: "h-[32px] w-[32px] rounded-sm p-0"
                          }, {
                            default: w(() => [
                              E(p(xe), {
                                name: "Monitor",
                                class: "w-5 h-5"
                              })
                            ]),
                            _: 1
                          }),
                          E(p(ap), {
                            value: "60",
                            class: "h-[32px] w-[32px] rounded-sm p-0"
                          }, {
                            default: w(() => [
                              E(p(xe), {
                                name: "Tablet",
                                class: "w-5 h-5"
                              })
                            ]),
                            _: 1
                          }),
                          E(p(ap), {
                            value: "30",
                            class: "h-[32px] w-[32px] rounded-sm p-0"
                          }, {
                            default: w(() => [
                              E(p(xe), {
                                name: "Phone",
                                class: "w-5 h-5"
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ])
                  ])
                ]),
                _: 1
              }),
              B("div", GH, [
                E(p(HH), {
                  id: "preview-resizable",
                  direction: "horizontal",
                  class: "relative z-10 overflow-auto"
                }, {
                  default: w(() => [
                    E(p(zv), {
                      ref_key: "resizableRef",
                      ref: r,
                      class: "relative rounded-lg border bg-background transition-all",
                      "default-size": 100,
                      "min-size": 30,
                      id: "preview-resize-panel-1"
                    }, {
                      default: w(() => [
                        E(p(c6), { class: "h-full w-full rounded-md border p-3 border-none" }, {
                          default: w(() => [
                            B("div", {
                              innerHTML: p(a),
                              class: "ProseMirror"
                            }, null, 8, JH)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 512),
                    E(p(jH), {
                      id: "block-resizable-handle",
                      class: "relative hidden w-3 bg-transparent p-0 after:absolute after:right-0 after:top-1/2 after:h-8 after:w-[6px] after:-translate-y-1/2 after:translate-x-[-1px] after:rounded-full after:bg-border after:transition-all after:hover:h-10 sm:block"
                    }),
                    E(p(zv), {
                      id: "block-resizable-panel-2",
                      "default-size": 0,
                      "min-size": 0
                    })
                  ]),
                  _: 1
                })
              ]),
              E(p(FH), { class: "p-2 pt-0" }, {
                default: w(() => [
                  E(p(Pt), { onClick: s }, {
                    default: w(() => [
                      he(q(p(n)("editor.close")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["open"]);
    };
  }
}), XH = '.ProseMirror p{margin-bottom:.375rem;line-height:1.625}.ProseMirror p:first-child{margin-top:0}.ProseMirror p:last-child{margin-bottom:0}.ProseMirror p:empty:after{content:" "}.ProseMirror>p{margin-bottom:.375rem}.ProseMirror>p:first-child{margin-top:0}.ProseMirror>p:last-child{margin-bottom:0}.ProseMirror h1{font-size:1.875rem;line-height:2.25rem}.ProseMirror h2{font-size:1.5rem;line-height:2rem}.ProseMirror h3{font-size:1.25rem;line-height:1.75rem}.ProseMirror h4{font-size:1.125rem;line-height:1.75rem}.ProseMirror h5{font-size:1rem;line-height:1.5rem}.ProseMirror h6{font-size:.875rem;line-height:1.25rem}.ProseMirror h1,.ProseMirror h2,.ProseMirror h3,.ProseMirror h4,.ProseMirror h5,.ProseMirror h6{font-weight:700}.ProseMirror h1:first-child,.ProseMirror h2:first-child,.ProseMirror h3:first-child,.ProseMirror h4:first-child,.ProseMirror h5:first-child,.ProseMirror h6:first-child{margin-top:0}.ProseMirror h1:last-child,.ProseMirror h2:last-child,.ProseMirror h3:last-child,.ProseMirror h4:last-child,.ProseMirror h5:last-child,.ProseMirror h6:last-child{margin-bottom:0}.ProseMirror h1,.ProseMirror h2,.ProseMirror h3{margin-top:3rem}.ProseMirror h4,.ProseMirror h5,.ProseMirror h6{margin-top:2rem}.ProseMirror a.link{font-weight:800;--tw-text-opacity: 1;color:rgb(59 130 246 / var(--tw-text-opacity))}.ProseMirror a.link:is(.dark *){--tw-text-opacity: 1;color:rgb(96 165 250 / var(--tw-text-opacity))}.ProseMirror mark{border-radius:calc(var(--radius) - 4px);--tw-bg-opacity: 1;background-color:rgb(239 68 68 / var(--tw-bg-opacity));-webkit-box-decoration-break:clone;box-decoration-break:clone;padding-top:.25rem;padding-bottom:.25rem;padding-left:0;padding-right:0;color:inherit}.ProseMirror mark:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(248 113 113 / var(--tw-bg-opacity))}.ProseMirror img{display:block;height:auto;max-width:100%}.ProseMirror *[data-indent="1"]{text-indent:2em!important}.ProseMirror *[data-indent="2"]{text-indent:4em!important}.ProseMirror *[data-indent="3"]{text-indent:6em!important}.ProseMirror *[data-indent="4"]{text-indent:8em!important}.ProseMirror *[data-indent="5"]{text-indent:10em!important}.ProseMirror *[data-indent="6"]{text-indent:12em!important}.ProseMirror *[data-indent="7"]{text-indent:14em!important}.ProseMirror iframe{margin-top:.5rem;height:400px;width:100%;border-radius:calc(var(--radius) - 4px);border-width:1px;border-color:hsl(var(--border))}.ProseMirror [data-type=horizontalRule]{margin-top:2rem;margin-bottom:2rem;padding-top:1rem;padding-bottom:1rem}.ProseMirror [data-type=horizontalRule] hr{border-width:0px;border-top-width:1px;border-color:#0003;background-color:#000c}.ProseMirror [data-type=horizontalRule] hr:is(.dark *){border-color:#fff3;background-color:#fffc}.ProseMirror .blockquote{border-radius:var(--radius);border-top-left-radius:0;border-bottom-left-radius:0;border-left-width:4px;--tw-border-opacity: 1;border-left-color:rgb(64 64 64 / var(--tw-border-opacity));--tw-bg-opacity: .8;padding:.5rem 1rem;--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity))}.ProseMirror .blockquote:is(.dark *){--tw-border-opacity: 1;border-left-color:rgb(212 212 212 / var(--tw-border-opacity));--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.ProseMirror [data-type=columns]{margin-top:3.5rem;margin-bottom:3rem;display:grid;gap:1rem}.ProseMirror [data-type=columns].layout-sidebar-left{grid-template-columns:40fr 60fr}.ProseMirror [data-type=columns].layout-sidebar-right{grid-template-columns:60fr 40fr}.ProseMirror [data-type=columns].layout-two-column{grid-template-columns:1fr 1fr}.ProseMirror [data-type=column]{overflow:auto}.ProseMirror code{border-radius:calc(var(--radius) - 4px);--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity));font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity));caret-color:#fff;--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.ProseMirror code::-moz-selection{background-color:#ffffff4d}.ProseMirror code::selection{background-color:#ffffff4d}.ProseMirror pre{margin-top:3rem;margin-bottom:3rem;border-radius:.25rem;border-width:1px;--tw-border-opacity: 1;border-color:rgb(0 0 0 / var(--tw-border-opacity));--tw-bg-opacity: 1;background-color:rgb(64 64 64 / var(--tw-bg-opacity));padding:1rem;--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity));caret-color:#fff}.ProseMirror pre:is(.dark *){--tw-border-opacity: 1;border-color:rgb(38 38 38 / var(--tw-border-opacity));--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity))}.ProseMirror pre *::-moz-selection{background-color:#fff3}.ProseMirror pre *::selection{background-color:#fff3}.ProseMirror pre code{background-color:inherit;padding:0;color:inherit;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.ProseMirror pre .hljs-comment,.ProseMirror pre .hljs-quote{--tw-text-opacity: 1;color:rgb(163 163 163 / var(--tw-text-opacity))}.ProseMirror pre .hljs-variable,.ProseMirror pre .hljs-template-variable,.ProseMirror pre .hljs-attribute,.ProseMirror pre .hljs-tag,.ProseMirror pre .hljs-name,.ProseMirror pre .hljs-regexp,.ProseMirror pre .hljs-link,.ProseMirror pre .hljs-selector-id,.ProseMirror pre .hljs-selector-class{--tw-text-opacity: 1;color:rgb(252 165 165 / var(--tw-text-opacity))}.ProseMirror pre .hljs-number,.ProseMirror pre .hljs-meta,.ProseMirror pre .hljs-built_in,.ProseMirror pre .hljs-builtin-name,.ProseMirror pre .hljs-literal,.ProseMirror pre .hljs-type,.ProseMirror pre .hljs-params{--tw-text-opacity: 1;color:rgb(253 186 116 / var(--tw-text-opacity))}.ProseMirror pre .hljs-string,.ProseMirror pre .hljs-symbol,.ProseMirror pre .hljs-bullet{--tw-text-opacity: 1;color:rgb(190 242 100 / var(--tw-text-opacity))}.ProseMirror pre .hljs-title,.ProseMirror pre .hljs-section{--tw-text-opacity: 1;color:rgb(253 224 71 / var(--tw-text-opacity))}.ProseMirror pre .hljs-keyword,.ProseMirror pre .hljs-selector-tag{--tw-text-opacity: 1;color:rgb(94 234 212 / var(--tw-text-opacity))}.ProseMirror pre .hljs-emphasis{font-style:italic}.ProseMirror pre .hljs-strong{font-weight:700}.ProseMirror ol{list-style-type:decimal}.ProseMirror ul{list-style-type:disc}.ProseMirror ul,.ProseMirror ol{margin-top:1.5rem;margin-bottom:1.5rem;padding-top:0;padding-bottom:0;padding-left:2rem;padding-right:2rem}.ProseMirror ul:first-child,.ProseMirror ol:first-child{margin-top:0}.ProseMirror ul:last-child,.ProseMirror ol:last-child{margin-bottom:0}.ProseMirror ul ul,.ProseMirror ul ol,.ProseMirror ul li,.ProseMirror ol ul,.ProseMirror ol ol,.ProseMirror ol li{margin-top:.25rem;margin-bottom:.25rem}.ProseMirror ul p,.ProseMirror ol p{margin-top:0;margin-bottom:.25rem}.ProseMirror>ul,.ProseMirror>ol{margin-top:2rem;margin-bottom:2rem}.ProseMirror>ul:first-child,.ProseMirror>ol:first-child{margin-top:0}.ProseMirror>ul:last-child,.ProseMirror>ol:last-child{margin-bottom:0}.ProseMirror ul[data-type=taskList]{list-style-type:none;padding:0}.ProseMirror ul[data-type=taskList] p{margin:0}.ProseMirror ul[data-type=taskList] li{display:flex}.ProseMirror ul[data-type=taskList] li>label{margin-top:.25rem;margin-right:.5rem;flex:1 1 auto;flex-shrink:0;flex-grow:0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ProseMirror ul[data-type=taskList] li>div{flex:1 1 auto}.ProseMirror ul[data-type=taskList] li[data-checked=true]{text-decoration-line:line-through}.ProseMirror table{box-sizing:border-box;display:block;table-layout:fixed;border-collapse:collapse;overflow-x:auto;overflow-y:hidden;border-color:#0000001a}.ProseMirror table:is(.dark *){border-color:#fff3}.ProseMirror table td,.ProseMirror table th{position:relative;box-sizing:border-box;min-width:1em;border-width:1px;border-style:solid;border-color:#0000001a;padding:.5rem;text-align:left;vertical-align:top}.ProseMirror table td:is(.dark *),.ProseMirror table th:is(.dark *){border-color:#fff3}.ProseMirror table td:first-of-type:not(a),.ProseMirror table th:first-of-type:not(a){margin-top:0}.ProseMirror table td p,.ProseMirror table th p{margin:0}.ProseMirror table td p+p,.ProseMirror table th p+p{margin-top:.75rem}.ProseMirror table th{text-align:left;font-weight:700}', ZH = '*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}:root{--background: 0 0% 100%;--foreground: 240 10% 3.9%;--muted: 240 4.8% 95.9%;--muted-foreground: 240 3.8% 46.1%;--popover: 0 0% 100%;--popover-foreground: 240 10% 3.9%;--card: 0 0% 100%;--card-foreground: 240 10% 3.9%;--border: 240 5.9% 90%;--input: 240 5.9% 90%;--primary: 240 5.9% 10%;--primary-foreground: 0 0% 98%;--secondary: 240 4.8% 95.9%;--secondary-foreground: 240 5.9% 10%;--accent: 240 4.8% 95.9%;--accent-foreground: 240 5.9% 10%;--destructive: 0 84.2% 60.2%;--destructive-foreground: 0 0% 98%;--ring: 240 10% 3.9%;--radius: .5rem}.dark{--background: 240 10% 3.9%;--foreground: 0 0% 98%;--muted: 240 3.7% 15.9%;--muted-foreground: 240 5% 64.9%;--popover: 240 10% 3.9%;--popover-foreground: 0 0% 98%;--card: 240 10% 3.9%;--card-foreground: 0 0% 98%;--border: 240 3.7% 15.9%;--input: 240 3.7% 15.9%;--primary: 0 0% 98%;--primary-foreground: 240 5.9% 10%;--secondary: 240 3.7% 15.9%;--secondary-foreground: 0 0% 98%;--accent: 240 3.7% 15.9%;--accent-foreground: 0 0% 98%;--destructive: 0 62.8% 30.6%;--destructive-foreground: 0 0% 98%;--ring: 240 4.9% 83.9%}*{border-color:hsl(var(--border))}body{background-color:hsl(var(--background));color:hsl(var(--foreground))}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.\\!container{width:100%!important;margin-right:auto!important;margin-left:auto!important;padding-right:2rem!important;padding-left:2rem!important}.container{width:100%;margin-right:auto;margin-left:auto;padding-right:2rem;padding-left:2rem}@media (min-width: 1400px){.\\!container{max-width:1400px!important}.container{max-width:1400px}}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.pointer-events-none{pointer-events:none}.pointer-events-auto{pointer-events:auto}.\\!fixed{position:fixed!important}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.inset-0{top:0;right:0;bottom:0;left:0}.inset-y-0{top:0;bottom:0}.bottom-0{bottom:0}.end-0{inset-inline-end:0px}.left-0{left:0}.left-1\\/2{left:50%}.left-2{left:.5rem}.left-\\[1px\\]{left:1px}.left-full{left:100%}.right-0{right:0}.right-1{right:.25rem}.right-2{right:.5rem}.right-4{right:1rem}.start-0{inset-inline-start:0px}.top-0{top:0}.top-1{top:.25rem}.top-1\\/2{top:50%}.top-2{top:.5rem}.top-4{top:1rem}.top-\\[-1px\\]{top:-1px}.z-10{z-index:10}.z-50{z-index:50}.z-\\[100\\]{z-index:100}.z-\\[10\\]{z-index:10}.z-\\[11\\]{z-index:11}.z-\\[99\\]{z-index:99}.col-\\[1\\/-1\\]{grid-column:1/-1}.m-0{margin:0}.m-2{margin:.5rem}.-mx-1{margin-left:-.25rem;margin-right:-.25rem}.mx-1{margin-left:.25rem;margin-right:.25rem}.mx-2{margin-left:.5rem;margin-right:.5rem}.mx-\\[10px\\]{margin-left:10px;margin-right:10px}.my-1{margin-top:.25rem;margin-bottom:.25rem}.my-3{margin-top:.75rem;margin-bottom:.75rem}.my-8{margin-top:2rem;margin-bottom:2rem}.mb-8{margin-bottom:2rem}.me-1{margin-inline-end:.25rem}.me-2{margin-inline-end:.5rem}.ml-1{margin-left:.25rem}.ml-auto{margin-left:auto}.mr-1{margin-right:.25rem}.mt-1{margin-top:.25rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:.75rem}.box-border{box-sizing:border-box}.block{display:block}.inline-block{display:inline-block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.table{display:table}.grid{display:grid}.hidden{display:none}.size-5{width:1.25rem;height:1.25rem}.h-0{height:0px}.h-10{height:2.5rem}.h-12{height:3rem}.h-2{height:.5rem}.h-2\\.5{height:.625rem}.h-3{height:.75rem}.h-3\\.5{height:.875rem}.h-4{height:1rem}.h-5{height:1.25rem}.h-6{height:1.5rem}.h-7{height:1.75rem}.h-8{height:2rem}.h-9{height:2.25rem}.h-96{height:24rem}.h-\\[--container-height\\]{height:var(--container-height)}.h-\\[--radix-select-trigger-height\\]{height:var(--radix-select-trigger-height)}.h-\\[16px\\]{height:16px}.h-\\[18px\\]{height:18px}.h-\\[26px\\]{height:26px}.h-\\[32px\\]{height:32px}.h-\\[3px\\]{height:3px}.h-\\[48px\\]{height:48px}.h-\\[72px\\]{height:72px}.h-auto{height:auto}.h-full{height:100%}.h-px{height:1px}.max-h-96{max-height:24rem}.max-h-\\[90dvh\\]{max-height:90dvh}.max-h-\\[min\\(80vh\\,24rem\\)\\]{max-height:min(80vh,24rem)}.max-h-screen{max-height:100vh}.w-0{width:0px}.w-2{width:.5rem}.w-2\\.5{width:.625rem}.w-20{width:5rem}.w-3{width:.75rem}.w-3\\.5{width:.875rem}.w-32{width:8rem}.w-36{width:9rem}.w-4{width:1rem}.w-48{width:12rem}.w-5{width:1.25rem}.w-6{width:1.5rem}.w-7{width:1.75rem}.w-72{width:18rem}.w-80{width:20rem}.w-9{width:2.25rem}.w-\\[160px\\]{width:160px}.w-\\[16px\\]{width:16px}.w-\\[18px\\]{width:18px}.w-\\[320px\\]{width:320px}.w-\\[32px\\]{width:32px}.w-\\[400px\\]{width:400px}.w-\\[450px\\]{width:450px}.w-\\[48px\\]{width:48px}.w-\\[72px\\]{width:72px}.w-auto{width:auto}.w-full{width:100%}.w-px{width:1px}.min-w-24{min-width:6rem}.min-w-32{min-width:8rem}.min-w-4{min-width:1rem}.min-w-48{min-width:12rem}.min-w-\\[--radix-select-trigger-width\\]{min-width:var(--radix-select-trigger-width)}.max-w-24{max-width:6rem}.max-w-32{max-width:8rem}.max-w-56{max-width:14rem}.max-w-60{max-width:15rem}.max-w-\\[calc\\(-68px_\\+_100vw\\)\\]{max-width:calc(-68px + 100vw)}.max-w-lg{max-width:32rem}.max-w-sm{max-width:24rem}.flex-1{flex:1 1 0%}.flex-shrink-0,.shrink-0{flex-shrink:0}.flex-grow{flex-grow:1}.-translate-x-1\\/2{--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.-translate-y-1\\/2{--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-default{cursor:default}.cursor-grab{cursor:grab}.cursor-pointer{cursor:pointer}.touch-none{touch-action:none}.select-none{-webkit-user-select:none;-moz-user-select:none;user-select:none}.resize{resize:both}.list-outside{list-style-position:outside}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.grid-rows-\\[auto_minmax\\(0\\,1fr\\)_auto\\]{grid-template-rows:auto minmax(0,1fr) auto}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-wrap{flex-wrap:wrap}.flex-nowrap{flex-wrap:nowrap}.place-items-center{place-items:center}.items-center{align-items:center}.justify-start{justify-content:flex-start}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-0{gap:0px}.gap-0\\.5{gap:.125rem}.gap-1{gap:.25rem}.gap-1\\.5{gap:.375rem}.gap-2{gap:.5rem}.gap-3{gap:.75rem}.gap-4{gap:1rem}.gap-x-1{-moz-column-gap:.25rem;column-gap:.25rem}.gap-y-1{row-gap:.25rem}.gap-y-1\\.5{row-gap:.375rem}.space-x-1>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.25rem * var(--tw-space-x-reverse));margin-left:calc(.25rem * calc(1 - var(--tw-space-x-reverse)))}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.self-end{align-self:flex-end}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-visible{overflow:visible}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.whitespace-nowrap{white-space:nowrap}.break-all{word-break:break-all}.rounded{border-radius:.25rem}.rounded-\\[0\\.5rem\\]{border-radius:.5rem}.rounded-\\[2px\\]{border-radius:2px}.rounded-\\[inherit\\]{border-radius:inherit}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:var(--radius)}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.rounded-b-none{border-bottom-right-radius:0;border-bottom-left-radius:0}.rounded-l-none{border-top-left-radius:0;border-bottom-left-radius:0}.rounded-t-\\[0\\.5rem\\]{border-top-left-radius:.5rem;border-top-right-radius:.5rem}.border{border-width:1px}.border-0{border-width:0px}.border-2{border-width:2px}.border-b{border-bottom-width:1px}.border-l{border-left-width:1px}.border-t{border-top-width:1px}.border-none{border-style:none}.border-accent-foreground{border-color:hsl(var(--accent-foreground))}.border-black{--tw-border-opacity: 1;border-color:rgb(0 0 0 / var(--tw-border-opacity))}.border-border{border-color:hsl(var(--border))}.border-destructive{border-color:hsl(var(--destructive))}.border-input{border-color:hsl(var(--input))}.border-neutral-200{--tw-border-opacity: 1;border-color:rgb(229 229 229 / var(--tw-border-opacity))}.border-primary{border-color:hsl(var(--primary))}.border-transparent{border-color:transparent}.border-l-transparent{border-left-color:transparent}.border-r-transparent{border-right-color:transparent}.border-t-transparent{border-top-color:transparent}.bg-accent{background-color:hsl(var(--accent))}.bg-background{background-color:hsl(var(--background))}.bg-black\\/80{background-color:#000c}.bg-border{background-color:hsl(var(--border))}.bg-destructive{background-color:hsl(var(--destructive))}.bg-foreground{background-color:hsl(var(--foreground))}.bg-gray-200{--tw-bg-opacity: 1;background-color:rgb(229 231 235 / var(--tw-bg-opacity))}.bg-muted{background-color:hsl(var(--muted))}.bg-popover{background-color:hsl(var(--popover))}.bg-primary{background-color:hsl(var(--primary))}.bg-secondary{background-color:hsl(var(--secondary))}.bg-transparent{background-color:transparent}.bg-white{--tw-bg-opacity: 1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-opacity-10{--tw-bg-opacity: .1}.fill-current{fill:currentColor}.p-0{padding:0}.p-0\\.5{padding:.125rem}.p-1{padding:.25rem}.p-1\\.5{padding:.375rem}.p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.p-6{padding:1.5rem}.p-\\[2px\\]{padding:2px}.p-px{padding:1px}.px-1{padding-left:.25rem;padding-right:.25rem}.px-1\\.5{padding-left:.375rem;padding-right:.375rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-2\\.5{padding-left:.625rem;padding-right:.625rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-8{padding-left:2rem;padding-right:2rem}.py-0{padding-top:0;padding-bottom:0}.py-0\\.5{padding-top:.125rem;padding-bottom:.125rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-1\\.5{padding-top:.375rem;padding-bottom:.375rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.pb-0{padding-bottom:0}.pl-10{padding-left:2.5rem}.pl-2{padding-left:.5rem}.pl-3{padding-left:.75rem}.pl-4{padding-left:1rem}.pl-8{padding-left:2rem}.pr-10{padding-right:2.5rem}.pr-2{padding-right:.5rem}.pr-20{padding-right:5rem}.pr-40{padding-right:10rem}.pr-6{padding-right:1.5rem}.pr-8{padding-right:2rem}.pt-0{padding-top:0}.text-left{text-align:left}.text-center{text-align:center}.text-start{text-align:start}.text-\\[0\\.65rem\\]{font-size:.65rem}.text-\\[10px\\]{font-size:10px}.text-\\[12px\\]{font-size:12px}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-normal{font-weight:400}.font-semibold{font-weight:600}.uppercase{text-transform:uppercase}.italic{font-style:italic}.leading-none{line-height:1}.tracking-tight{letter-spacing:-.025em}.tracking-wider{letter-spacing:.05em}.tracking-widest{letter-spacing:.1em}.text-accent-foreground{color:hsl(var(--accent-foreground))}.text-black{--tw-text-opacity: 1;color:rgb(0 0 0 / var(--tw-text-opacity))}.text-current{color:currentColor}.text-destructive-foreground{color:hsl(var(--destructive-foreground))}.text-foreground{color:hsl(var(--foreground))}.text-foreground\\/50{color:hsl(var(--foreground) / .5)}.text-gray-800{--tw-text-opacity: 1;color:rgb(31 41 55 / var(--tw-text-opacity))}.text-muted-foreground{color:hsl(var(--muted-foreground))}.text-neutral-400{--tw-text-opacity: 1;color:rgb(163 163 163 / var(--tw-text-opacity))}.text-neutral-500{--tw-text-opacity: 1;color:rgb(115 115 115 / var(--tw-text-opacity))}.text-neutral-600{--tw-text-opacity: 1;color:rgb(82 82 82 / var(--tw-text-opacity))}.text-neutral-800{--tw-text-opacity: 1;color:rgb(38 38 38 / var(--tw-text-opacity))}.text-popover-foreground{color:hsl(var(--popover-foreground))}.text-primary{color:hsl(var(--primary))}.text-primary-foreground{color:hsl(var(--primary-foreground))}.text-secondary-foreground{color:hsl(var(--secondary-foreground))}.text-zinc-500{--tw-text-opacity: 1;color:rgb(113 113 122 / var(--tw-text-opacity))}.text-zinc-600{--tw-text-opacity: 1;color:rgb(82 82 91 / var(--tw-text-opacity))}.underline{text-decoration-line:underline}.underline-offset-4{text-underline-offset:4px}.opacity-0{opacity:0}.opacity-50{opacity:.5}.opacity-60{opacity:.6}.opacity-70{opacity:.7}.opacity-90{opacity:.9}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-lg{--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-md{--tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);--tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-none{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-sm{--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.outline{outline-style:solid}.outline-1{outline-width:1px}.outline-border{outline-color:hsl(var(--border))}.outline-primary{outline-color:hsl(var(--primary))}.ring-0{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.ring-offset-background{--tw-ring-offset-color: hsl(var(--background))}.blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.duration-200{transition-duration:.2s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}@keyframes enter{0%{opacity:var(--tw-enter-opacity, 1);transform:translate3d(var(--tw-enter-translate-x, 0),var(--tw-enter-translate-y, 0),0) scale3d(var(--tw-enter-scale, 1),var(--tw-enter-scale, 1),var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity, 1);transform:translate3d(var(--tw-exit-translate-x, 0),var(--tw-exit-translate-y, 0),0) scale3d(var(--tw-exit-scale, 1),var(--tw-exit-scale, 1),var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))}}.animate-in{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.fade-in-0{--tw-enter-opacity: 0}.zoom-in-95{--tw-enter-scale: .95}.duration-200{animation-duration:.2s}.ease-out{animation-timing-function:cubic-bezier(0,0,.2,1)}.file\\:border-0::file-selector-button{border-width:0px}.file\\:bg-transparent::file-selector-button{background-color:transparent}.file\\:text-sm::file-selector-button{font-size:.875rem;line-height:1.25rem}.file\\:font-medium::file-selector-button{font-weight:500}.placeholder\\:text-muted-foreground::-moz-placeholder{color:hsl(var(--muted-foreground))}.placeholder\\:text-muted-foreground::placeholder{color:hsl(var(--muted-foreground))}.after\\:absolute:after{content:var(--tw-content);position:absolute}.after\\:inset-0:after{content:var(--tw-content);top:0;right:0;bottom:0;left:0}.after\\:inset-y-0:after{content:var(--tw-content);top:0;bottom:0}.after\\:left-0:after{content:var(--tw-content);left:0}.after\\:left-1\\/2:after{content:var(--tw-content);left:50%}.after\\:right-0:after{content:var(--tw-content);right:0}.after\\:right-3:after{content:var(--tw-content);right:.75rem}.after\\:top-1\\/2:after{content:var(--tw-content);top:50%}.after\\:top-\\[10px\\]:after{content:var(--tw-content);top:10px}.after\\:z-0:after{content:var(--tw-content);z-index:0}.after\\:block:after{content:var(--tw-content);display:block}.after\\:h-0:after{content:var(--tw-content);height:0px}.after\\:h-8:after{content:var(--tw-content);height:2rem}.after\\:w-1:after{content:var(--tw-content);width:.25rem}.after\\:w-6:after{content:var(--tw-content);width:1.5rem}.after\\:w-\\[6px\\]:after{content:var(--tw-content);width:6px}.after\\:-translate-x-1\\/2:after{content:var(--tw-content);--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.after\\:-translate-y-1\\/2:after{content:var(--tw-content);--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.after\\:translate-x-\\[-1px\\]:after{content:var(--tw-content);--tw-translate-x: -1px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.after\\:rotate-\\[45deg\\]:after{content:var(--tw-content);--tw-rotate: 45deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.after\\:rounded-full:after{content:var(--tw-content);border-radius:9999px}.after\\:rounded-lg:after{content:var(--tw-content);border-radius:var(--radius)}.after\\:border-b-2:after{content:var(--tw-content);border-bottom-width:2px}.after\\:border-b-red-500:after{content:var(--tw-content);--tw-border-opacity: 1;border-bottom-color:rgb(239 68 68 / var(--tw-border-opacity))}.after\\:bg-border:after{content:var(--tw-content);background-color:hsl(var(--border))}.after\\:transition-all:after{content:var(--tw-content);transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.first\\:mt-0:first-child{margin-top:0}.first\\:mt-0\\.5:first-child{margin-top:.125rem}.last\\:pb-2:last-child{padding-bottom:.5rem}.hover\\:cursor-pointer:hover{cursor:pointer}.hover\\:border-border:hover{border-color:hsl(var(--border))}.hover\\:bg-accent:hover{background-color:hsl(var(--accent))}.hover\\:bg-destructive\\/90:hover{background-color:hsl(var(--destructive) / .9)}.hover\\:bg-muted:hover{background-color:hsl(var(--muted))}.hover\\:bg-muted-foreground\\/20:hover{background-color:hsl(var(--muted-foreground) / .2)}.hover\\:bg-primary\\/90:hover{background-color:hsl(var(--primary) / .9)}.hover\\:bg-red-400:hover{--tw-bg-opacity: 1;background-color:rgb(248 113 113 / var(--tw-bg-opacity))}.hover\\:bg-secondary:hover{background-color:hsl(var(--secondary))}.hover\\:bg-secondary\\/80:hover{background-color:hsl(var(--secondary) / .8)}.hover\\:bg-opacity-20:hover{--tw-bg-opacity: .2}.hover\\:text-accent-foreground:hover{color:hsl(var(--accent-foreground))}.hover\\:text-foreground:hover{color:hsl(var(--foreground))}.hover\\:text-muted-foreground:hover{color:hsl(var(--muted-foreground))}.hover\\:text-neutral-800:hover{--tw-text-opacity: 1;color:rgb(38 38 38 / var(--tw-text-opacity))}.hover\\:underline:hover{text-decoration-line:underline}.hover\\:opacity-100:hover{opacity:1}.hover\\:shadow-sm:hover{--tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);--tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.after\\:hover\\:h-10:hover:after{content:var(--tw-content);height:2.5rem}.focus\\:bg-accent:focus{background-color:hsl(var(--accent))}.focus\\:bg-red-400:focus{--tw-bg-opacity: 1;background-color:rgb(248 113 113 / var(--tw-bg-opacity))}.focus\\:bg-opacity-30:focus{--tw-bg-opacity: .3}.focus\\:text-accent-foreground:focus{color:hsl(var(--accent-foreground))}.focus\\:text-red-500:focus{--tw-text-opacity: 1;color:rgb(239 68 68 / var(--tw-text-opacity))}.focus\\:opacity-100:focus{opacity:1}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-1:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-ring:focus{--tw-ring-color: hsl(var(--ring))}.focus\\:ring-offset-2:focus{--tw-ring-offset-width: 2px}.focus-visible\\:outline-none:focus-visible{outline:2px solid transparent;outline-offset:2px}.focus-visible\\:ring-0:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-1:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-2:focus-visible{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus-visible\\:ring-ring:focus-visible{--tw-ring-color: hsl(var(--ring))}.focus-visible\\:ring-offset-1:focus-visible{--tw-ring-offset-width: 1px}.focus-visible\\:ring-offset-2:focus-visible{--tw-ring-offset-width: 2px}.focus-visible\\:ring-offset-background:focus-visible{--tw-ring-offset-color: hsl(var(--background))}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-50:disabled{opacity:.5}.group:hover .group-hover\\:opacity-100{opacity:1}.group.destructive .group-\\[\\.destructive\\]\\:border-muted\\/40{border-color:hsl(var(--muted) / .4)}.group.destructive .group-\\[\\.destructive\\]\\:text-red-300{--tw-text-opacity: 1;color:rgb(252 165 165 / var(--tw-text-opacity))}.group.destructive .group-\\[\\.destructive\\]\\:hover\\:border-destructive\\/30:hover{border-color:hsl(var(--destructive) / .3)}.group.destructive .group-\\[\\.destructive\\]\\:hover\\:bg-destructive:hover{background-color:hsl(var(--destructive))}.group.destructive .group-\\[\\.destructive\\]\\:hover\\:text-destructive-foreground:hover{color:hsl(var(--destructive-foreground))}.group.destructive .group-\\[\\.destructive\\]\\:hover\\:text-red-50:hover{--tw-text-opacity: 1;color:rgb(254 242 242 / var(--tw-text-opacity))}.group.destructive .group-\\[\\.destructive\\]\\:focus\\:ring-destructive:focus{--tw-ring-color: hsl(var(--destructive))}.group.destructive .group-\\[\\.destructive\\]\\:focus\\:ring-red-400:focus{--tw-ring-opacity: 1;--tw-ring-color: rgb(248 113 113 / var(--tw-ring-opacity))}.group.destructive .group-\\[\\.destructive\\]\\:focus\\:ring-offset-red-600:focus{--tw-ring-offset-color: #dc2626}.peer:disabled~.peer-disabled\\:cursor-not-allowed{cursor:not-allowed}.peer:disabled~.peer-disabled\\:opacity-70{opacity:.7}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.data-\\[side\\=bottom\\]\\:translate-y-1[data-side=bottom]{--tw-translate-y: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[side\\=left\\]\\:-translate-x-1[data-side=left]{--tw-translate-x: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[side\\=right\\]\\:translate-x-1[data-side=right]{--tw-translate-x: .25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[side\\=top\\]\\:-translate-y-1[data-side=top]{--tw-translate-y: -.25rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[state\\=checked\\]\\:translate-x-4[data-state=checked]{--tw-translate-x: 1rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[state\\=unchecked\\]\\:translate-x-0[data-state=unchecked],.data-\\[swipe\\=cancel\\]\\:translate-x-0[data-swipe=cancel]{--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[swipe\\=end\\]\\:translate-x-\\[var\\(--radix-toast-swipe-end-x\\)\\][data-swipe=end]{--tw-translate-x: var(--radix-toast-swipe-end-x);transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[swipe\\=move\\]\\:translate-x-\\[var\\(--radix-toast-swipe-move-x\\)\\][data-swipe=move]{--tw-translate-x: var(--radix-toast-swipe-move-x);transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[panel-group-direction\\=vertical\\]\\:flex-col[data-panel-group-direction=vertical]{flex-direction:column}.data-\\[state\\=active\\]\\:bg-background[data-state=active]{background-color:hsl(var(--background))}.data-\\[state\\=checked\\]\\:bg-primary[data-state=checked]{background-color:hsl(var(--primary))}.data-\\[state\\=on\\]\\:bg-accent[data-state=on],.data-\\[state\\=open\\]\\:bg-accent[data-state=open]{background-color:hsl(var(--accent))}.data-\\[state\\=unchecked\\]\\:bg-input[data-state=unchecked]{background-color:hsl(var(--input))}.data-\\[state\\=active\\]\\:text-foreground[data-state=active]{color:hsl(var(--foreground))}.data-\\[state\\=checked\\]\\:text-primary-foreground[data-state=checked]{color:hsl(var(--primary-foreground))}.data-\\[state\\=on\\]\\:text-accent-foreground[data-state=on],.data-\\[state\\=open\\]\\:text-accent-foreground[data-state=open]{color:hsl(var(--accent-foreground))}.data-\\[state\\=open\\]\\:text-muted-foreground[data-state=open]{color:hsl(var(--muted-foreground))}.data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.data-\\[state\\=active\\]\\:shadow[data-state=active]{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.data-\\[swipe\\=move\\]\\:transition-none[data-swipe=move]{transition-property:none}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation-name:enter;animation-duration:.15s;--tw-enter-opacity: initial;--tw-enter-scale: initial;--tw-enter-rotate: initial;--tw-enter-translate-x: initial;--tw-enter-translate-y: initial}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed],.data-\\[swipe\\=end\\]\\:animate-out[data-swipe=end]{animation-name:exit;animation-duration:.15s;--tw-exit-opacity: initial;--tw-exit-scale: initial;--tw-exit-rotate: initial;--tw-exit-translate-x: initial;--tw-exit-translate-y: initial}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity: 0}.data-\\[state\\=closed\\]\\:fade-out-80[data-state=closed]{--tw-exit-opacity: .8}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity: 0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale: .95}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale: .95}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y: -.5rem}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x: .5rem}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x: -.5rem}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y: .5rem}.data-\\[state\\=closed\\]\\:slide-out-to-left-1\\/2[data-state=closed]{--tw-exit-translate-x: -50%}.data-\\[state\\=closed\\]\\:slide-out-to-right-full[data-state=closed]{--tw-exit-translate-x: 100%}.data-\\[state\\=closed\\]\\:slide-out-to-top-\\[48\\%\\][data-state=closed]{--tw-exit-translate-y: -48%}.data-\\[state\\=open\\]\\:slide-in-from-left-1\\/2[data-state=open]{--tw-enter-translate-x: -50%}.data-\\[state\\=open\\]\\:slide-in-from-top-\\[48\\%\\][data-state=open]{--tw-enter-translate-y: -48%}.data-\\[state\\=open\\]\\:slide-in-from-top-full[data-state=open]{--tw-enter-translate-y: -100%}.dark\\:border-neutral-800:is(.dark *){--tw-border-opacity: 1;border-color:rgb(38 38 38 / var(--tw-border-opacity))}.dark\\:bg-black:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(0 0 0 / var(--tw-bg-opacity))}.dark\\:bg-neutral-900:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity))}.dark\\:text-gray-100:is(.dark *){--tw-text-opacity: 1;color:rgb(243 244 246 / var(--tw-text-opacity))}.dark\\:text-neutral-200:is(.dark *){--tw-text-opacity: 1;color:rgb(229 229 229 / var(--tw-text-opacity))}.dark\\:hover\\:bg-neutral-900:hover:is(.dark *){--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity))}.dark\\:hover\\:bg-opacity-20:hover:is(.dark *){--tw-bg-opacity: .2}.dark\\:hover\\:text-neutral-200:hover:is(.dark *){--tw-text-opacity: 1;color:rgb(229 229 229 / var(--tw-text-opacity))}.dark\\:hover\\:text-red-500:hover:is(.dark *){--tw-text-opacity: 1;color:rgb(239 68 68 / var(--tw-text-opacity))}@media (min-width: 640px){.sm\\:bottom-0{bottom:0}.sm\\:right-0{right:0}.sm\\:top-auto{top:auto}.sm\\:block{display:block}.sm\\:max-w-\\[425px\\]{max-width:425px}.sm\\:flex-row{flex-direction:row}.sm\\:flex-col{flex-direction:column}.sm\\:flex-wrap{flex-wrap:wrap}.sm\\:justify-end{justify-content:flex-end}.sm\\:gap-x-2{-moz-column-gap:.5rem;column-gap:.5rem}.sm\\:rounded-lg{border-radius:var(--radius)}.sm\\:text-left{text-align:left}.data-\\[state\\=open\\]\\:sm\\:slide-in-from-bottom-full[data-state=open]{--tw-enter-translate-y: 100%}}@media (min-width: 768px){.md\\:flex{display:flex}.md\\:w-full{width:100%}.md\\:max-w-\\[420px\\]{max-width:420px}.md\\:max-w-\\[825px\\]{max-width:825px}}@media (min-width: 1024px){.lg\\:max-w-\\[1200px\\]{max-width:1200px}}.\\[\\&\\+div\\]\\:text-xs+div{font-size:.75rem;line-height:1rem}.\\[\\&\\:\\:-webkit-inner-spin-button\\]\\:appearance-none::-webkit-inner-spin-button{-webkit-appearance:none;-moz-appearance:none;appearance:none}.\\[\\&\\:\\:-webkit-outer-spin-button\\]\\:appearance-none::-webkit-outer-spin-button{-webkit-appearance:none;-moz-appearance:none;appearance:none}.\\[\\&\\>span\\]\\:truncate>span{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.\\[\\&\\[data-orientation\\=vertical\\]\\>div\\]\\:rotate-90[data-orientation=vertical]>div{--tw-rotate: 90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\\[\\&\\[data-orientation\\=vertical\\]\\]\\:h-px[data-orientation=vertical]{height:1px}.\\[\\&\\[data-orientation\\=vertical\\]\\]\\:w-full[data-orientation=vertical]{width:100%}.\\[\\&\\[data-orientation\\=vertical\\]\\]\\:after\\:left-0[data-orientation=vertical]:after{content:var(--tw-content);left:0}.\\[\\&\\[data-orientation\\=vertical\\]\\]\\:after\\:h-1[data-orientation=vertical]:after{content:var(--tw-content);height:.25rem}.\\[\\&\\[data-orientation\\=vertical\\]\\]\\:after\\:w-full[data-orientation=vertical]:after{content:var(--tw-content);width:100%}.\\[\\&\\[data-orientation\\=vertical\\]\\]\\:after\\:-translate-y-1\\/2[data-orientation=vertical]:after{content:var(--tw-content);--tw-translate-y: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\\[\\&\\[data-orientation\\=vertical\\]\\]\\:after\\:translate-x-0[data-orientation=vertical]:after{content:var(--tw-content);--tw-translate-x: 0px;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}', QH = ["srcdoc"], eV = /* @__PURE__ */ T({
  __name: "Printer",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, { state: n } = pn(), o = O(""), r = O(null);
    async function i() {
      var d, u;
      e.editor.commands.blur();
      const c = e.editor.getHTML();
      o.value = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <title>Echo Editor</title>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>${XH} ${ZH}</style>
    </head>
    <body class="is-print">
      <div class="tiptap ProseMirror" translate="no" aria-expanded="false">
          ${c}
      </div>
    </body>
    </html>`, await qe(), s(r.value), (u = (d = r == null ? void 0 : r.value) == null ? void 0 : d.contentWindow) == null || u.print();
    }
    function s(c) {
      if (!c.contentWindow) {
        console.error("无法访问 iframe 的 contentWindow");
        return;
      }
      c.contentWindow.addEventListener("afterprint", () => {
        n.printer = !1;
      });
    }
    ce(
      () => n.printer,
      (c) => {
        c && i();
      }
    );
    const { bind: a, unbind: l } = _x("ctrl+p,command+p", () => {
      n.printer = !0;
    });
    return e.editor.on("focus", a), e.editor.on("blur", l), (c, d) => p(n).printer ? (k(), U("iframe", {
      key: 0,
      ref_key: "iframeRef",
      ref: r,
      class: "absolute w-0 h-0 border-none overflow-auto",
      srcdoc: p(o)
    }, null, 8, QH)) : ae("", !0);
  }
}), tV = { class: "flex w-full max-w-sm items-center gap-1.5" }, nV = { class: "relative w-full max-w-sm items-center" }, oV = { class: "absolute end-0 inset-y-0 flex items-center justify-center px-2 text-sm" }, rV = { class: "flex gap-1" }, iV = { class: "flex items-center space-x-2 mt-2" }, sV = {
  for: "terms",
  class: "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
}, aV = { class: "flex gap-3 mt-3" }, lV = /* @__PURE__ */ T({
  __name: "FindAndReplace",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    containerRef: { default: void 0 }
  },
  emits: ["update:modelValue", "find", "replace"],
  setup(t, { emit: e }) {
    const n = t, o = O(null), r = O(null), i = pn(), s = O(""), a = O(""), l = O(!1), { t: c } = et(), d = P(() => n.containerRef), { focused: u } = Ym(r), { top: f, right: h } = hO(d), m = gO(d), g = O({ x: 0, y: 0 }), v = P(() => {
      var $, L;
      return ((L = ($ = n.editor) == null ? void 0 : $.storage.findAndReplace) == null ? void 0 : L.results.length) || 0;
    });
    ce([f, h, m], () => {
      m.value && o.value && (g.value = {
        y: f.value + 24,
        x: h.value - 320 - 24
      });
    });
    const y = ($ = !1) => {
      n.editor && ($ && n.editor.commands.resetIndex(), n.editor.commands.setSearchTerm(s.value), n.editor.commands.setReplaceTerm(a.value), n.editor.commands.setCaseSensitive(l.value));
    }, x = () => {
      if (!n.editor)
        return;
      const { results: $, resultIndex: L } = n.editor.storage.findAndReplace, Y = $[L];
      if (!Y)
        return;
      n.editor.commands.setTextSelection(Y);
      const { node: J } = n.editor.view.domAtPos(n.editor.state.selection.anchor);
      J instanceof HTMLElement && J.scrollIntoView({ behavior: "smooth", block: "center" });
    };
    ce(
      () => s.value.trim(),
      ($, L) => {
        $ || A(), $ !== L && y(!0);
      }
    ), ce(
      () => a.value.trim(),
      ($, L) => $ === L ? null : y()
    ), ce(
      () => l.value,
      ($, L) => $ === L ? null : y(!0)
    ), ce(
      () => i.state.findAndReplace,
      async ($) => {
        $ ? (await qe(), u.value = !0, s.value = Fh(n.editor) || "") : A();
      }
    );
    const C = () => {
      n.editor.commands.replace(), x();
    }, b = () => {
      n.editor.commands.nextSearchResult(), x();
    }, S = ($) => {
      $.preventDefault(), n.editor.commands.previousSearchResult(), x();
    }, A = () => {
      s.value = a.value = "", n.editor.commands.resetIndex();
    }, I = () => n.editor.commands.replaceAll();
    function z($) {
      l.value = $;
    }
    _e(() => setTimeout(y));
    const { bind: N, unbind: M } = _x("ctrl+f,command+f", () => {
      i.state.findAndReplace = !0;
    });
    return n.editor.on("focus", N), n.editor.on("blur", M), ($, L) => {
      var H, K, Q, Z, ue, Se, be, we, Re, Ie, Ge, gt;
      const Y = xe, J = ya, ne = Rr, F = Pt, R = e3;
      return k(), _(gl, { to: "body" }, [
        Sn(B("div", {
          ref_key: "dialogRef",
          ref: o,
          class: "findAndReplaceDialog fixed bg-white shadow-lg rounded-lg p-4 w-[320px] border z-[11]",
          style: ct({ top: `${g.value.y}px`, left: `${g.value.x}px` })
        }, [
          B("button", {
            onClick: L[0] || (L[0] = (We) => p(i).toggleFindAndReplace()),
            class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground"
          }, [
            E(Y, { name: "Close" })
          ]),
          E(J, null, {
            default: w(() => [
              he(q(p(c)("editor.findAndReplace.find")), 1)
            ]),
            _: 1
          }),
          B("div", tV, [
            B("div", nV, [
              E(ne, {
                modelValue: s.value,
                "onUpdate:modelValue": L[1] || (L[1] = (We) => s.value = We),
                onKeyup: Sr(b, ["enter"]),
                class: "pr-10",
                ref_key: "inputRef",
                ref: r
              }, null, 8, ["modelValue"]),
              B("span", oV, q((Q = (K = (H = $.editor) == null ? void 0 : H.storage) == null ? void 0 : K.findAndReplace) != null && Q.results.length ? ((Se = (ue = (Z = $.editor) == null ? void 0 : Z.storage) == null ? void 0 : ue.findAndReplace) == null ? void 0 : Se.resultIndex) + 1 : (Re = (we = (be = $.editor) == null ? void 0 : be.storage) == null ? void 0 : we.findAndReplace) == null ? void 0 : Re.resultIndex) + " / " + q((gt = (Ge = (Ie = $.editor) == null ? void 0 : Ie.storage) == null ? void 0 : Ge.findAndReplace) == null ? void 0 : gt.results.length), 1)
            ]),
            B("div", rV, [
              E(F, {
                onClick: S,
                variant: "outline",
                size: "icon",
                class: "px-2.5"
              }, {
                default: w(() => [
                  E(Y, {
                    name: "ChevronUp",
                    class: "w-5 h-5"
                  })
                ]),
                _: 1
              }),
              E(F, {
                onClick: b,
                variant: "outline",
                size: "icon",
                class: "px-2.5"
              }, {
                default: w(() => [
                  E(Y, {
                    name: "ChevronDown",
                    class: "w-5 h-5"
                  })
                ]),
                _: 1
              })
            ])
          ]),
          E(J, null, {
            default: w(() => [
              he(q(p(c)("editor.findAndReplace.replace")), 1)
            ]),
            _: 1
          }),
          E(ne, {
            modelValue: a.value,
            "onUpdate:modelValue": L[2] || (L[2] = (We) => a.value = We)
          }, null, 8, ["modelValue"]),
          B("div", iV, [
            E(R, {
              id: "terms",
              checked: l.value,
              "onUpdate:checked": z
            }, null, 8, ["checked"]),
            B("label", sV, q(p(c)("editor.findAndReplace.caseSensitive")), 1)
          ]),
          B("div", aV, [
            E(F, {
              type: "submit",
              disabled: !v.value
            }, {
              default: w(() => [
                he(q(p(c)("editor.findAndReplace.find")), 1)
              ]),
              _: 1
            }, 8, ["disabled"]),
            E(F, {
              variant: "secondary",
              onClick: C,
              disabled: !$.editor.isEditable || !v.value
            }, {
              default: w(() => [
                he(q(p(c)("editor.findAndReplace.replace")), 1)
              ]),
              _: 1
            }, 8, ["disabled"]),
            E(F, {
              variant: "secondary",
              onClick: I,
              disabled: !$.editor.isEditable || !v.value
            }, {
              default: w(() => [
                he(q(p(c)("editor.findAndReplace.replaceAll")), 1)
              ]),
              _: 1
            }, 8, ["disabled"])
          ])
        ], 4), [
          [Jn, p(i).state.findAndReplace && p(m)]
        ])
      ]);
    };
  }
}), cV = /* @__PURE__ */ T({
  __name: "Toast",
  props: {
    class: {},
    variant: {},
    onOpenChange: { type: Function },
    defaultOpen: { type: Boolean },
    forceMount: { type: Boolean },
    type: {},
    open: { type: Boolean },
    duration: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(ML), j(p(i), {
      class: p(fe)(p(hV)({ variant: s.variant }), n.class),
      "onUpdate:open": s.onOpenChange
    }), {
      default: w(() => [
        D(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "onUpdate:open"]));
  }
}), dV = /* @__PURE__ */ T({
  __name: "ToastViewport",
  props: {
    hotkey: {},
    label: { type: [String, Function] },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(IL), j(n.value, {
      class: p(fe)(
        "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
        e.class
      )
    }), null, 16, ["class"]));
  }
}), uV = /* @__PURE__ */ T({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(OL), j(n.value, {
      class: p(fe)(
        "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
        e.class
      )
    }), {
      default: w(() => [
        E(p(Q4), { class: "h-4 w-4" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), fV = /* @__PURE__ */ T({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(DL), j(n.value, {
      class: p(fe)("text-sm font-semibold [&+div]:text-xs", e.class)
    }), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $y = /* @__PURE__ */ T({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(RL), j({
      class: p(fe)("text-sm opacity-90", e.class)
    }, n.value), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), pV = /* @__PURE__ */ T({
  __name: "ToastProvider",
  props: {
    label: {},
    duration: {},
    swipeDirection: {},
    swipeThreshold: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(yL), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), hV = Rg(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), mV = { class: "grid gap-1" }, gV = /* @__PURE__ */ T({
  __name: "Toaster",
  setup(t) {
    const { toasts: e } = js();
    return (n, o) => (k(), _(p(pV), null, {
      default: w(() => [
        (k(!0), U(ve, null, Fe(p(e), (r) => (k(), _(p(cV), j({
          key: r.id,
          ref_for: !0
        }, r), {
          default: w(() => [
            B("div", mV, [
              r.title ? (k(), _(p(fV), { key: 0 }, {
                default: w(() => [
                  he(q(r.title), 1)
                ]),
                _: 2
              }, 1024)) : ae("", !0),
              r.description ? (k(), U(ve, { key: 1 }, [
                a8(r.description) ? (k(), _(p($y), { key: 0 }, {
                  default: w(() => [
                    (k(), _(_n(r.description)))
                  ]),
                  _: 2
                }, 1024)) : (k(), _(p($y), { key: 1 }, {
                  default: w(() => [
                    he(q(r.description), 1)
                  ]),
                  _: 2
                }, 1024))
              ], 64)) : ae("", !0),
              E(p(uV))
            ]),
            (k(), _(_n(r.action)))
          ]),
          _: 2
        }, 1040))), 128)),
        E(p(dV))
      ]),
      _: 1
    }));
  }
}), vV = { class: "overflow-hidden relative flex-1" }, yV = {
  key: 2,
  class: "flex justify-between border-t p-3 items-center"
}, bV = { class: "flex flex-col" }, wV = { class: "flex justify-end gap-3 text-sm" }, xV = /* @__PURE__ */ T({
  __name: "EchoEditor",
  props: {
    modelValue: { default: "" },
    output: { default: "html" },
    dark: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: !1 },
    hideToolbar: { type: Boolean, default: !1 },
    hideMenubar: { type: Boolean, default: !1 },
    hideBubble: { type: Boolean, default: !1 },
    removeDefaultWrapper: { type: Boolean, default: !1 },
    maxWidth: { default: void 0 },
    minHeight: { default: void 0 },
    maxHeight: { default: void 0 },
    extensions: { default: () => [] },
    editorClass: { default: void 0 },
    contentClass: { default: void 0 }
  },
  emits: ["enter", "change", "update:modelValue"],
  setup(t, { expose: e, emit: n }) {
    const o = t, r = n, i = l8(), { state: s, isFullscreen: a } = pn(), { t: l } = et(), c = fO(), d = O(null), u = P(
      () => [...s.extensions, ...s9(o.extensions, s.extensions, "name")].map(
        (g, v) => g.configure({ sort: v })
      )
    ), f = new P2({
      content: o.modelValue,
      editorProps: {
        handleKeyDown: sd((g, v) => v.key === "Enter" && i.enter && !v.shiftKey ? (r("enter"), !0) : !1, F1)
      },
      onUpdate: sd(({ editor: g }) => {
        const v = m(g, o.output);
        r("update:modelValue", v), r("change", { editor: g, output: v });
      }, F1),
      extensions: p(u),
      editable: !o.disabled
    });
    ce(
      () => o.dark,
      (g) => {
        g !== void 0 && (c.value = g);
      }
    );
    const h = P(() => ({
      ...p(a) ? { height: "100%", overflowY: "auto" } : {
        minHeight: Tc(o.minHeight),
        maxHeight: Tc(o.maxHeight),
        overflowY: "auto",
        scrollBehavior: "smooth",
        scrollbarWidth: "thin"
      },
      maxWidth: Tc(o.maxWidth),
      width: o.maxWidth ? "100%" : void 0,
      margin: o.maxWidth ? "8px auto" : void 0
    }));
    function m(g, v) {
      if (o.removeDefaultWrapper)
        return v === "html" ? g.isEmpty ? "" : g.getHTML() : v === "json" ? g.isEmpty ? {} : g.getJSON() : v === "text" ? g.isEmpty ? "" : g.getText() : "";
      switch (v) {
        case "html":
          return g.getHTML();
        case "json":
          return g.getJSON();
        case "text":
          return g.getText();
        default:
          return "";
      }
    }
    return ce(
      () => o.modelValue,
      (g) => {
        if (!f || a9(m(f, o.output), g))
          return;
        const { from: v, to: y } = f.state.selection;
        f.commands.setContent(g, !1), f.commands.setTextSelection({ from: v, to: y });
      },
      { deep: !0 }
    ), ce(
      () => o.disabled,
      (g) => f == null ? void 0 : f.setEditable(!g)
    ), en(() => f == null ? void 0 : f.destroy()), e({ editor: f }), (g, v) => p(f) ? (k(), U("div", {
      key: 0,
      class: Ze(["echo-editor rounded-[0.5rem] bg-background shadow outline outline-1 relative", [
        g.editorClass,
        {
          "outline-primary": p(f).isFocused,
          "outline-border": !p(f).isFocused
        }
      ]])
    }, [
      E(YH, { editor: p(f) }, null, 8, ["editor"]),
      E(eV, { editor: p(f) }, null, 8, ["editor"]),
      E(lV, {
        "container-ref": p(d),
        editor: p(f)
      }, null, 8, ["container-ref", "editor"]),
      B("div", {
        class: Ze(["relative flex flex-col overflow-hidden", {
          "!fixed bg-background inset-0 z-[10]  w-full h-full m-0 rounded-[0.5rem]": p(a)
        }])
      }, [
        g.hideMenubar ? ae("", !0) : (k(), _(OH, {
          key: 0,
          editor: p(f),
          disabled: g.disabled
        }, null, 8, ["editor", "disabled"])),
        g.hideToolbar ? ae("", !0) : (k(), _(PH, {
          key: 1,
          editor: p(f),
          disabled: g.disabled,
          class: "border-b py-1 px-1 overflow-hidden"
        }, null, 8, ["editor", "disabled"])),
        B("div", vV, [
          E(p($7), {
            ref_key: "contentRef",
            ref: d,
            editor: p(f),
            class: Ze(g.contentClass),
            style: ct(h.value),
            spellcheck: p(s).spellCheck
          }, null, 8, ["editor", "class", "style", "spellcheck"]),
          !g.hideBubble && !g.disabled && p(f).isEditable ? (k(), U(ve, { key: 0 }, [
            E(VF, {
              editor: p(f),
              class: "hidden sm:block"
            }, null, 8, ["editor"]),
            E(e$, { editor: p(f) }, null, 8, ["editor"]),
            E(KF, { editor: p(f) }, null, 8, ["editor"]),
            E(L$, { editor: p(f) }, null, 8, ["editor"]),
            E(xH, { editor: p(f) }, null, 8, ["editor"]),
            E(XF, { editor: p(f) }, null, 8, ["editor"]),
            E(_N, { editor: p(f) }, null, 8, ["editor"])
          ], 64)) : ae("", !0)
        ]),
        p(xu)(p(f), "characterCount") ? (k(), U("div", yV, [
          B("div", bV, [
            B("div", wV, [
              B("span", null, q(p(f).storage.characterCount.characters()) + " " + q(p(l)("editor.characters")), 1)
            ])
          ]),
          D(g.$slots, "footer", { editor: p(f) })
        ])) : ae("", !0)
      ], 2),
      E(gV)
    ], 2)) : ae("", !0);
  }
});
function kV() {
  i3({
    prefix: "echo",
    icons: {
      baidu: {
        body: '<svg t="1716185245518" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6045" width="24" height="24"><path d="M824.32 1018.88h-163.84l348.16-348.16v163.84c0 102.4-81.92 184.32-184.32 184.32z m0-1008.64c102.4 0 184.32 81.92 184.32 184.32v97.28l-281.6-281.6h97.28z m-58.88 366.08c0 66.56-25.6 128-66.56 174.08l-7.68 5.12c-79.36 87.04-140.8 192-179.2 307.2-2.56 2.56-5.12 5.12-10.24 5.12s-7.68-2.56-10.24-5.12c-38.4-115.2-99.84-217.6-179.2-307.2l-7.68-7.68-2.56-2.56 2.56 2.56c-40.96-46.08-66.56-107.52-66.56-174.08 0-56.32 17.92-107.52 46.08-148.48C332.8 156.16 409.6 112.64 499.2 112.64s168.96 43.52 215.04 112.64c33.28 43.52 51.2 94.72 51.2 151.04z m-289.28-112.64h-33.28v61.44h-38.4c-38.4 0-71.68 30.72-71.68 71.68v15.36c0 38.4 30.72 71.68 71.68 71.68h66.56v-2.56h2.56v-217.6z m176.64 64h-35.84v125.44h-40.96c-15.36 0-30.72-12.8-30.72-30.72v-97.28H512V435.2c0 25.6 20.48 48.64 48.64 48.64h92.16v-156.16z m-276.48 84.48v-15.36c0-20.48 15.36-35.84 35.84-35.84h30.72v89.6h-30.72c-20.48-2.56-35.84-17.92-35.84-38.4z m-97.28-194.56c-17.92 28.16-33.28 58.88-40.96 89.6L28.16 94.72C61.44 43.52 117.76 7.68 184.32 7.68h307.2l107.52 107.52c-30.72-12.8-64-17.92-97.28-17.92-92.16 2.56-174.08 48.64-222.72 120.32z m20.48 335.36l7.68 7.68c28.16 30.72 53.76 61.44 76.8 97.28L64 972.8C25.6 939.52 0 890.88 0 834.56V225.28l250.88 250.88c12.8 28.16 28.16 53.76 48.64 76.8z m476.16-181.76c0-35.84-7.68-69.12-17.92-99.84l245.76 245.76-276.48 279.04-117.76-117.76c25.6-40.96 56.32-79.36 89.6-117.76l7.68-7.68c40.96-48.64 69.12-112.64 69.12-181.76zM491.52 878.08c2.56 2.56 5.12 5.12 10.24 5.12s7.68-2.56 10.24-5.12c10.24-33.28 25.6-66.56 40.96-99.84l94.72 94.72-145.92 145.92H184.32c-15.36 0-30.72-2.56-43.52-5.12l286.72-286.72c25.6 48.64 48.64 99.84 64 151.04z" fill="#B3CE7D" p-id="6046"></path><path d="M765.44 376.32c0 66.56-25.6 128-66.56 174.08l-7.68 5.12c-79.36 87.04-140.8 192-179.2 307.2-2.56 2.56-5.12 5.12-10.24 5.12s-7.68-2.56-10.24-5.12c-38.4-115.2-99.84-217.6-179.2-307.2l-7.68-7.68-2.56-2.56 2.56 2.56c-40.96-46.08-66.56-107.52-66.56-174.08 0-56.32 17.92-107.52 46.08-148.48C332.8 156.16 409.6 112.64 499.2 112.64s168.96 43.52 215.04 112.64c33.28 43.52 51.2 94.72 51.2 151.04z m-289.28-112.64h-33.28v61.44h-38.4c-38.4 0-71.68 30.72-71.68 71.68v15.36c0 38.4 30.72 71.68 71.68 71.68h66.56v-2.56h2.56v-217.6z m176.64 64h-35.84v125.44h-40.96c-15.36 0-30.72-12.8-30.72-30.72v-97.28H512V435.2c0 25.6 20.48 48.64 48.64 48.64h92.16v-156.16z m-276.48 84.48v-15.36c0-20.48 15.36-35.84 35.84-35.84h30.72v89.6h-30.72c-20.48-2.56-35.84-17.92-35.84-38.4z" fill="#F93737" p-id="6047"></path><path d="M824.32 10.24c102.4 0 184.32 81.92 184.32 184.32v97.28l-281.6-281.6h97.28z" fill="#B2E5FF" p-id="6048"></path><path d="M279.04 217.6c-17.92 28.16-33.28 58.88-40.96 89.6L28.16 94.72C61.44 43.52 117.76 7.68 184.32 7.68h307.2l107.52 107.52c-30.72-12.8-64-17.92-97.28-17.92-92.16 2.56-174.08 48.64-222.72 120.32z m496.64 153.6c0-35.84-7.68-69.12-17.92-99.84l245.76 245.76-276.48 279.04-117.76-117.76c25.6-40.96 56.32-79.36 89.6-117.76l7.68-7.68c40.96-48.64 69.12-112.64 69.12-181.76z" fill="#E6F28F" p-id="6049"></path></svg>',
        width: 24,
        height: 24
      },
      gaode: {
        body: '<svg t="1716185147787" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4078" width="24" height="24"><path d="M658.285714 621.714286h365.714286v256a146.285714 146.285714 0 0 1-146.285714 146.285714h-219.428572V621.714286z" fill="#B2D8FF" p-id="4079"></path><path d="M1024 364.397714V218.624H0v145.773714z" fill="#FFFFFF" p-id="4080"></path><path d="M649.142857 1024h145.773714V0H649.142857z" fill="#FFFFFF" p-id="4081"></path><path d="M1024 729.417143v-145.773714H0v145.773714z" fill="#FFCF68" p-id="4082"></path><path d="M0 218.624h649.179429V0H146.285714a146.285714 146.285714 0 0 0-146.285714 146.285714v72.338286z" fill="#AFE881" p-id="4083"></path><path d="M195.803429 1024H341.577143V0H195.803429z" fill="#FFCF68" p-id="4084"></path><path d="M103.862857 543.670857L349.622857 618.057143l302.628572-256.950857-234.569143 276.772571 262.765714 81.188572 135.314286-520.192z" fill="#0093FD" p-id="4085"></path><path d="M652.251429 361.142857L349.586286 618.057143l68.096 19.821714z" fill="#0066BD" p-id="4086"></path><path d="M349.622857 618.093714v143.908572l97.938286-114.834286-97.974857-29.074286z" fill="#0064BB" p-id="4087"></path></svg>',
        width: 24,
        height: 24
      },
      youku: {
        body: '<svg t="1716185468594" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7073" width="24" height="24"><path d="M740.113 555.315l0.205-0.307c0.512-0.82 0.887-1.707 1.4-2.526 0.204-0.41 0.409-0.82 0.716-1.229 0.205-0.307 0.341-0.682 0.512-1.024 5.598-10.956 8.636-23.04 8.738-35.328v-2.457a80.76 80.76 0 0 0-8.738-35.362c-0.205-0.308-0.307-0.683-0.512-1.024a7.578 7.578 0 0 0-0.683-1.195c-0.546-0.82-0.921-1.707-1.433-2.526-0.103-0.102-0.103-0.205-0.205-0.341a71.339 71.339 0 0 0-4.983-7.305v-0.102a76.902 76.902 0 0 0-8.124-9.148l-0.205-0.17a106.462 106.462 0 0 0-5.086-4.472c-0.41-0.341-0.682-0.614-1.126-0.922l-3.652-2.73a5.632 5.632 0 0 1-0.82-0.615l-250.88-168.14a80.247 80.247 0 0 0-60.586-12.186 80.213 80.213 0 0 0-51.405 34.236 80.862 80.862 0 0 0 22.05 112.06l150.87 101.17-150.972 101.172a80.862 80.862 0 0 0-22.05 112.06 80.213 80.213 0 0 0 51.404 34.235 80.247 80.247 0 0 0 60.553-12.185L715.913 580.71a5.632 5.632 0 0 0 0.819-0.614l1.536-1.024 2.218-1.604 1.127-0.922c1.843-1.433 3.447-2.935 5.086-4.437l0.204-0.24c2.936-2.832 5.7-5.87 8.124-9.147v-0.102c1.912-2.321 3.55-4.779 5.086-7.305z" fill="#FF4A4A" p-id="7074"></path><path d="M979.149 312.627a504.286 504.286 0 0 0-108.886-161.45A506.778 506.778 0 0 0 510.976 2.526c-86.016 0-171.042 21.913-245.93 63.385A510.26 510.26 0 0 0 85.162 233.335 506.368 506.368 0 0 0 2.97 510.464c0 68.574 13.38 135.1 39.936 197.769a505.651 505.651 0 0 0 108.783 161.45A508.757 508.757 0 0 0 313.105 978.57a509.61 509.61 0 0 0 435.712-19.115A512.341 512.341 0 0 0 926.583 802.61a504.9 504.9 0 0 0 92.331-292.181 501.214 501.214 0 0 0-39.8-197.769zM510.976 857.532c-191.386 0-347.136-155.717-347.136-347.136 0-67.55 19.456-132.95 56.115-189.235a346.453 346.453 0 0 1 291.021-157.867c191.42 0 347.136 155.716 347.136 347.136 0 71.919-21.845 140.97-63.078 199.51a347.477 347.477 0 0 1-284.058 147.592z" fill="#38CEFF" p-id="7075"></path><path d="M907.332 690.415a80.35 80.35 0 0 0-112.06 19.524 80.35 80.35 0 0 0 65.707 126.669c25.293 0 50.176-11.878 65.843-34.133a80.555 80.555 0 0 0-19.49-112.06z m-798.72-345.77a80.486 80.486 0 0 0 87.894-134.827 80.486 80.486 0 0 0-87.86 134.826z" fill="#0B99FF" p-id="7076"></path><path d="M751.684 512.444a82.193 82.193 0 0 0-8.738-35.362c-0.205-0.308-0.307-0.683-0.512-1.024a7.578 7.578 0 0 0-0.683-1.195c-0.546-0.82-0.921-1.707-1.433-2.526-0.103-0.102-0.103-0.205-0.205-0.341-0.717-1.093-1.331-2.219-2.15-3.243-0.922-1.4-1.912-2.73-2.936-4.062v-0.102a87.04 87.04 0 0 0-8.124-9.148l-0.204-0.17a106.462 106.462 0 0 0-5.086-4.472c-0.41-0.341-0.683-0.614-1.127-0.922a17.954 17.954 0 0 0-2.218-1.638l-1.536-1.024a79.701 79.701 0 0 0-45.91-14.2c-16.042 0-31.607 4.78-44.885 13.722l-100.01 67.038 100.01 67.038c13.312 8.943 28.843 13.721 44.885 13.721a80.982 80.982 0 0 0 45.91-14.233l1.536-1.024 2.218-1.604 1.127-0.922a157.672 157.672 0 0 0 5.086-4.437l0.204-0.24a77.32 77.32 0 0 0 8.124-9.147v-0.102c1.024-1.298 1.912-2.629 2.936-4.062l2.15-3.243 0.205-0.307a31.88 31.88 0 0 0 1.4-2.526c0.204-0.41 0.409-0.82 0.716-1.229 0.205-0.307 0.341-0.683 0.512-1.024 5.598-10.957 8.533-23.04 8.738-35.362v-2.628z" fill="#F5001A" p-id="7077"></path></svg>',
        width: 24,
        height: 24
      },
      bilibili: {
        body: '<svg t="1716185543850" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="8124" width="24" height="24"><path d="M0 0m184.32 0l655.36 0q184.32 0 184.32 184.32l0 655.36q0 184.32-184.32 184.32l-655.36 0q-184.32 0-184.32-184.32l0-655.36q0-184.32 184.32-184.32Z" fill="#EC5D85" p-id="8125"></path><path d="M512 241.96096h52.224l65.06496-96.31744c49.63328-50.31936 89.64096 0.43008 63.85664 45.71136l-34.31424 51.5072c257.64864 5.02784 257.64864 43.008 257.64864 325.03808 0 325.94944 0 336.46592-404.48 336.46592S107.52 893.8496 107.52 567.90016c0-277.69856 0-318.80192 253.14304-324.95616l-39.43424-58.368c-31.26272-54.90688 37.33504-90.40896 64.68608-42.37312l60.416 99.80928c18.18624-0.0512 41.18528-0.0512 65.66912-0.0512z" fill="#EF85A7" p-id="8126"></path><path d="M512 338.5856c332.8 0 332.8 0 332.8 240.64s0 248.39168-332.8 248.39168-332.8-7.75168-332.8-248.39168 0-240.64 332.8-240.64z" fill="#EC5D85" p-id="8127"></path><path d="M281.6 558.08a30.72 30.72 0 0 1-27.47392-16.97792 30.72 30.72 0 0 1 13.73184-41.216l122.88-61.44a30.72 30.72 0 0 1 41.216 13.74208 30.72 30.72 0 0 1-13.74208 41.216l-122.88 61.44a30.59712 30.59712 0 0 1-13.73184 3.23584zM752.64 558.08a30.60736 30.60736 0 0 1-12.8512-2.83648l-133.12-61.44a30.72 30.72 0 0 1-15.04256-40.7552 30.72 30.72 0 0 1 40.76544-15.02208l133.12 61.44A30.72 30.72 0 0 1 752.64 558.08zM454.656 666.88a15.36 15.36 0 0 1-12.288-6.1952 15.36 15.36 0 0 1 3.072-21.49376l68.5056-50.91328 50.35008 52.62336a15.36 15.36 0 0 1-22.20032 21.23776l-31.5904-33.024-46.71488 34.72384a15.28832 15.28832 0 0 1-9.13408 3.04128z" fill="#EF85A7" p-id="8128"></path><path d="M65.536 369.31584c15.03232 101.90848 32.84992 147.17952 44.544 355.328 14.63296 2.18112 177.70496 10.04544 204.05248-74.62912a16.14848 16.14848 0 0 0 1.64864-10.87488c-30.60736-80.3328-169.216-60.416-169.216-60.416s-10.36288-146.50368-11.49952-238.83776zM362.25024 383.03744l34.816 303.17568h34.64192L405.23776 381.1328zM309.52448 536.28928h45.48608l16.09728 158.6176-31.82592 1.85344zM446.86336 542.98624h45.80352V705.3312h-33.87392zM296.6016 457.97376h21.39136l5.2736 58.99264-18.91328 2.26304zM326.99392 457.97376h21.39136l2.53952 55.808-17.408 1.61792zM470.62016 459.88864h19.456v62.27968h-19.456zM440.23808 459.88864h22.20032v62.27968h-16.62976z" fill="#FFFFFF" p-id="8129"></path><path d="M243.56864 645.51936a275.456 275.456 0 0 1-28.4672 23.74656 242.688 242.688 0 0 1-29.53216 17.52064 2.70336 2.70336 0 0 1-4.4032-1.95584 258.60096 258.60096 0 0 1-5.12-29.57312c-1.41312-12.1856-1.95584-25.68192-2.16064-36.36224 0-0.3072 0-2.5088 3.01056-1.90464a245.92384 245.92384 0 0 1 34.22208 9.5744 257.024 257.024 0 0 1 32.3584 15.17568c0.52224 0.256 2.51904 1.4848 0.09216 3.77856z" fill="#EB5480" p-id="8130"></path><path d="M513.29024 369.31584c15.03232 101.90848 32.84992 147.17952 44.544 355.328 14.63296 2.18112 177.70496 10.04544 204.05248-74.62912a16.14848 16.14848 0 0 0 1.64864-10.87488c-30.60736-80.3328-169.216-60.416-169.216-60.416s-10.36288-146.50368-11.49952-238.83776zM810.00448 383.03744l34.816 303.17568h34.64192L852.992 381.1328zM757.27872 536.28928h45.48608l16.09728 158.6176-31.82592 1.85344zM894.6176 542.98624h45.80352V705.3312H906.5472zM744.35584 457.97376h21.39136l5.2736 58.99264-18.91328 2.26304zM774.74816 457.97376h21.39136l2.53952 55.808-17.408 1.61792zM918.3744 459.88864h19.456v62.27968h-19.456zM887.99232 459.88864h22.20032v62.27968h-16.62976z" fill="#FFFFFF" p-id="8131"></path><path d="M691.32288 645.51936a275.456 275.456 0 0 1-28.4672 23.74656 242.688 242.688 0 0 1-29.53216 17.52064 2.70336 2.70336 0 0 1-4.4032-1.95584 258.60096 258.60096 0 0 1-5.12-29.57312c-1.41312-12.1856-1.95584-25.68192-2.16064-36.36224 0-0.3072 0-2.5088 3.01056-1.90464a245.92384 245.92384 0 0 1 34.22208 9.5744 257.024 257.024 0 0 1 32.3584 15.17568c0.52224 0.256 2.51904 1.4848 0.09216 3.77856z" fill="#EB5480" p-id="8132"></path></svg>',
        width: 24,
        height: 24
      },
      modao: {
        body: '<svg t="1716185608586" class="icon" viewBox="0 0 1061 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9191" width="24" height="24"><path d="M601.043478 881.15942c-1.855072-5.194203-17.066667-40.069565-33.391304-77.542029-16.324638-37.843478-29.681159-70.121739-29.68116-71.976811s13.727536-11.501449 30.423189-21.147826c74.944928-44.521739 131.710145-120.208696 157.310145-209.994203 10.017391-34.504348 10.017391-35.988406 12.243478-190.70145l2.226087-155.826087 79.397101-1.113043c43.77971-0.742029 83.478261-0.371014 88.30145 1.113043l8.904348 2.226087-1.484058 162.133334c-1.113043 147.663768-2.226087 165.101449-9.275363 196.637681-17.437681 77.913043-47.86087 148.776812-89.043478 206.284058-42.295652 58.991304-115.756522 125.031884-176.231884 157.681159-26.342029 14.098551-34.875362 14.469565-39.698551 2.226087zM132.452174 480.092754c-1.484058-1.484058-2.597101-74.944928-2.597102-163.246377 0-126.886957 1.113043-160.649275 4.823189-162.133334 8.162319-2.968116 163.617391-2.597101 168.811594 0.371015 3.710145 2.597101 4.452174 37.843478 3.710145 164.35942l-1.113043 161.02029-85.704348 1.113044c-47.118841 0.371014-86.446377-0.371014-87.930435-1.484058zM421.843478 480.092754c-1.484058-1.484058-2.597101-74.944928-2.597101-163.246377 0-126.515942 1.113043-160.649275 4.823188-162.133334 7.791304-2.968116 163.988406-2.226087 168.811594 0.742029 3.33913 2.226087 4.452174 39.698551 3.710145 163.988406l-1.113043 161.02029-85.704348 1.113044c-47.118841 0.371014-86.446377-0.371014-87.930435-1.484058z" fill="#FF3332" p-id="9192"></path></svg>',
        width: 24,
        height: 24
      },
      lanhu: {
        body: '<svg t="1716185640724" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11680" width="24" height="24"><path d="M959.445292 862.225843c38.558128 43.498852 6.246304 133.850105-74.735493 94.088796-167.319032-82.174739-200.485883 60.133477-374.071698 65.217559-173.596055 5.094322-211.422035-147.387178-373.677464-65.217559-80.495404 40.749454-113.303861-50.589943-74.750853-94.088796 53.800134-60.665949 104.461757-130.138162 105.506221-384.147703-0.445433-8.125315 0-11.04367 0-19.271384 0-103.340494 35.977688-197.244972 94.626387-266.732546-5.913509-6.891414-12.123974-15.856397-18.267879-26.213998a61.346898 61.346898 0 0 1-1.658855-2.969554 340.239257 340.239257 0 0 1-16.102153-31.164962 370.523592 370.523592 0 0 1-13.444913-33.996278c-0.455673-1.443818-0.993265-2.887636-1.372139-4.336573a303.662539 303.662539 0 0 1-6.082467-21.862065C197.677785 37.903137 199.121603 9.113819 218.408347 0.947544c10.941272-4.638649 24.160909 8.46323 39.495073 27.744854 0.537592 0.686069 1.146862 1.382379 1.745894 2.129887 0.691189 0.844787 1.372139 1.684454 2.053088 2.590681 10.019686 12.953401 21.114556 28.118608 33.177091 42.142073 0.931826 1.059824 1.827812 2.135007 2.749398 3.20507 0.527352 0.604151 1.059824 1.203182 1.587175 1.827812 14.602016 16.419588 30.60177 30.842407 47.989024 37.974457 49.105166-30.217776 105.470381-47.405352 165.42466-47.405352 58.443903 0 113.493298 16.347909 161.728078 45.173067 15.492882-7.679882 29.838902-20.87904 43.038059-35.737052 0.537592-0.62975 1.075183-1.228781 1.597416-1.832932l2.734038-3.20507c12.083015-14.028585 23.172764-29.183552 33.18221-42.142073 0.691189-0.906226 1.372139-1.745893 2.063329-2.590681 0.599031-0.747509 1.208301-1.443818 1.740773-2.129887 15.339285-19.281624 28.548682-32.383503 39.500194-27.744854 19.276504 8.161155 20.735682 36.955593 12.98412 70.572997a298.419739 298.419739 0 0 1-6.082466 21.867184c-0.368634 1.448938-0.906226 2.892756-1.361899 4.336573a379.514174 379.514174 0 0 1-13.434674 33.996278 342.829938 342.829938 0 0 1-16.112393 31.164962c-0.522232 0.993265-1.059824 1.97117-1.669094 2.969555-4.710328 7.935878-9.446255 15.052569-14.079784 21.047996C819.743116 256.882175 857.543496 352.880702 857.543496 458.811876c0 6.041507-0.02048 6.246304-0.266236 12.231492 0.122878 259.411058 47.917344 330.004534 102.168032 391.187595z" fill="#0692FF" p-id="11681"></path><path d="M510.863377 640.374529c112.67923 0 203.982789-92.189305 203.982789-205.87716 0-39.295397-10.931032-75.994993-29.96178-107.282833 0-0.081919-0.071679-0.153598-0.143358-0.240637-35.747291-58.955895-100.227582-98.261532-173.872531-98.261531-112.668991 0-204.054468 92.117626-204.054467 205.785001a206.368672 206.368672 0 0 0 53.027026 138.432435c37.354947 41.389445 91.124361 67.444725 151.022321 67.444725z" fill="#FFFFFF" p-id="11682"></path><path d="M554.223992 290.089986c57.030805 0 103.268815 46.632244 103.268815 104.1904 0 57.532557-46.23801 104.169921-103.268815 104.169921-57.030805 0-103.268815-46.637364-103.268815-104.169921 0-57.558156 46.23801-104.190401 103.268815-104.1904z" fill="#293D50" p-id="11683"></path></svg>',
        width: 24,
        height: 24
      },
      qqvideo: {
        body: '<svg t="1716186856310" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16273" width="24" height="24"><path d="M199.111111 0h625.777778c109.795556 0 199.111111 89.315556 199.111111 199.111111v625.777778c0 109.795556-89.315556 199.111111-199.111111 199.111111H199.111111c-109.795556 0-199.111111-89.315556-199.111111-199.111111V199.111111C0 89.315556 89.315556 0 199.111111 0z" fill="#FFFFFF" p-id="16274"></path><path d="M327.68 143.36c25.6-2.844444 51.768889 0.568889 75.662222 9.102222 52.906667 17.066667 104.675556 38.684444 154.737778 63.146667 84.195556 41.528889 164.977778 89.884444 242.346667 143.36 34.133333 22.755556 65.991111 48.924444 94.435555 78.506667 15.928889 18.204444 28.444444 40.96 26.168889 65.422222-3.413333 29.582222-23.893333 52.906667-44.373333 72.817778-84.195556 79.644444-176.924444 150.186667-276.48 209.92-51.2 30.72-105.813333 55.751111-162.133334 75.662222-36.408889 12.515556-74.524444 23.324444-113.208888 19.342222-23.324444-1.706667-44.942222-11.946667-60.871112-28.444444-13.084444-15.36-21.617778-33.564444-25.031111-52.906667l1.137778-1.706667c17.066667-3.982222 33.564444-9.102222 50.631111-13.084444 71.111111-18.204444 139.946667-44.373333 205.368889-77.368889 70.542222-34.133333 137.671111-73.955556 201.386667-119.466667 20.48-15.36 43.235556-30.72 55.182222-55.182222 7.964444-17.635556 6.826667-38.115556-3.982222-54.613333-12.515556-19.342222-29.013333-35.271111-48.355556-48.355556-21.617778-15.36-44.373333-29.582222-67.697778-42.666667-44.373333-26.737778-91.022222-49.493333-138.24-72.248888-54.044444-26.168889-109.795556-48.355556-167.253333-66.56-25.6-7.395556-51.2-15.36-76.8-22.186667 2.844444-11.377778 6.257778-22.755556 10.808889-33.564445 13.084444-26.168889 37.546667-44.942222 66.56-48.924444z" fill="#10ABF2" p-id="16275"></path><path d="M168.96 231.537778c23.893333-11.377778 51.768889-7.964444 76.8-3.413334-7.395556 33.564444-11.946667 67.697778-17.066667 101.831112-0.568889 14.791111-2.275556 29.013333-3.982222 43.804444-2.844444 18.204444-2.275556 36.977778-5.12 55.182222-0.568889 21.048889-1.706667 42.666667-2.275555 64.284445-2.275556 20.48-1.137778 41.528889-1.137778 62.008889 0 30.72-0.568889 62.008889 1.706666 92.728888 1.706667 47.217778 5.12 93.866667 11.377778 140.515556v6.826667c-23.893333 4.551111-51.768889 7.964444-73.955555-6.826667s-27.875556-42.097778-33.564445-65.991111c-13.084444-76.8-19.911111-154.737778-19.342222-233.244445 1.137778-40.96 5.12-81.351111 10.808889-121.742222 4.551111-32.995556 11.946667-65.422222 22.755555-97.28 5.688889-16.497778 17.635556-30.72 32.995556-38.684444z" fill="#FF8F21" p-id="16276"></path><path d="M246.897778 225.848889l5.12 0.568889c25.6 6.826667 51.2 14.791111 76.8 22.186666 57.457778 18.204444 113.208889 40.96 167.253333 67.128889 46.648889 23.324444 93.297778 46.08 138.24 72.248889 23.324444 13.084444 46.08 27.306667 67.697778 42.666667 19.342222 12.515556 35.271111 29.013333 48.355555 47.786667 10.808889 16.497778 11.946667 36.977778 3.982223 54.613333-11.377778 23.893333-34.702222 39.253333-55.182223 55.182222-63.715556 45.511111-130.844444 85.333333-201.386666 119.466667-65.991111 32.995556-134.826667 58.595556-205.937778 77.368889-17.066667 3.982222-33.564444 9.102222-50.631111 13.084444l-9.671111 1.706667c-0.568889-3.982222-1.137778-7.964444-1.706667-12.515556-6.257778-46.648889-9.671111-93.866667-11.377778-140.515555-3.413333-30.72-2.275556-62.008889-2.275555-92.728889-0.568889-20.48 0-41.528889 1.137778-62.008889 0.568889-21.048889 1.706667-42.666667 2.275555-64.284445 2.844444-18.204444 2.275556-36.977778 5.12-55.182222 1.706667-14.222222 3.413333-29.013333 3.982222-43.804444 5.12-34.133333 9.102222-68.266667 17.066667-101.831111l0.568889-2.275556 0.568889 1.137778z m96.711111 122.311111c-9.102222 3.413333-14.791111 11.946667-14.222222 21.048889-0.568889 13.653333-0.568889 27.306667 0.568889 40.96 0.568889 40.391111-0.568889 81.351111 0.568888 121.742222v108.088889c-1.137778 9.102222 2.844444 18.204444 10.808889 23.324444 9.102222 2.275556 19.342222 0.568889 26.737778-5.688888 65.422222-43.804444 131.413333-87.608889 196.835556-131.413334 7.964444-5.688889 17.066667-14.222222 15.928889-25.6-1.706667-10.24-8.533333-19.342222-18.204445-23.893333L362.951111 353.28c-5.688889-3.982222-12.515556-5.688889-19.342222-5.12z" fill="#7DE621" p-id="16277"></path><path d="M343.608889 348.16c6.826667-0.568889 13.653333 1.137778 19.342222 5.12l200.817778 124.017778c9.671111 4.551111 16.497778 13.084444 18.204444 23.893333 1.137778 10.808889-7.964444 19.342222-15.928889 25.6-65.422222 43.235556-131.413333 87.04-196.835555 130.844445-7.395556 5.688889-17.635556 7.964444-26.737778 5.688888-7.395556-5.12-11.377778-13.653333-10.808889-22.755555v-108.088889c-1.137778-40.391111 0-81.351111-0.568889-121.742222-1.137778-13.653333-1.706667-27.306667-1.137777-41.528889-1.137778-9.102222 5.12-17.635556 13.653333-21.048889z" fill="#FFFFFF" p-id="16278"></path></svg>',
        width: 24,
        height: 24
      },
      figma: {
        body: '<svg t="1716187077296" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="17340" width="24" height="24"><path d="M512 512c0-94.4 76.8-171.2 171.2-171.2 94.4 0 171.2 76.8 171.2 171.2s-76.8 171.2-171.2 171.2C588.8 683.2 512 606.4 512 512z" fill="#1ABCFE" p-id="17341"></path><path d="M171.2 852.8c0-94.4 76.8-171.2 171.2-171.2H512v171.2C512 947.2 435.2 1024 340.8 1024s-169.6-76.8-169.6-171.2z" fill="#0ACF83" p-id="17342"></path><path d="M512 0v340.8h171.2c94.4 0 171.2-76.8 171.2-171.2S777.6 0 683.2 0H512z" fill="#FF7262" p-id="17343"></path><path d="M171.2 171.2c0 94.4 76.8 171.2 171.2 171.2H512V0H340.8c-94.4 0-169.6 76.8-169.6 171.2z" fill="#F24E1E" p-id="17344"></path><path d="M171.2 512c0 94.4 76.8 171.2 171.2 171.2H512V340.8H340.8c-94.4 0-169.6 76.8-169.6 171.2z" fill="#A259FF" p-id="17345"></path></svg>',
        width: 24,
        height: 24
      },
      canva: {
        body: '<svg t="1716187133225" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23499" width="24" height="24"><path d="M512 0C229.248 0 0 229.248 0 512s229.248 512 512 512 512-229.248 512-512S794.752 0 512 0zM297.056 327.68c32.16 0 57.056 23.424 59.936 51.2 2.944 24.864-7.296 46.816-35.072 60-14.624 7.296-20.48 7.328-23.424 2.944-1.44-2.944 0-5.856 2.944-8.8 26.336-21.92 26.336-39.52 23.392-64.352-1.44-16.128-13.152-26.368-24.864-26.368-51.2 0-124.32 114.08-114.08 197.504 4.384 32.16 23.424 70.24 64.384 70.24 13.152 0 27.744-4.384 40.96-10.24 21.344-11.264 34.08-20.064 46.816-34.144-3.104-37.76 30.048-87.296 78.976-87.296 21.984 0 39.52 8.736 40.96 24.864 2.912 21.92-16.096 24.832-21.92 24.832s-16.128-1.44-16.128-7.264c-1.44-5.888 13.184-2.976 11.744-16.128-1.504-8.8-10.24-11.68-19.04-11.68-30.72 0-48.256 42.4-43.904 68.736 1.504 11.744 7.328 23.424 19.072 23.424 8.736 0 21.92-13.216 26.336-32.224 2.912-13.152 14.624-21.92 24.864-21.92 4.352 0 7.264 1.44 8.736 7.296v5.888c-1.44 5.856-5.856 23.392-4.352 27.776 0 2.944 1.44 7.296 7.264 7.296 3.936 0 18.592-7.68 33.152-19.584 4.992-25.184 10.784-55.392 10.784-57.888 1.44-10.24 5.856-20.48 26.336-20.48 4.384 0 7.296 1.44 8.736 7.296v5.888l-5.792 26.336c18.976-24.864 46.816-42.4 64.352-42.4 7.328 0 13.184 4.352 13.184 11.68 0 4.384 0 11.68-2.944 19.04a474.88 474.88 0 0 0-17.568 62.88c0 5.856 1.504 11.68 8.832 11.68 7.296 0 29.216-8.8 46.752-32.16l0.288-0.16c-0.096-2.912-0.288-5.728-0.288-8.608 0-17.536 1.504-32.16 4.448-42.4 2.912-11.68 17.536-21.92 26.336-21.92 4.384 0 8.736 2.944 8.736 7.296 0 1.504 0 4.384-1.44 5.856-5.856 19.04-10.24 36.576-10.24 54.144 0 10.24 1.44 24.832 4.352 33.632 0 1.44 1.504 2.944 2.976 2.944 2.912 0 23.392-18.976 37.984-43.872-13.152-8.8-20.48-23.424-20.48-40.96 0-30.72 19.04-46.816 36.608-46.816 14.624 0 26.336 10.24 26.336 30.72 0 13.152-4.384 27.744-11.68 40.96h4.352l1.056 0.032c9.376 0 17.856-3.936 23.84-10.24a12.448 12.448 0 0 1 5.632-4.96l0.096-0.032c14.304-18.144 35.424-31.584 60.16-31.584 20.48 0 39.424 8.736 40.928 24.832 2.912 21.984-16.128 26.368-21.984 26.368l-0.096-0.096c-5.888 0-16.096-1.504-16.096-7.328s13.184-2.912 11.68-16.032c-1.44-8.8-10.24-11.744-19.04-11.744-29.28 0-48.224 38.016-43.872 68.736 1.44 11.744 7.296 24.864 18.976 24.864 8.8 0 21.984-13.152 27.808-32.16 2.912-11.68 14.624-21.92 24.864-21.92 4.384 0 7.264 1.44 8.736 7.296 0 2.944 0 8.8-5.856 27.808-7.264 13.152-7.296 20.48-5.856 26.336 1.44 11.68 7.296 20.48 13.184 24.864 1.44 1.44 2.912 4.352 2.912 4.352 0 2.944-1.44 5.888-5.856 5.888-1.44 0-2.912 0-4.384-1.504-21.92-8.736-30.72-23.392-33.664-38.016-8.736 10.24-18.976 16.096-30.72 16.096-18.976 0-37.984-17.536-40.96-39.52a68.8 68.8 0 0 1 3.328-28.192l-0.128 0.48c-8.672 5.536-18.016 8.672-26.592 8.672h-7.264c-19.072 27.808-39.552 46.848-54.176 55.584a38.048 38.048 0 0 1-16 4.448h-0.096c-2.912 0-7.296-1.504-8.736-4.448-4.064-6.496-6.656-16.736-8.224-28.448-20.512 22.496-48.864 34.336-61.984 34.336-14.624 0-23.392-8.8-24.832-23.456v-16.032c4.352-32.16 16.096-51.2 16.096-57.056a3.136 3.136 0 0 0-2.944-2.976c-10.24 0-43.872 35.168-49.76 58.592l-4.384 18.976c-2.912 13.184-16.096 21.984-24.832 21.984-4.384 0-7.328-1.504-8.8-7.328v-5.856l1.952-9.952c-18.56 13.216-37.12 21.664-45.856 21.664-13.152 0-20.48-7.328-21.92-17.568-8.8 11.68-18.976 17.568-32.16 17.568-15.008 0-29.696-10.24-36.768-25.312-10.4 11.744-22.304 23.584-36.352 32.608-20.48 13.184-43.872 23.424-71.68 23.424-24.832 0-46.816-13.184-58.496-24.864-17.568-16.096-27.776-40.96-29.28-64.384-8.736-71.68 35.104-163.84 102.4-204.8 16.128-8.736 32.224-14.624 48.288-14.624z m416.832 140.416c-4.448 0-7.328 7.328-7.328 14.624 0 11.68 5.856 24.864 13.184 32.224a72.64 72.64 0 0 0 4.352-24.864c0-14.624-5.856-21.984-10.208-21.984z" fill="#00C4CC" p-id="23500"></path></svg>',
        width: 24,
        height: 24
      },
      processon: {
        body: '<svg t="1716187155553" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="24554" width="24" height="24"><path d="M241.29537297 142.80465793C204.50619412 147.5843544 170.32412243 172.20703316 154.24696159 205.66490841 140.92174722 233.32921219 141.93562222 206.96846199 141.93562222 513.44839287c0 259.11748409 0.14483929 270.55978775 2.75194645 280.26401997C153.66760444 827.74964523 175.97285461 855.41394901 205.66490841 869.75303841c27.66430378 13.32521438 1.30355359 12.31133938 307.78348446 12.31133937 259.11748409 0 270.55978775-0.14483929 280.26401997-2.75194645 34.0372324-8.98003579 61.70153618-31.28528595 76.04062557-60.97733974 13.32521438-27.66430378 12.31133938-1.30355359 12.31133937-307.78348446 0-259.11748409-0.14483929-270.55978775-2.75194644-280.26401997C870.33239556 196.25035477 848.02714539 168.4412117 818.33509159 154.24696159c-27.66430378-13.32521438 0.43451786-12.16650009-301.26571655-12.45617866C370.4920168 141.64594364 246.364748 142.0804615 241.29537297 142.80465793z m158.59901905 177.28328706c36.06498242 6.37292861 62.42573261 19.40846443 87.48292923 43.59662532 25.63655377 24.76751804 42.29307175 56.19764328 50.83858967 96.46296502 3.76582146 17.5255537 5.35905361 60.25314331 2.89678573 80.24096489-11.29746438 92.40746498-66.62607193 152.22609043-152.08125115 164.39259052-19.11878586 2.60710716-54.02505397 1.013875-71.4057684-3.47614289-66.48123264-17.38071443-111.52625084-69.0883398-125.28598308-144.40476894-3.47614289-18.97394658-3.47614289-66.33639336-0.14483928-84.73098278 4.20033931-22.30525017 9.55939293-38.38241101 19.26362514-57.93571472 16.51167869-33.31303597 36.64433956-55.47344685 66.62607193-73.5783577 15.64264297-9.26971435 41.42403603-18.24975014 60.97733975-21.14653587 14.48392868-2.1725893 46.92792893-1.73807144 60.83250046 0.57935715z m360.21530628 104.28428649c29.11269665 6.08325005 53.73537541 27.66430378 65.03283977 56.77700043 8.98003579 23.0294466 8.83519649 21.43621445 9.41455365 124.56178665l0.57935714 94.58005429H765.46875191v-83.71710778c0-91.82810783-0.28967857-95.73876858-8.69035721-112.82980442-7.53164291-15.20812511-19.26362514-22.73976803-38.52725029-24.62267876-21.14653587-2.02775002-43.30694676 11.29746438-53.88021469 32.15432167-5.64873218 11.15262508-6.08325005 19.84298229-6.08325005 106.02235795V700.29107285h-69.23317909l-0.72419643-132.23826885c-0.43451786-72.56448269-1.30355359-133.831501-1.73807144-136.1489296l-1.01387502-3.91066075h30.41625024c27.80914307 0 30.56108952 0.28967857 31.28528595 2.46226787 0.43451786 1.44839287 1.1587143 10.13875008 1.73807143 19.26362515 0.43451786 9.12487507 1.1587143 17.09103584 1.59323216 17.81523227 0.28967857 0.57935715 3.47614289-2.75194645 6.80744648-7.38680361 13.32521438-17.96007157 35.77530383-31.57496453 60.39798259-36.354661 10.13875008-2.02775002 31.57496453-1.73807144 42.29307176 0.57935715z" fill="#067bef" p-id="24555"></path><path d="M342.82771302 376.43042755c-15.49780369 3.76582146-29.11269665 11.87682152-42.29307176 25.34687519-17.5255537 17.67039299-26.79526807 36.49950027-33.60271453 67.49510765-4.05550003 18.68426799-5.06937504 57.64603615-2.02775002 76.33030414 10.71810723 65.46735764 48.08664322 104.2842865 100.80814362 104.57396508 16.80135728 0 26.21591092-2.02775002 41.27919674-9.26971435 39.39628601-18.82910728 61.84637546-66.19155407 61.70153617-130.35535813-0.14483929-49.24535752-14.3390894-87.62776852-42.00339317-113.26432229-11.29746438-10.42842865-23.89848232-17.38071443-37.94789314-20.712018-11.15262508-2.60710716-35.19594669-2.60710716-45.91405391-0.14483929z" fill="#067bef" p-id="24556"></path></svg>',
        width: 24,
        height: 24
      },
      codepen: {
        body: '<svg t="1716187324883" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="25725" id="mx_n_1716187324884" width="24" height="24"><path d="M0 512a512 512 0 1 0 1024 0A512 512 0 1 0 0 512z" fill="#030502" p-id="25726"></path><path d="M840.277 383.595l-312-208a29.333 29.333 0 0 0-32.554 0l-312 208A29.717 29.717 0 0 0 170.667 408v208c0 10.07 5.397 19.35 13.056 24.405l312 208a29.333 29.333 0 0 0 32.554 0l312-208c7.531-4.906 13.056-14.229 13.056-24.405V408c0-9.45-4.842-18.987-13.056-24.405zM541.333 254.827L771.18 408.043l-102.656 68.672-127.19-85.078v-136.81z m-58.666 0v136.81l-127.168 85.078L252.82 408.02l229.846-153.194zM229.333 462.912l73.387 49.067-73.387 49.109v-98.176z m253.334 306.261L252.8 615.957l102.677-68.65 127.147 85.056v136.81zM512 581.397L408.256 512 512 442.603 615.744 512 512 581.397z m29.333 187.776v-136.81l127.19-85.056 102.656 68.65-229.846 153.216z m253.334-208.085L721.28 512l73.387-49.088v98.155z" fill="#FFFFFF" p-id="25727"></path></svg>',
        width: 24,
        height: 24
      },
      jinshuju: {
        body: '<svg t="1716187349707" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="26820" width="24" height="24"><path d="M697.7024 128.5632c-17.8688 10.24-33.28 20.4288-49.5104 32.6144-15.872 12.0832-18.944 14.8992-38.4 34.2016-46.5408 46.6432-69.2224 96.4608-67.6864 149.3504 0.3072 11.4688 0.8704 16.7424 4.096 34.2016 1.3312 6.7584 8.1408 26.7776 12.9536 37.6832 9.9328 22.528 24.832 41.472 35.584 45.0048 13.2096 4.352 38.144 1.1264 63.3856-8.0896 28.9792-10.752 48.64-22.7328 66.0992-40.1408 29.7984-29.7984 44.288-66.6624 44.3904-112.896 0-13.824-2.2528-37.888-4.2496-46.08-0.4096-2.048-1.1264-5.12-1.3824-7.168-3.0208-16.6912-13.5168-49.6128-23.3984-73.8816-7.2704-17.408-23.7056-52.0192-25.3952-53.0432a101.12 101.12 0 0 0-16.4864 8.2432z m-577.28-5.12c0.3072 1.4336 1.024 7.936 1.536 14.6432 0.6144 6.656 1.1776 13.0048 1.4336 14.1824 0.4608 2.0992 1.7408 12.1856 2.8672 20.5312 0.512 4.8128 4.8128 31.0784 5.632 35.4816 24.1664 123.0848 59.5968 201.4208 112.7936 249.344a153.6 153.6 0 0 0 66.6624 34.8672c13.312 3.0208 16.7424 3.2768 31.8976 3.584 28.3648 0.512 66.0992-5.9904 90.368-15.616 30.9248-12.1856 46.3872-28.672 53.4528-56.832 4.608-17.7664 4.7104-19.6096 5.12-48.6912 0.3072-26.112-1.024-40.2944-5.5296-60.7232-6.656-29.6448-31.744-65.0752-59.392-83.8144-28.2624-18.9952-49.408-26.624-141.4656-51.2-47.9232-12.8-133.7344-42.5472-155.5968-54.0672-9.0624-4.8128-10.3424-4.9664-9.728-1.6896z m657.5616 357.9904c-12.9024 1.536-20.2752 2.8672-26.2144 4.4032l-8.3968 2.048c-6.912 1.2288-23.552 10.752-31.0272 17.5616-17.3056 15.872-30.7712 42.0864-37.5808 73.728-4.864 22.272-3.6864 39.9872 3.3792 49.2032 12.1856 16.0256 58.4192 32.256 91.0848 31.7952 35.1744-0.4096 73.0112-25.9584 101.12-68.2496 8.8064-13.0048 22.6816-37.6832 23.3984-41.1136 0-0.4096 1.536-3.9936 3.2768-7.7824 7.3728-16.0256 17.5616-45.6704 16.4352-47.5136a18.7904 18.7904 0 0 0-7.2192-2.1504 94.1056 94.1056 0 0 1-9.5232-1.536c-3.072-0.5632-31.3344-5.8368-37.888-6.9632-22.272-3.84-63.232-5.5296-80.8448-3.4304z m-358.4 40.2944c3.9424-1.9968 16.2816-8.3456 27.2384-14.1824 10.9056-5.632 20.5312-10.496 21.4016-10.496 0.7168-0.1536 13.4656 14.4896 28.3648 32.3584 14.7456 17.8688 28.3648 33.28 30.3616 34.1504 15.616 7.5264 38.144-4.6592 65.6384-35.328 3.1232-3.3792 6.144-5.4784 6.656-4.9152 0.768 0.6656 1.5872 5.2224 2.1504 10.0352 0.4608 4.864 1.1264 10.24 1.4336 12.0832 0.4096 1.8432 1.1264 6.0928 1.536 9.6256l3.4304 24.1152 0.1024 0.8704c2.7136 18.944 2.7136 18.9952-6.656 28.928-27.8016 29.6448-54.5792 71.7824-64.8192 102.2464a254.208 254.208 0 0 0-8.7552 36.0448l-1.4336 11.3152c-1.9968 15.0528-2.9696 41.5744-1.6896 47.5648 2.9696 13.8752 7.2192 21.9648 16.0256 29.6448 10.24 8.9088 23.2448 14.4384 43.8272 18.432 15.872 3.072 62.4128 0.8192 86.3744-4.096 3.84-0.8704 7.2192-1.3312 7.5264-0.8704a18.176 18.176 0 0 1 1.1264 5.2224l1.4336 9.7792c0.4096 2.7136 0.9728 7.2704 1.2288 9.9328 1.5872 12.6464 2.56 19.3024 3.0208 21.2992 0.256 1.1264 1.024 5.632 1.3824 10.0864l0.8704 7.936-202.24 0.256-202.4448 0.1536 1.024-10.24c0.512-5.632 1.28-11.3152 1.4336-12.4416 0.256-1.1264 0.8192-5.9904 1.2288-10.6496l1.536-11.3664a35.0208 35.0208 0 0 0 0.6144-5.12c0.1536-1.9456 1.9968-2.4064 11.9296-2.4064 6.3488 0 13.6192-0.4096 15.872-0.8192 2.4064-0.4096 5.8368-1.1264 7.68-1.536 18.1248-3.584 41.5232-17.7664 56.832-34.3552 6.2464-6.656 22.7328-30.0544 22.7328-32.2048 0-0.256 2.56-5.12 5.632-10.6496 10.8032-19.712 23.8592-55.6032 33.3824-91.648 3.7888-14.2848 4.9152-34.304 2.9696-48.1792a248.6272 248.6272 0 0 0-6.8096-34.7648c-4.5568-18.8416-15.36-52.224-22.4256-69.3248a137.0624 137.0624 0 0 1-4.2496-11.6736c0-0.6656 3.3792-2.816 7.5264-4.8128z m-202.8544 24.9856a217.5488 217.5488 0 0 0-65.0752 17.7152c-17.6128 7.5264-29.696 14.336-29.5424 16.5888 0.3072 4.2496 59.5968 84.1216 72.0896 97.1776 11.776 12.288 27.8016 23.3984 39.2704 27.0848 14.4896 4.6592 32.0512 5.12 48.2304 1.4336 30.5152-7.1168 42.3936-15.616 47.2576-33.9456 1.9456-7.7824 2.0992-38.9632 0.1024-48.896-8.0896-41.2672-27.8016-65.024-61.1328-73.728a155.7504 155.7504 0 0 0-51.2-3.4304z" fill="#FE8432" p-id="26821"></path></svg>',
        width: 24,
        height: 24
      }
    }
  });
}
const CV = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, SV = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, AV = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, EV = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, _V = Qt.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      mi({
        find: CV,
        type: this.type
      }),
      mi({
        find: AV,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: SV,
        type: this.type
      }),
      Er({
        find: EV,
        type: this.type
      })
    ];
  }
}), cJ = _V.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: ye,
        componentProps: {
          action: () => e.commands.toggleBold(),
          isActive: () => e.isActive("bold") || !1,
          disabled: !e.can().toggleBold(),
          icon: "Bold",
          shortcutKeys: ["mod", "B"],
          tooltip: n("editor.bold.tooltip")
        }
      })
    };
  }
}), MV = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, TV = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, OV = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, IV = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, DV = Qt.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      mi({
        find: MV,
        type: this.type
      }),
      mi({
        find: OV,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: TV,
        type: this.type
      }),
      Er({
        find: IV,
        type: this.type
      })
    ];
  }
}), dJ = DV.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, t: n }) {
        return {
          component: ye,
          componentProps: {
            action: () => e.commands.toggleItalic(),
            isActive: () => e.isActive("italic") || !1,
            disabled: !e.can().toggleItalic(),
            shortcutKeys: ["mod", "I"],
            icon: "Italic",
            tooltip: n("editor.italic.tooltip")
          }
        };
      }
    };
  }
}), RV = Qt.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), uJ = RV.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, t: n }) {
        return {
          component: ye,
          componentProps: {
            action: () => e.commands.toggleUnderline(),
            isActive: () => e.isActive("underline") || !1,
            disabled: !e.can().toggleUnderline(),
            icon: "Underline",
            shortcutKeys: ["mod", "U"],
            tooltip: n("editor.underline.tooltip")
          }
        };
      }
    };
  }
}), PV = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, LV = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, NV = Qt.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      mi({
        find: PV,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: LV,
        type: this.type
      })
    ];
  }
}), fJ = NV.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: ye,
        componentProps: {
          action: () => e.commands.toggleStrike(),
          isActive: () => e.isActive("strike") || !1,
          disabled: !e.can().toggleStrike(),
          icon: "Strikethrough",
          shortcutKeys: ["shift", "mod", "X"],
          tooltip: n("editor.strike.tooltip")
        }
      })
    };
  }
}), BV = /(^|[^`])`([^`]+)`(?!`)/, $V = /(^|[^`])`([^`]+)`(?!`)/g, zV = Qt.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      mi({
        find: BV,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: $V,
        type: this.type
      })
    ];
  }
}), pJ = zV.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      toolbar: !1,
      button: ({ editor: e, t: n }) => ({
        component: ye,
        componentProps: {
          action: () => e.commands.toggleCode(),
          isActive: () => e.isActive("code") || !1,
          disabled: !e.can().toggleCode(),
          icon: "Code",
          shortcutKeys: ["mod", "E"],
          tooltip: n("editor.code.tooltip")
        }
      })
    };
  }
}), FV = /^```([a-z]+)?[\s\n]$/, HV = /^~~~([a-z]+)?[\s\n]$/, VV = ot.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options, i = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
          return i || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      He(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: o, empty: r } = n;
        if (!r || o.parent.type !== this.type)
          return !1;
        const i = o.parentOffset === o.parent.nodeSize - 2, s = o.parent.textContent.endsWith(`

`);
        return !i || !s ? !1 : t.chain().command(({ tr: a }) => (a.delete(o.pos - 2, o.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: o } = e, { $from: r, empty: i } = n;
        if (!i || r.parent.type !== this.type || !(r.parentOffset === r.parent.nodeSize - 2))
          return !1;
        const a = r.after();
        return a === void 0 ? !1 : o.nodeAt(a) ? t.commands.command(({ tr: c }) => (c.setSelection(pe.near(o.resolve(a))), !0)) : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      jp({
        find: FV,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      jp({
        find: HV,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Ne({
        key: new Be("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), o = e.clipboardData.getData("vscode-editor-data"), r = o ? JSON.parse(o) : void 0, i = r == null ? void 0 : r.mode;
            if (!n || !i)
              return !1;
            const { tr: s, schema: a } = t.state, l = a.text(n.replace(/\r\n?/g, `
`));
            return s.replaceSelectionWith(this.type.create({ language: i }, l)), s.selection.$from.parent.type !== this.type && s.setSelection(le.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", !0), t.dispatch(s), !0;
          }
        }
      })
    ];
  }
});
function jV(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function d6(t) {
  return t instanceof Map ? t.clear = t.delete = t.set = function() {
    throw new Error("map is read-only");
  } : t instanceof Set && (t.add = t.clear = t.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(t), Object.getOwnPropertyNames(t).forEach((e) => {
    const n = t[e], o = typeof n;
    (o === "object" || o === "function") && !Object.isFrozen(n) && d6(n);
  }), t;
}
class zy {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function u6(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function br(t, ...e) {
  const n = /* @__PURE__ */ Object.create(null);
  for (const o in t)
    n[o] = t[o];
  return e.forEach(function(o) {
    for (const r in o)
      n[r] = o[r];
  }), /** @type {T} */
  n;
}
const UV = "</span>", Fy = (t) => !!t.scope, WV = (t, { prefix: e }) => {
  if (t.startsWith("language:"))
    return t.replace("language:", "language-");
  if (t.includes(".")) {
    const n = t.split(".");
    return [
      `${e}${n.shift()}`,
      ...n.map((o, r) => `${o}${"_".repeat(r + 1)}`)
    ].join(" ");
  }
  return `${e}${t}`;
};
class KV {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, n) {
    this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += u6(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!Fy(e))
      return;
    const n = WV(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(n);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    Fy(e) && (this.buffer += UV);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const Hy = (t = {}) => {
  const e = { children: [] };
  return Object.assign(e, t), e;
};
class Xg {
  constructor() {
    this.rootNode = Hy(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const n = Hy({ scope: e });
    this.add(n), this.stack.push(n);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, n) {
    return typeof n == "string" ? e.addText(n) : n.children && (e.openNode(n), n.children.forEach((o) => this._walk(e, o)), e.closeNode(n)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((n) => typeof n == "string") ? e.children = [e.children.join("")] : e.children.forEach((n) => {
      Xg._collapse(n);
    }));
  }
}
class qV extends Xg {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, n) {
    const o = e.root;
    n && (o.scope = `language:${n}`), this.add(o);
  }
  toHTML() {
    return new KV(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), !0;
  }
}
function ul(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function f6(t) {
  return Oi("(?=", t, ")");
}
function GV(t) {
  return Oi("(?:", t, ")*");
}
function JV(t) {
  return Oi("(?:", t, ")?");
}
function Oi(...t) {
  return t.map((n) => ul(n)).join("");
}
function YV(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function Zg(...t) {
  return "(" + (YV(t).capture ? "" : "?:") + t.map((o) => ul(o)).join("|") + ")";
}
function p6(t) {
  return new RegExp(t.toString() + "|").exec("").length - 1;
}
function XV(t, e) {
  const n = t && t.exec(e);
  return n && n.index === 0;
}
const ZV = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Qg(t, { joinWith: e }) {
  let n = 0;
  return t.map((o) => {
    n += 1;
    const r = n;
    let i = ul(o), s = "";
    for (; i.length > 0; ) {
      const a = ZV.exec(i);
      if (!a) {
        s += i;
        break;
      }
      s += i.substring(0, a.index), i = i.substring(a.index + a[0].length), a[0][0] === "\\" && a[1] ? s += "\\" + String(Number(a[1]) + r) : (s += a[0], a[0] === "(" && n++);
    }
    return s;
  }).map((o) => `(${o})`).join(e);
}
const QV = /\b\B/, h6 = "[a-zA-Z]\\w*", e0 = "[a-zA-Z_]\\w*", m6 = "\\b\\d+(\\.\\d+)?", g6 = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", v6 = "\\b(0b[01]+)", ej = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", tj = (t = {}) => {
  const e = /^#![ ]*\//;
  return t.binary && (t.begin = Oi(
    e,
    /.*\b/,
    t.binary,
    /\b.*/
  )), br({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (n, o) => {
      n.index !== 0 && o.ignoreMatch();
    }
  }, t);
}, fl = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, nj = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [fl]
}, oj = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [fl]
}, rj = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, Qu = function(t, e, n = {}) {
  const o = br(
    {
      scope: "comment",
      begin: t,
      end: e,
      contains: []
    },
    n
  );
  o.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const r = Zg(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return o.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: Oi(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        r,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), o;
}, ij = Qu("//", "$"), sj = Qu("/\\*", "\\*/"), aj = Qu("#", "$"), lj = {
  scope: "number",
  begin: m6,
  relevance: 0
}, cj = {
  scope: "number",
  begin: g6,
  relevance: 0
}, dj = {
  scope: "number",
  begin: v6,
  relevance: 0
}, uj = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    fl,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [fl]
    }
  ]
}, fj = {
  scope: "title",
  begin: h6,
  relevance: 0
}, pj = {
  scope: "title",
  begin: e0,
  relevance: 0
}, hj = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + e0,
  relevance: 0
}, mj = function(t) {
  return Object.assign(
    t,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, n) => {
        n.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, n) => {
        n.data._beginMatch !== e[1] && n.ignoreMatch();
      }
    }
  );
};
var gc = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: nj,
  BACKSLASH_ESCAPE: fl,
  BINARY_NUMBER_MODE: dj,
  BINARY_NUMBER_RE: v6,
  COMMENT: Qu,
  C_BLOCK_COMMENT_MODE: sj,
  C_LINE_COMMENT_MODE: ij,
  C_NUMBER_MODE: cj,
  C_NUMBER_RE: g6,
  END_SAME_AS_BEGIN: mj,
  HASH_COMMENT_MODE: aj,
  IDENT_RE: h6,
  MATCH_NOTHING_RE: QV,
  METHOD_GUARD: hj,
  NUMBER_MODE: lj,
  NUMBER_RE: m6,
  PHRASAL_WORDS_MODE: rj,
  QUOTE_STRING_MODE: oj,
  REGEXP_MODE: uj,
  RE_STARTERS_RE: ej,
  SHEBANG: tj,
  TITLE_MODE: fj,
  UNDERSCORE_IDENT_RE: e0,
  UNDERSCORE_TITLE_MODE: pj
});
function gj(t, e) {
  t.input[t.index - 1] === "." && e.ignoreMatch();
}
function vj(t, e) {
  t.className !== void 0 && (t.scope = t.className, delete t.className);
}
function yj(t, e) {
  e && t.beginKeywords && (t.begin = "\\b(" + t.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", t.__beforeBegin = gj, t.keywords = t.keywords || t.beginKeywords, delete t.beginKeywords, t.relevance === void 0 && (t.relevance = 0));
}
function bj(t, e) {
  Array.isArray(t.illegal) && (t.illegal = Zg(...t.illegal));
}
function wj(t, e) {
  if (t.match) {
    if (t.begin || t.end)
      throw new Error("begin & end are not supported with match");
    t.begin = t.match, delete t.match;
  }
}
function xj(t, e) {
  t.relevance === void 0 && (t.relevance = 1);
}
const kj = (t, e) => {
  if (!t.beforeMatch)
    return;
  if (t.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const n = Object.assign({}, t);
  Object.keys(t).forEach((o) => {
    delete t[o];
  }), t.keywords = n.keywords, t.begin = Oi(n.beforeMatch, f6(n.begin)), t.starts = {
    relevance: 0,
    contains: [
      Object.assign(n, { endsParent: !0 })
    ]
  }, t.relevance = 0, delete n.beforeMatch;
}, Cj = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], Sj = "keyword";
function y6(t, e, n = Sj) {
  const o = /* @__PURE__ */ Object.create(null);
  return typeof t == "string" ? r(n, t.split(" ")) : Array.isArray(t) ? r(n, t) : Object.keys(t).forEach(function(i) {
    Object.assign(
      o,
      y6(t[i], e, i)
    );
  }), o;
  function r(i, s) {
    e && (s = s.map((a) => a.toLowerCase())), s.forEach(function(a) {
      const l = a.split("|");
      o[l[0]] = [i, Aj(l[0], l[1])];
    });
  }
}
function Aj(t, e) {
  return e ? Number(e) : Ej(t) ? 0 : 1;
}
function Ej(t) {
  return Cj.includes(t.toLowerCase());
}
const Vy = {}, di = (t) => {
  console.error(t);
}, jy = (t, ...e) => {
  console.log(`WARN: ${t}`, ...e);
}, Hi = (t, e) => {
  Vy[`${t}/${e}`] || (console.log(`Deprecated as of ${t}. ${e}`), Vy[`${t}/${e}`] = !0);
}, kd = new Error();
function b6(t, e, { key: n }) {
  let o = 0;
  const r = t[n], i = {}, s = {};
  for (let a = 1; a <= e.length; a++)
    s[a + o] = r[a], i[a + o] = !0, o += p6(e[a - 1]);
  t[n] = s, t[n]._emit = i, t[n]._multi = !0;
}
function _j(t) {
  if (Array.isArray(t.begin)) {
    if (t.skip || t.excludeBegin || t.returnBegin)
      throw di("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), kd;
    if (typeof t.beginScope != "object" || t.beginScope === null)
      throw di("beginScope must be object"), kd;
    b6(t, t.begin, { key: "beginScope" }), t.begin = Qg(t.begin, { joinWith: "" });
  }
}
function Mj(t) {
  if (Array.isArray(t.end)) {
    if (t.skip || t.excludeEnd || t.returnEnd)
      throw di("skip, excludeEnd, returnEnd not compatible with endScope: {}"), kd;
    if (typeof t.endScope != "object" || t.endScope === null)
      throw di("endScope must be object"), kd;
    b6(t, t.end, { key: "endScope" }), t.end = Qg(t.end, { joinWith: "" });
  }
}
function Tj(t) {
  t.scope && typeof t.scope == "object" && t.scope !== null && (t.beginScope = t.scope, delete t.scope);
}
function Oj(t) {
  Tj(t), typeof t.beginScope == "string" && (t.beginScope = { _wrap: t.beginScope }), typeof t.endScope == "string" && (t.endScope = { _wrap: t.endScope }), _j(t), Mj(t);
}
function Ij(t) {
  function e(s, a) {
    return new RegExp(
      ul(s),
      "m" + (t.case_insensitive ? "i" : "") + (t.unicodeRegex ? "u" : "") + (a ? "g" : "")
    );
  }
  class n {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, a]), this.matchAt += p6(a) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const a = this.regexes.map((l) => l[1]);
      this.matcherRe = e(Qg(a, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(a) {
      this.matcherRe.lastIndex = this.lastIndex;
      const l = this.matcherRe.exec(a);
      if (!l)
        return null;
      const c = l.findIndex((u, f) => f > 0 && u !== void 0), d = this.matchIndexes[c];
      return l.splice(0, c), Object.assign(l, d);
    }
  }
  class o {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(a) {
      if (this.multiRegexes[a])
        return this.multiRegexes[a];
      const l = new n();
      return this.rules.slice(a).forEach(([c, d]) => l.addRule(c, d)), l.compile(), this.multiRegexes[a] = l, l;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(a, l) {
      this.rules.push([a, l]), l.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(a) {
      const l = this.getMatcher(this.regexIndex);
      l.lastIndex = this.lastIndex;
      let c = l.exec(a);
      if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) {
        const d = this.getMatcher(0);
        d.lastIndex = this.lastIndex + 1, c = d.exec(a);
      }
      return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c;
    }
  }
  function r(s) {
    const a = new o();
    return s.contains.forEach((l) => a.addRule(l.begin, { rule: l, type: "begin" })), s.terminatorEnd && a.addRule(s.terminatorEnd, { type: "end" }), s.illegal && a.addRule(s.illegal, { type: "illegal" }), a;
  }
  function i(s, a) {
    const l = (
      /** @type CompiledMode */
      s
    );
    if (s.isCompiled)
      return l;
    [
      vj,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      wj,
      Oj,
      kj
    ].forEach((d) => d(s, a)), t.compilerExtensions.forEach((d) => d(s, a)), s.__beforeBegin = null, [
      yj,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      bj,
      // default to 1 relevance if not specified
      xj
    ].forEach((d) => d(s, a)), s.isCompiled = !0;
    let c = null;
    return typeof s.keywords == "object" && s.keywords.$pattern && (s.keywords = Object.assign({}, s.keywords), c = s.keywords.$pattern, delete s.keywords.$pattern), c = c || /\w+/, s.keywords && (s.keywords = y6(s.keywords, t.case_insensitive)), l.keywordPatternRe = e(c, !0), a && (s.begin || (s.begin = /\B|\b/), l.beginRe = e(l.begin), !s.end && !s.endsWithParent && (s.end = /\B|\b/), s.end && (l.endRe = e(l.end)), l.terminatorEnd = ul(l.end) || "", s.endsWithParent && a.terminatorEnd && (l.terminatorEnd += (s.end ? "|" : "") + a.terminatorEnd)), s.illegal && (l.illegalRe = e(
      /** @type {RegExp | string} */
      s.illegal
    )), s.contains || (s.contains = []), s.contains = [].concat(...s.contains.map(function(d) {
      return Dj(d === "self" ? s : d);
    })), s.contains.forEach(function(d) {
      i(
        /** @type Mode */
        d,
        l
      );
    }), s.starts && i(s.starts, a), l.matcher = r(l), l;
  }
  if (t.compilerExtensions || (t.compilerExtensions = []), t.contains && t.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return t.classNameAliases = br(t.classNameAliases || {}), i(
    /** @type Mode */
    t
  );
}
function w6(t) {
  return t ? t.endsWithParent || w6(t.starts) : !1;
}
function Dj(t) {
  return t.variants && !t.cachedVariants && (t.cachedVariants = t.variants.map(function(e) {
    return br(t, { variants: null }, e);
  })), t.cachedVariants ? t.cachedVariants : w6(t) ? br(t, { starts: t.starts ? br(t.starts) : null }) : Object.isFrozen(t) ? br(t) : t;
}
var Rj = "11.10.0";
class Pj extends Error {
  constructor(e, n) {
    super(e), this.name = "HTMLInjectionError", this.html = n;
  }
}
const lp = u6, Uy = br, Wy = Symbol("nomatch"), Lj = 7, x6 = function(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), o = [];
  let r = !0;
  const i = "Could not find the language '{}', did you forget to load/include a language module?", s = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let a = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: qV
  };
  function l(R) {
    return a.noHighlightRe.test(R);
  }
  function c(R) {
    let H = R.className + " ";
    H += R.parentNode ? R.parentNode.className : "";
    const K = a.languageDetectRe.exec(H);
    if (K) {
      const Q = N(K[1]);
      return Q || (jy(i.replace("{}", K[1])), jy("Falling back to no-highlight mode for this block.", R)), Q ? K[1] : "no-highlight";
    }
    return H.split(/\s+/).find((Q) => l(Q) || N(Q));
  }
  function d(R, H, K) {
    let Q = "", Z = "";
    typeof H == "object" ? (Q = R, K = H.ignoreIllegals, Z = H.language) : (Hi("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Hi("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), Z = R, Q = H), K === void 0 && (K = !0);
    const ue = {
      code: Q,
      language: Z
    };
    ne("before:highlight", ue);
    const Se = ue.result ? ue.result : u(ue.language, ue.code, K);
    return Se.code = ue.code, ne("after:highlight", Se), Se;
  }
  function u(R, H, K, Q) {
    const Z = /* @__PURE__ */ Object.create(null);
    function ue(te, re) {
      return te.keywords[re];
    }
    function Se() {
      if (!me.keywords) {
        tt.addText(je);
        return;
      }
      let te = 0;
      me.keywordPatternRe.lastIndex = 0;
      let re = me.keywordPatternRe.exec(je), ke = "";
      for (; re; ) {
        ke += je.substring(te, re.index);
        const Ue = Lt.case_insensitive ? re[0].toLowerCase() : re[0], bt = ue(me, Ue);
        if (bt) {
          const [Pn, nf] = bt;
          if (tt.addText(ke), ke = "", Z[Ue] = (Z[Ue] || 0) + 1, Z[Ue] <= Lj && (vn += nf), Pn.startsWith("_"))
            ke += re[0];
          else {
            const V = Lt.classNameAliases[Pn] || Pn;
            Re(re[0], V);
          }
        } else
          ke += re[0];
        te = me.keywordPatternRe.lastIndex, re = me.keywordPatternRe.exec(je);
      }
      ke += je.substring(te), tt.addText(ke);
    }
    function be() {
      if (je === "")
        return;
      let te = null;
      if (typeof me.subLanguage == "string") {
        if (!e[me.subLanguage]) {
          tt.addText(je);
          return;
        }
        te = u(me.subLanguage, je, !0, gn[me.subLanguage]), gn[me.subLanguage] = /** @type {CompiledMode} */
        te._top;
      } else
        te = h(je, me.subLanguage.length ? me.subLanguage : null);
      me.relevance > 0 && (vn += te.relevance), tt.__addSublanguage(te._emitter, te.language);
    }
    function we() {
      me.subLanguage != null ? be() : Se(), je = "";
    }
    function Re(te, re) {
      te !== "" && (tt.startScope(re), tt.addText(te), tt.endScope());
    }
    function Ie(te, re) {
      let ke = 1;
      const Ue = re.length - 1;
      for (; ke <= Ue; ) {
        if (!te._emit[ke]) {
          ke++;
          continue;
        }
        const bt = Lt.classNameAliases[te[ke]] || te[ke], Pn = re[ke];
        bt ? Re(Pn, bt) : (je = Pn, Se(), je = ""), ke++;
      }
    }
    function Ge(te, re) {
      return te.scope && typeof te.scope == "string" && tt.openNode(Lt.classNameAliases[te.scope] || te.scope), te.beginScope && (te.beginScope._wrap ? (Re(je, Lt.classNameAliases[te.beginScope._wrap] || te.beginScope._wrap), je = "") : te.beginScope._multi && (Ie(te.beginScope, re), je = "")), me = Object.create(te, { parent: { value: me } }), me;
    }
    function gt(te, re, ke) {
      let Ue = XV(te.endRe, ke);
      if (Ue) {
        if (te["on:end"]) {
          const bt = new zy(te);
          te["on:end"](re, bt), bt.isMatchIgnored && (Ue = !1);
        }
        if (Ue) {
          for (; te.endsParent && te.parent; )
            te = te.parent;
          return te;
        }
      }
      if (te.endsWithParent)
        return gt(te.parent, re, ke);
    }
    function We(te) {
      return me.matcher.regexIndex === 0 ? (je += te[0], 1) : (Zo = !0, 0);
    }
    function Ft(te) {
      const re = te[0], ke = te.rule, Ue = new zy(ke), bt = [ke.__beforeBegin, ke["on:begin"]];
      for (const Pn of bt)
        if (Pn && (Pn(te, Ue), Ue.isMatchIgnored))
          return We(re);
      return ke.skip ? je += re : (ke.excludeBegin && (je += re), we(), !ke.returnBegin && !ke.excludeBegin && (je = re)), Ge(ke, te), ke.returnBegin ? 0 : re.length;
    }
    function mn(te) {
      const re = te[0], ke = H.substring(te.index), Ue = gt(me, te, ke);
      if (!Ue)
        return Wy;
      const bt = me;
      me.endScope && me.endScope._wrap ? (we(), Re(re, me.endScope._wrap)) : me.endScope && me.endScope._multi ? (we(), Ie(me.endScope, te)) : bt.skip ? je += re : (bt.returnEnd || bt.excludeEnd || (je += re), we(), bt.excludeEnd && (je = re));
      do
        me.scope && tt.closeNode(), !me.skip && !me.subLanguage && (vn += me.relevance), me = me.parent;
      while (me !== Ue.parent);
      return Ue.starts && Ge(Ue.starts, te), bt.returnEnd ? 0 : re.length;
    }
    function Rn() {
      const te = [];
      for (let re = me; re !== Lt; re = re.parent)
        re.scope && te.unshift(re.scope);
      te.forEach((re) => tt.openNode(re));
    }
    let go = {};
    function Ur(te, re) {
      const ke = re && re[0];
      if (je += te, ke == null)
        return we(), 0;
      if (go.type === "begin" && re.type === "end" && go.index === re.index && ke === "") {
        if (je += H.slice(re.index, re.index + 1), !r) {
          const Ue = new Error(`0 width match regex (${R})`);
          throw Ue.languageName = R, Ue.badRule = go.rule, Ue;
        }
        return 1;
      }
      if (go = re, re.type === "begin")
        return Ft(re);
      if (re.type === "illegal" && !K) {
        const Ue = new Error('Illegal lexeme "' + ke + '" for mode "' + (me.scope || "<unnamed>") + '"');
        throw Ue.mode = me, Ue;
      } else if (re.type === "end") {
        const Ue = mn(re);
        if (Ue !== Wy)
          return Ue;
      }
      if (re.type === "illegal" && ke === "")
        return 1;
      if (Xo > 1e5 && Xo > re.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return je += ke, ke.length;
    }
    const Lt = N(R);
    if (!Lt)
      throw di(i.replace("{}", R)), new Error('Unknown language: "' + R + '"');
    const Wr = Ij(Lt);
    let Yo = "", me = Q || Wr;
    const gn = {}, tt = new a.__emitter(a);
    Rn();
    let je = "", vn = 0, tn = 0, Xo = 0, Zo = !1;
    try {
      if (Lt.__emitTokens)
        Lt.__emitTokens(H, tt);
      else {
        for (me.matcher.considerAll(); ; ) {
          Xo++, Zo ? Zo = !1 : me.matcher.considerAll(), me.matcher.lastIndex = tn;
          const te = me.matcher.exec(H);
          if (!te)
            break;
          const re = H.substring(tn, te.index), ke = Ur(re, te);
          tn = te.index + ke;
        }
        Ur(H.substring(tn));
      }
      return tt.finalize(), Yo = tt.toHTML(), {
        language: R,
        value: Yo,
        relevance: vn,
        illegal: !1,
        _emitter: tt,
        _top: me
      };
    } catch (te) {
      if (te.message && te.message.includes("Illegal"))
        return {
          language: R,
          value: lp(H),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: te.message,
            index: tn,
            context: H.slice(tn - 100, tn + 100),
            mode: te.mode,
            resultSoFar: Yo
          },
          _emitter: tt
        };
      if (r)
        return {
          language: R,
          value: lp(H),
          illegal: !1,
          relevance: 0,
          errorRaised: te,
          _emitter: tt,
          _top: me
        };
      throw te;
    }
  }
  function f(R) {
    const H = {
      value: lp(R),
      illegal: !1,
      relevance: 0,
      _top: s,
      _emitter: new a.__emitter(a)
    };
    return H._emitter.addText(R), H;
  }
  function h(R, H) {
    H = H || a.languages || Object.keys(e);
    const K = f(R), Q = H.filter(N).filter($).map(
      (we) => u(we, R, !1)
    );
    Q.unshift(K);
    const Z = Q.sort((we, Re) => {
      if (we.relevance !== Re.relevance)
        return Re.relevance - we.relevance;
      if (we.language && Re.language) {
        if (N(we.language).supersetOf === Re.language)
          return 1;
        if (N(Re.language).supersetOf === we.language)
          return -1;
      }
      return 0;
    }), [ue, Se] = Z, be = ue;
    return be.secondBest = Se, be;
  }
  function m(R, H, K) {
    const Q = H && n[H] || K;
    R.classList.add("hljs"), R.classList.add(`language-${Q}`);
  }
  function g(R) {
    let H = null;
    const K = c(R);
    if (l(K))
      return;
    if (ne(
      "before:highlightElement",
      { el: R, language: K }
    ), R.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", R);
      return;
    }
    if (R.children.length > 0 && (a.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(R)), a.throwUnescapedHTML))
      throw new Pj(
        "One of your code blocks includes unescaped HTML.",
        R.innerHTML
      );
    H = R;
    const Q = H.textContent, Z = K ? d(Q, { language: K, ignoreIllegals: !0 }) : h(Q);
    R.innerHTML = Z.value, R.dataset.highlighted = "yes", m(R, K, Z.language), R.result = {
      language: Z.language,
      // TODO: remove with version 11.0
      re: Z.relevance,
      relevance: Z.relevance
    }, Z.secondBest && (R.secondBest = {
      language: Z.secondBest.language,
      relevance: Z.secondBest.relevance
    }), ne("after:highlightElement", { el: R, result: Z, text: Q });
  }
  function v(R) {
    a = Uy(a, R);
  }
  const y = () => {
    b(), Hi("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function x() {
    b(), Hi("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let C = !1;
  function b() {
    if (document.readyState === "loading") {
      C = !0;
      return;
    }
    document.querySelectorAll(a.cssSelector).forEach(g);
  }
  function S() {
    C && b();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", S, !1);
  function A(R, H) {
    let K = null;
    try {
      K = H(t);
    } catch (Q) {
      if (di("Language definition for '{}' could not be registered.".replace("{}", R)), r)
        di(Q);
      else
        throw Q;
      K = s;
    }
    K.name || (K.name = R), e[R] = K, K.rawDefinition = H.bind(null, t), K.aliases && M(K.aliases, { languageName: R });
  }
  function I(R) {
    delete e[R];
    for (const H of Object.keys(n))
      n[H] === R && delete n[H];
  }
  function z() {
    return Object.keys(e);
  }
  function N(R) {
    return R = (R || "").toLowerCase(), e[R] || e[n[R]];
  }
  function M(R, { languageName: H }) {
    typeof R == "string" && (R = [R]), R.forEach((K) => {
      n[K.toLowerCase()] = H;
    });
  }
  function $(R) {
    const H = N(R);
    return H && !H.disableAutodetect;
  }
  function L(R) {
    R["before:highlightBlock"] && !R["before:highlightElement"] && (R["before:highlightElement"] = (H) => {
      R["before:highlightBlock"](
        Object.assign({ block: H.el }, H)
      );
    }), R["after:highlightBlock"] && !R["after:highlightElement"] && (R["after:highlightElement"] = (H) => {
      R["after:highlightBlock"](
        Object.assign({ block: H.el }, H)
      );
    });
  }
  function Y(R) {
    L(R), o.push(R);
  }
  function J(R) {
    const H = o.indexOf(R);
    H !== -1 && o.splice(H, 1);
  }
  function ne(R, H) {
    const K = R;
    o.forEach(function(Q) {
      Q[K] && Q[K](H);
    });
  }
  function F(R) {
    return Hi("10.7.0", "highlightBlock will be removed entirely in v12.0"), Hi("10.7.0", "Please use highlightElement now."), g(R);
  }
  Object.assign(t, {
    highlight: d,
    highlightAuto: h,
    highlightAll: b,
    highlightElement: g,
    // TODO: Remove with v12 API
    highlightBlock: F,
    configure: v,
    initHighlighting: y,
    initHighlightingOnLoad: x,
    registerLanguage: A,
    unregisterLanguage: I,
    listLanguages: z,
    getLanguage: N,
    registerAliases: M,
    autoDetection: $,
    inherit: Uy,
    addPlugin: Y,
    removePlugin: J
  }), t.debugMode = function() {
    r = !1;
  }, t.safeMode = function() {
    r = !0;
  }, t.versionString = Rj, t.regex = {
    concat: Oi,
    lookahead: f6,
    either: Zg,
    optional: JV,
    anyNumberOfTimes: GV
  };
  for (const R in gc)
    typeof gc[R] == "object" && d6(gc[R]);
  return Object.assign(t, gc), t;
}, xs = x6({});
xs.newInstance = () => x6({});
var Nj = xs;
xs.HighlightJS = xs;
xs.default = xs;
var Bj = /* @__PURE__ */ jV(Nj);
function k6(t, e = []) {
  return t.map((n) => {
    const o = [...e, ...n.properties ? n.properties.className : []];
    return n.children ? k6(n.children, o) : {
      text: n.value,
      classes: o
    };
  }).flat();
}
function Ky(t) {
  return t.value || t.children || [];
}
function $j(t) {
  return !!Bj.getLanguage(t);
}
function qy({ doc: t, name: e, lowlight: n, defaultLanguage: o }) {
  const r = [];
  return Fp(t, (i) => i.type.name === e).forEach((i) => {
    var s;
    let a = i.pos + 1;
    const l = i.node.attrs.language || o, c = n.listLanguages(), d = l && (c.includes(l) || $j(l) || !((s = n.registered) === null || s === void 0) && s.call(n, l)) ? Ky(n.highlight(l, i.node.textContent)) : Ky(n.highlightAuto(i.node.textContent));
    k6(d).forEach((u) => {
      const f = a + u.text.length;
      if (u.classes.length) {
        const h = ht.inline(a, f, {
          class: u.classes.join(" ")
        });
        r.push(h);
      }
      a = f;
    });
  }), ze.create(t, r);
}
function zj(t) {
  return typeof t == "function";
}
function Fj({ name: t, lowlight: e, defaultLanguage: n }) {
  if (!["highlight", "highlightAuto", "listLanguages"].every((r) => zj(e[r])))
    throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
  const o = new Ne({
    key: new Be("lowlight"),
    state: {
      init: (r, { doc: i }) => qy({
        doc: i,
        name: t,
        lowlight: e,
        defaultLanguage: n
      }),
      apply: (r, i, s, a) => {
        const l = s.selection.$head.parent.type.name, c = a.selection.$head.parent.type.name, d = Fp(s.doc, (f) => f.type.name === t), u = Fp(a.doc, (f) => f.type.name === t);
        return r.docChanged && ([l, c].includes(t) || u.length !== d.length || r.steps.some((f) => (
          // @ts-ignore
          f.from !== void 0 && f.to !== void 0 && d.some((h) => (
            // @ts-ignore
            h.pos >= f.from && h.pos + h.node.nodeSize <= f.to
          ))
        ))) ? qy({
          doc: r.doc,
          name: t,
          lowlight: e,
          defaultLanguage: n
        }) : i.map(r.mapping, r.doc);
      }
    },
    props: {
      decorations(r) {
        return o.getState(r);
      }
    }
  });
  return o;
}
const Hj = VV.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) === null || t === void 0 ? void 0 : t.call(this),
      lowlight: {},
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  addProseMirrorPlugins() {
    var t;
    return [
      ...((t = this.parent) === null || t === void 0 ? void 0 : t.call(this)) || [],
      Fj({
        name: this.name,
        lowlight: this.options.lowlight,
        defaultLanguage: this.options.defaultLanguage
      })
    ];
  }
}), Vj = /* @__PURE__ */ T({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(EP), j(n.value, {
      class: p(fe)("-mx-1 my-1 h-px bg-muted", e.class)
    }), null, 16, ["class"]));
  }
}), jj = /* @__PURE__ */ T({
  __name: "Select",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: {},
    dir: {},
    name: {},
    autocomplete: {},
    disabled: { type: Boolean },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(t, { emit: e }) {
    const r = De(t, e);
    return (i, s) => (k(), _(p(pP), Oe(Le(p(r))), {
      default: w(() => [
        D(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Uj = /* @__PURE__ */ T({
  __name: "SelectValue",
  props: {
    placeholder: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(NP), Oe(Le(e)), {
      default: w(() => [
        D(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Wj = /* @__PURE__ */ T({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(gP), j(p(o), {
      class: p(fe)(
        "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:truncate text-start",
        e.class
      )
    }), {
      default: w(() => [
        D(r.$slots, "default"),
        E(p(BP), { "as-child": "" }, {
          default: w(() => [
            E(p(MN), { class: "w-4 h-4 opacity-50 shrink-0" })
          ]),
          _: 1
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Kj = /* @__PURE__ */ T({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(t, { emit: e }) {
    const n = t, o = e, r = P(() => {
      const { class: s, ...a } = n;
      return a;
    }), i = De(r, o);
    return (s, a) => (k(), _(p(vP), null, {
      default: w(() => [
        E(p(AP), j({ ...p(i), ...s.$attrs }, {
          class: p(fe)(
            "relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            s.position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
            n.class
          )
        }), {
          default: w(() => [
            E(p(Jj)),
            E(p(RP), {
              class: Ze(p(fe)("p-1", s.position === "popper" && "h-[--radix-select-trigger-height] w-full min-w-[--radix-select-trigger-width]"))
            }, {
              default: w(() => [
                D(s.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            E(p(Yj))
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), qj = /* @__PURE__ */ T({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(IP), j({
      class: p(fe)("p-1 w-full", e.class)
    }, n.value), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Gj = { class: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center" }, Gy = /* @__PURE__ */ T({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(MP), j(p(o), {
      class: p(fe)(
        "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.class
      )
    }), {
      default: w(() => [
        B("span", Gj, [
          E(p(TP), null, {
            default: w(() => [
              E(p(Vu), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        E(p(DP), null, {
          default: w(() => [
            D(r.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Jj = /* @__PURE__ */ T({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(PP), j(p(o), {
      class: p(fe)("flex cursor-default items-center justify-center py-1", e.class)
    }), {
      default: w(() => [
        D(r.$slots, "default", {}, () => [
          E(p(IN))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Yj = /* @__PURE__ */ T({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: r, ...i } = e;
      return i;
    }), o = _t(n);
    return (r, i) => (k(), _(p(LP), j(p(o), {
      class: p(fe)("flex cursor-default items-center justify-center py-1", e.class)
    }), {
      default: w(() => [
        D(r.$slots, "default", {}, () => [
          E(p(TN))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Xj = /* @__PURE__ */ T({
  __name: "CodeBlockView",
  props: Cl,
  setup(t) {
    const e = t, n = O(e.extension.options.lowlight.listLanguages()), o = P({
      get() {
        return e.node.attrs.language || "auto";
      },
      set(r) {
        e.updateAttributes({ language: r });
      }
    });
    return (r, i) => {
      const s = Vj;
      return k(), _(p(kl), { class: "code-block relative" }, {
        default: w(() => [
          E(p(jj), {
            modelValue: o.value,
            "onUpdate:modelValue": i[0] || (i[0] = (a) => o.value = a)
          }, {
            default: w(() => [
              E(p(Wj), { class: "w-[160px] h-8 absolute right-2 top-2 bg-background" }, {
                default: w(() => [
                  E(p(Uj), { placeholder: "Select Language" })
                ]),
                _: 1
              }),
              E(p(Kj), null, {
                default: w(() => [
                  E(p(qj), null, {
                    default: w(() => [
                      E(p(Gy), { value: "auto" }, {
                        default: w(() => [
                          he(" Auto ")
                        ]),
                        _: 1
                      }),
                      E(s),
                      (k(!0), U(ve, null, Fe(n.value, (a, l) => (k(), _(p(Gy), {
                        value: a,
                        key: l
                      }, {
                        default: w(() => [
                          he(q(a), 1)
                        ]),
                        _: 2
                      }, 1032, ["value"]))), 128))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["modelValue"]),
          B("pre", null, [
            B("code", null, [
              E(p(z7))
            ])
          ])
        ]),
        _: 1
      });
    };
  }
}), hJ = Hj.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      language: "auto",
      button: ({ editor: e, t: n }) => ({
        component: ye,
        componentProps: {
          action: () => e.commands.toggleCodeBlock(),
          isActive: () => e.isActive("codeBlock") || !1,
          disabled: !e.can().toggleCodeBlock(),
          icon: "Code2",
          tooltip: n("editor.codeblock.tooltip")
        }
      })
    };
  },
  addNodeView() {
    return Sl(Xj);
  }
}), Zj = ot.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, He(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => jp({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
}), Qj = { class: "flex items-center h-full justify-between font-normal w-full" }, eU = {
  key: 0,
  class: "text-left truncate text-sm flex-grow"
}, tU = { class: "max-w-24 text-center flex flex-col items-center" }, nU = {
  key: 0,
  class: "flex"
}, oU = /* @__PURE__ */ T({
  __name: "ActionMenuButton",
  props: {
    icon: { default: void 0 },
    class: { default: "" },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    shortcutKeys: { default: void 0 },
    color: { default: void 0 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(Ps), null, {
      default: w(() => [
        E(p(Is), { "delay-duration": 0 }, {
          default: w(() => [
            E(p(Rs), { "as-child": "" }, {
              default: w(() => [
                E(p(Pt), {
                  class: Ze(p(fe)("h-[32px] px-1.5 py-0", e.class)),
                  variant: "ghost",
                  disabled: n.disabled
                }, {
                  default: w(() => [
                    B("div", Qj, [
                      n.title ? (k(), U("div", eU, q(n.title), 1)) : ae("", !0),
                      n.icon ? (k(), _(p(xe), {
                        key: 1,
                        class: "w-[16px] h-[16px]",
                        name: n.icon
                      }, null, 8, ["name"])) : ae("", !0),
                      E(p(xe), {
                        class: "w-3 h-3 ml-1 text-zinc-500 flex-shrink-0",
                        name: "MenuDown"
                      })
                    ])
                  ]),
                  _: 1
                }, 8, ["class", "disabled"])
              ]),
              _: 1
            }),
            n.tooltip || n.shortcutKeys && n.shortcutKeys.length ? (k(), _(p(Ds), { key: 0 }, {
              default: w(() => [
                B("div", tU, [
                  B("div", null, q(n.tooltip), 1),
                  n.shortcutKeys && n.shortcutKeys.length ? (k(), U("div", nU, [
                    B("span", null, q(p(To)(n.shortcutKeys)), 1)
                  ])) : ae("", !0)
                ])
              ]),
              _: 1
            })) : ae("", !0)
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), Ii = /* @__PURE__ */ T({
  __name: "ActionDropdownButton",
  props: {
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    class: { default: "" },
    btn_class: { default: "" },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    return (n, o) => (k(), _(p(Wg), null, {
      default: w(() => [
        E(p(Kg), { disabled: n.disabled }, {
          default: w(() => [
            E(oU, {
              class: Ze(n.btn_class),
              title: n.title,
              icon: n.icon,
              tooltip: n.tooltip,
              disabled: n.disabled,
              "is-active": n.isActive
            }, null, 8, ["class", "title", "icon", "tooltip", "disabled", "is-active"])
          ]),
          _: 1
        }, 8, ["disabled"]),
        E(p(qg), j({
          class: p(fe)("min-w-24", e.class),
          align: "start",
          side: "bottom"
        }, n.$attrs), {
          default: w(() => [
            D(n.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), rU = /* @__PURE__ */ T({
  __name: "HeadingButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    shortcutKeys: { default: void 0 },
    maxHeight: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, n = P(() => {
      const o = e.items.find((i) => i.isActive());
      return o && !o.default ? {
        ...o
      } : {
        title: e.tooltip,
        level: 0,
        isActive: () => !1
      };
    });
    return (o, r) => {
      var i;
      return k(), _(Ii, {
        disabled: o.disabled,
        tooltip: o.tooltip,
        title: (i = n.value) == null ? void 0 : i.title,
        btn_class: "min-w-24 max-w-32"
      }, {
        default: w(() => [
          (k(!0), U(ve, null, Fe(e.items, (s, a) => (k(), U(ve, { key: a }, [
            E(p(Vs), {
              checked: n.value.title === s.title,
              onClick: s.action
            }, {
              default: w(() => [
                B("div", {
                  class: Ze(["ml-1 h-full", "heading-" + s.level])
                }, q(s.title), 3),
                E(p(a6), { class: "pl-4" }, {
                  default: w(() => {
                    var l;
                    return [
                      he(q((l = s.shortcutKeys) == null ? void 0 : l.map((c) => p(Ku)(c)).join(" ")), 1)
                    ];
                  }),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1032, ["checked", "onClick"]),
            s.level === 0 ? (k(), _(p(Zu), { key: 0 })) : ae("", !0)
          ], 64))), 128))
        ]),
        _: 1
      }, 8, ["disabled", "tooltip", "title"]);
    };
  }
}), mJ = Zj.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      levels: [1, 2, 3, 4, 5, 6],
      button({ editor: e, extension: n, t: o }) {
        var c;
        const { extensions: r = [] } = e.extensionManager ?? [], i = ((c = n.options) == null ? void 0 : c.levels) || [], s = r.find((d) => d.name === "base-kit"), a = i.map((d) => ({
          action: () => e.commands.toggleHeading({ level: d }),
          isActive: () => e.isActive("heading", { level: d }) || !1,
          disabled: !e.can().toggleHeading({ level: d }),
          title: o(`editor.heading.h${d}.tooltip`),
          level: d,
          shortcutKeys: ["alt", "mod", `${d}`]
        }));
        s && s.options.paragraph !== !1 && a.unshift({
          action: () => e.commands.setParagraph(),
          isActive: () => e.isActive("paragraph") || !1,
          disabled: !e.can().setParagraph(),
          level: 0,
          title: o("editor.paragraph.tooltip"),
          shortcutKeys: ["alt", "mod", "0"]
        });
        const l = a.filter((d) => d.disabled).length === a.length;
        return {
          component: rU,
          componentProps: {
            tooltip: o("editor.heading.tooltip"),
            disabled: l,
            items: a
          }
        };
      }
    };
  }
}), iU = Te.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign ? { style: `text-align: ${t.textAlign}` } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t })).every((n) => n) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).every((e) => e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
}), sU = /* @__PURE__ */ T({
  __name: "TextAlignMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    maxHeight: { default: void 0 },
    icon: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, n = P(() => {
      const o = e.items.find((i) => i.isActive());
      return o && !o.default ? {
        ...o,
        icon: o.icon ? o.icon : e.icon
      } : {
        title: e.tooltip,
        icon: e.icon,
        isActive: () => !1
      };
    });
    return (o, r) => (k(), _(Ii, {
      icon: o.icon,
      tooltip: o.tooltip,
      disabled: o.disabled,
      class: "min-w-4 w-full flex flex-row gap-1"
    }, {
      default: w(() => [
        E(p(Ps), null, {
          default: w(() => [
            (k(!0), U(ve, null, Fe(e.items, (i, s) => (k(), _(p(Is), { key: s }, {
              default: w(() => [
                E(p(Rs), { "as-child": "" }, {
                  default: w(() => [
                    E(p(xn), {
                      class: "p-0",
                      onClick: i.action
                    }, {
                      default: w(() => [
                        E(p(b3), {
                          size: "sm",
                          class: "w-7 h-7 p-1",
                          pressed: n.value.title === i.title
                        }, {
                          default: w(() => [
                            i.icon ? (k(), _(p(xe), {
                              key: 0,
                              name: i.icon
                            }, null, 8, ["name"])) : ae("", !0)
                          ]),
                          _: 2
                        }, 1032, ["pressed"])
                      ]),
                      _: 2
                    }, 1032, ["onClick"])
                  ]),
                  _: 2
                }, 1024),
                E(p(Ds), { class: "flex flex-col items-center" }, {
                  default: w(() => {
                    var a;
                    return [
                      B("span", null, q(i.title), 1),
                      B("span", null, q((a = i.shortcutKeys) == null ? void 0 : a.map((l) => p(Ku)(l)).join(" ")), 1)
                    ];
                  }),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1024))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["icon", "tooltip", "disabled"]));
  }
}), gJ = iU.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["heading", "paragraph", "list_item", "title"],
      button({ editor: e, extension: n, t: o }) {
        var c;
        const r = ((c = n.options) == null ? void 0 : c.alignments) || [], i = {
          left: ["mod", "Shift", "L"],
          center: ["mod", "Shift", "E"],
          right: ["mod", "Shift", "R"],
          justify: ["mod", "Shift", "J"]
        }, s = {
          left: "AlignLeft",
          center: "AlignCenter",
          right: "AlignRight",
          justify: "AlignJustify"
        }, a = r.map((d) => ({
          title: o(`editor.textalign.${d}.tooltip`),
          icon: s[d],
          shortcutKeys: i[d],
          isActive: () => e.isActive({ textAlign: d }) || !1,
          action: () => e.commands.setTextAlign(d),
          disabled: !e.can().setTextAlign(d)
        })), l = a.filter((d) => d.disabled).length === a.length;
        return {
          component: sU,
          componentProps: {
            icon: "AlignJustify",
            tooltip: o("editor.textalign.tooltip"),
            disabled: l,
            items: a
          }
        };
      }
    };
  }
}), aU = { class: "ml-1 h-full" }, lU = /* @__PURE__ */ T({
  __name: "FontSizeMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    shortcutKeys: { default: void 0 },
    maxHeight: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, { t: n } = et(), o = P(() => {
      const r = e.items.find((s) => s.isActive());
      return r || {
        title: n.value("editor.fontSize.default.tooltip"),
        isActive: () => !1
      };
    });
    return (r, i) => {
      const s = Zu;
      return k(), _(Ii, {
        disabled: r.disabled,
        tooltip: r.tooltip,
        title: o.value.title,
        btn_class: "min-w-24 max-w-32"
      }, {
        default: w(() => [
          E(p(c6), { class: "w-32 h-96" }, {
            default: w(() => [
              (k(!0), U(ve, null, Fe(e.items, (a, l) => (k(), U(ve, { key: l }, [
                E(p(Vs), {
                  checked: o.value.title === a.title,
                  onClick: a.action
                }, {
                  default: w(() => [
                    B("div", aU, q(a.title), 1)
                  ]),
                  _: 2
                }, 1032, ["checked", "onClick"]),
                a.title === p(n)("editor.fontSize.default.tooltip") ? (k(), _(s, { key: 0 })) : ae("", !0)
              ], 64))), 128))
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["disabled", "tooltip", "title"]);
    };
  }
}), vJ = Te.create({
  name: "fontSize",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["textStyle"],
      fontSizes: [...U7],
      button({ editor: e, extension: n, t: o }) {
        var a;
        const r = ((a = n.options) == null ? void 0 : a.fontSizes) || [], i = [zi, ...r].map((l) => ({
          title: l === zi ? o("editor.fontSize.default.tooltip") : String(l),
          isActive: () => {
            const { fontSize: c } = e.getAttributes("textStyle");
            return l === zi && c === void 0 ? !0 : e.isActive({ fontSize: String(l) }) || !1;
          },
          action: () => {
            if (l === zi) {
              e.commands.unsetFontSize();
              return;
            }
            e.commands.setFontSize(String(l));
          },
          disabled: !e.can().setFontSize(String(l)),
          divider: l === zi || !1,
          default: l === zi || !1
        })), s = i.filter((l) => l.disabled).length === i.length;
        return {
          component: lU,
          componentProps: {
            editor: e,
            tooltip: o("editor.fontSize.tooltip"),
            disabled: s,
            items: i,
            maxHeight: 280
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (t) => t.style.fontSize.replace(/['"]+/g, ""),
            renderHTML: (t) => t.fontSize ? {
              style: `font-size: ${t.fontSize}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (t) => ({ chain: e }) => e().setMark("textStyle", { fontSize: t }).run(),
      unsetFontSize: () => ({ chain: t }) => t().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run()
    };
  }
}), cU = (t) => {
  if (!t.children.length)
    return;
  const e = t.querySelectorAll("span");
  e && e.forEach((n) => {
    var o, r;
    const i = n.getAttribute("style"), s = (r = (o = n.parentElement) === null || o === void 0 ? void 0 : o.closest("span")) === null || r === void 0 ? void 0 : r.getAttribute("style");
    n.setAttribute("style", `${s};${i}`);
  });
}, dU = Qt.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !1
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && cU(t), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ tr: t }) => {
        const { selection: e } = t;
        return t.doc.nodesBetween(e.from, e.to, (n, o) => {
          if (n.isTextblock)
            return !0;
          n.marks.filter((r) => r.type === this.type).some((r) => Object.values(r.attrs).some((i) => !!i)) || t.removeMark(o, o + n.nodeSize, this.type);
        }), !0;
      }
    };
  }
}), uU = Te.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              var e;
              return (e = t.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.color ? {
              style: `color: ${t.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
      unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), fU = { class: "flex items-center h-[32px] hover:bg-muted rounded-md" }, pU = { class: "text-sm flex justify-center items-center" }, hU = {
  width: "18px",
  height: "18px",
  viewBox: "0 0 240 240",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
}, mU = {
  id: "icon/字体颜色",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, gU = { transform: "translate(0.000000, 0.500000)" }, vU = { transform: "translate(39.000000, 17.353553)" }, yU = ["fill"], bU = /* @__PURE__ */ B("path", {
  d: "M72.3425855,16.8295583 C75.799482,7.50883712 86.1577877,2.75526801 95.4785089,6.21216449 C100.284516,7.99463061 104.096358,11.7387855 105.968745,16.4968188 L106.112518,16.8745422 L159.385152,161.694068 C161.291848,166.877345 158.635655,172.624903 153.452378,174.531599 C148.358469,176.405421 142.719567,173.872338 140.716873,168.864661 L140.614848,168.598825 L89.211,28.86 L37.3759214,168.623816 C35.4885354,173.712715 29.8981043,176.351047 24.7909589,174.617647 L24.5226307,174.522368 C19.4337312,172.634982 16.7953993,167.044551 18.5287999,161.937406 L18.6240786,161.669077 L72.3425855,16.8295583 Z",
  id: "路径-21",
  fill: "currentColor",
  "fill-rule": "nonzero"
}, null, -1), wU = /* @__PURE__ */ B("path", {
  d: "M121,103.146447 C126.522847,103.146447 131,107.623599 131,113.146447 C131,118.575687 126.673329,122.994378 121.279905,123.142605 L121,123.146447 L55,123.146447 C49.4771525,123.146447 45,118.669294 45,113.146447 C45,107.717207 49.3266708,103.298515 54.7200952,103.150288 L55,103.146447 L121,103.146447 Z",
  id: "路径-22",
  fill: "currentColor",
  "fill-rule": "nonzero"
}, null, -1), xU = /* @__PURE__ */ T({
  __name: "ColorActionButton",
  props: {
    editor: {},
    icon: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t, n = O(void 0);
    function o(i) {
      var s;
      (s = e.action) == null || s.call(e, i);
    }
    function r(i) {
      var s;
      (s = e.action) == null || s.call(e, n.value);
    }
    return (i, s) => (k(), U("div", fU, [
      E(ye, {
        tooltip: i.tooltip,
        disabled: i.disabled,
        action: r
      }, {
        icon: w(() => [
          B("span", pU, [
            (k(), U("svg", hU, [
              B("g", mU, [
                B("g", gU, [
                  B("g", vU, [
                    B("path", {
                      d: "M11,201.146447 L167,201.146447 C173.075132,201.146447 178,206.071314 178,212.146447 C178,218.221579 173.075132,223.146447 167,223.146447 L11,223.146447 C4.92486775,223.146447 7.43989126e-16,218.221579 0,212.146447 C-7.43989126e-16,206.071314 4.92486775,201.146447 11,201.146447 Z",
                      id: "矩形",
                      fill: n.value || "#DF2A3F",
                      "fill-rule": "evenodd"
                    }, null, 8, yU),
                    bU,
                    wU
                  ])
                ])
              ])
            ]))
          ])
        ]),
        _: 1
      }, 8, ["tooltip", "disabled"]),
      E(x3, {
        modelValue: n.value,
        "onUpdate:modelValue": s[0] || (s[0] = (a) => n.value = a),
        onChange: o,
        disabled: i.disabled
      }, {
        default: w(() => [
          E(p(Pt), {
            variant: "ghost",
            size: "icon",
            class: "h-[32px] w-3 rounded-l-none hover:bg-muted-foreground/20",
            disabled: i.disabled
          }, {
            default: w(() => [
              E(p(xe), {
                class: "w-3 h-3 text-zinc-500",
                name: "MenuDown"
              })
            ]),
            _: 1
          }, 8, ["disabled"])
        ]),
        _: 1
      }, 8, ["modelValue", "disabled"])
    ]));
  }
}), yJ = uU.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, t: n }) {
        return {
          component: xU,
          componentProps: {
            action: (o) => {
              typeof o > "u" && e.chain().focus().unsetColor().run(), typeof o == "string" && e.chain().focus().setColor(o).run();
            },
            isActive: () => {
              const { color: o } = e.getAttributes("textStyle");
              return o && e.isActive({ color: o }) || !1;
            },
            editor: e,
            disabled: !e.can().setColor(""),
            tooltip: n("editor.color.tooltip")
          }
        };
      }
    };
  }
}), kU = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, CU = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, SU = Qt.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      mi({
        find: kU,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Er({
        find: CU,
        type: this.type
      })
    ];
  }
}), bJ = SU.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      multicolor: !0,
      button: ({ editor: e, t: n }) => ({
        component: k3,
        componentProps: {
          action: (o) => {
            typeof o == "string" && e.chain().focus().setHighlight({ color: o }).run(), typeof o > "u" && e.chain().focus().unsetHighlight().run();
          },
          editor: e,
          isActive: () => e.isActive("highlight") || !1,
          disabled: !e.can().setHighlight(),
          shortcutKeys: ["⇧", "mod", "H"],
          tooltip: n("editor.highlight.tooltip")
        }
      })
    };
  }
}), AU = "listItem", Jy = "textStyle", Yy = /^\s*([-+*])\s$/, EU = ot.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(AU, this.editor.getAttributes(Jy)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = cs({
      find: Yy,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = cs({
      find: Yy,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(Jy),
      editor: this.editor
    })), [
      t
    ];
  }
}), C6 = /* @__PURE__ */ T({
  __name: "ActionDropdownButtonSplit",
  props: {
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    class: { default: "" },
    shortcutKeys: { default: void 0 },
    btn_class: { default: "" },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    return (n, o) => {
      var r;
      return k(), U("div", {
        class: Ze(["flex items-center h-[32px] hover:bg-muted rounded-md", [((r = n.isActive) == null ? void 0 : r.call(n)) && "bg-muted"]])
      }, [
        E(ye, {
          class: Ze(n.btn_class),
          action: n.action,
          title: n.title,
          icon: n.icon,
          tooltip: n.tooltip,
          disabled: n.disabled,
          "shortcut-keys": n.shortcutKeys
        }, null, 8, ["class", "action", "title", "icon", "tooltip", "disabled", "shortcut-keys"]),
        E(p(Wg), null, {
          default: w(() => [
            E(p(Kg), { disabled: n.disabled }, {
              default: w(() => [
                E(Pt, {
                  variant: "ghost",
                  size: "icon",
                  class: "h-[32px] w-3 rounded-l-none hover:bg-muted-foreground/20",
                  disabled: n.disabled
                }, {
                  default: w(() => [
                    E(p(xe), {
                      class: "w-3 h-3 text-zinc-500",
                      name: "MenuDown"
                    })
                  ]),
                  _: 1
                }, 8, ["disabled"])
              ]),
              _: 1
            }, 8, ["disabled"]),
            E(p(qg), j({
              class: p(fe)("min-w-24", e.class),
              align: "start",
              side: "bottom"
            }, n.$attrs), {
              default: w(() => [
                D(n.$slots, "default")
              ]),
              _: 3
            }, 16, ["class"])
          ]),
          _: 3
        })
      ], 2);
    };
  }
}), _U = /* @__PURE__ */ B("hr", { class: "border-0 bg-gray-200 h-[3px] w-6 my-1" }, null, -1), MU = [
  _U
], TU = /* @__PURE__ */ T({
  __name: "BulletListMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    tooltip: { default: "" }
  },
  setup(t) {
    const e = t, { t: n } = et(), o = [
      { label: "editor.bulletlist.disc.tooltip", value: "disc" },
      { label: "editor.bulletlist.circle.tooltip", value: "circle" },
      { label: "editor.bulletlist.square.tooltip", value: "square" }
    ], r = P(() => {
      var s;
      return (s = e.editor) != null && s.isActive("bulletList") ? e.editor.getAttributes("bulletList").listStyleType : "disc";
    });
    function i(s) {
      e.editor.isActive("bulletList") ? e.editor.getAttributes("bulletList").listStyleType === s.value ? e.editor.chain().focus().toggleBulletList().run() : e.editor.chain().focus().updateAttributes("bulletList", { listStyleType: s.value }).run() : e.editor.chain().focus().toggleBulletList().updateAttributes("bulletList", { listStyleType: s.value }).run();
    }
    return (s, a) => (k(), _(C6, {
      action: i,
      disabled: s.disabled,
      tooltip: s.tooltip,
      class: "min-w-4 w-full grid grid-cols-3 gap-1"
    }, {
      default: w(() => [
        E(p(Ps), null, {
          default: w(() => [
            (k(), U(ve, null, Fe(o, (l) => E(p(Is), {
              "delay-duration": 0,
              key: l.value
            }, {
              default: w(() => [
                E(p(Rs), null, {
                  default: w(() => [
                    E(p(xn), {
                      class: "p-0",
                      onClick: (c) => i(l)
                    }, {
                      default: w(() => [
                        B("div", {
                          class: Ze([[r.value === l.value ? "bg-accent border border-accent-foreground" : ""], "h-[48px] flex flex-col w-[48px] box-border rounded-sm border"])
                        }, [
                          B("ol", {
                            style: ct({ listStyleType: l.value, lineHeight: 1 }),
                            class: "text-[10px] pl-3 flex-1 list-outside flex flex-col items-center justify-center"
                          }, [
                            (k(), U(ve, null, Fe(3, (c) => B("li", { key: c }, MU)), 64))
                          ], 4)
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["onClick"])
                  ]),
                  _: 2
                }, 1024),
                E(p(Ds), { side: "bottom" }, {
                  default: w(() => [
                    he(q(p(n)(l.label)), 1)
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1024)), 64))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["disabled", "tooltip"]));
  }
}), wJ = EU.extend({
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      listStyleType: {
        default: "disc",
        parseHTML: (e) => ({ listStyleType: e.style["list-style-type"] ?? "disc" }),
        renderHTML: ({ listStyleType: e }) => ({
          style: `list-style-type: ${(e == null ? void 0 : e.listStyleType) || e}`
        })
      }
    };
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: TU,
        componentProps: {
          action: () => e.commands.toggleBulletList(),
          isActive: () => e.isActive("bulletList") || !1,
          disabled: !e.can().toggleBulletList(),
          shortcutKeys: ["shift", "mod", "8"],
          icon: "List",
          tooltip: n("editor.bulletlist.tooltip")
        }
      })
    };
  }
}), xJ = ot.create({
  name: "clear",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: ye,
        componentProps: {
          action: () => e.chain().focus().clearNodes().unsetAllMarks().run(),
          disabled: !e.can().chain().focus().clearNodes().unsetAllMarks().run(),
          icon: "Eraser",
          tooltip: n("editor.clear.tooltip")
        }
      })
    };
  }
}), OU = "listItem", Xy = "textStyle", Zy = /^(\d+)\.\s$/, IU = ot.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: void 0,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", He(this.options.HTMLAttributes, n), 0] : ["ol", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(OU, this.editor.getAttributes(Xy)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = cs({
      find: Zy,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = cs({
      find: Zy,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(Xy) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [
      t
    ];
  }
}), DU = /* @__PURE__ */ B("hr", { class: "border-0 bg-gray-200 h-[3px] w-6 my-1" }, null, -1), RU = [
  DU
], PU = /* @__PURE__ */ T({
  __name: "OrderedListMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    tooltip: { default: "" },
    shortcutKeys: { default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t, { t: n } = et(), o = [
      { label: "editor.orderedlist.decimal.tooltip", value: "decimal" },
      {
        label: "editor.orderedlist.decimalLeadingZero.tooltip",
        value: "decimal-leading-zero"
      },
      { label: "editor.orderedlist.lowerRoman.tooltip", value: "lower-roman" },
      { label: "editor.orderedlist.upperRoman.tooltip", value: "upper-roman" },
      { label: "editor.orderedlist.lowerLatin.tooltip", value: "lower-latin" },
      { label: "editor.orderedlist.upperLatin.tooltip", value: "upper-latin" },
      {
        label: "editor.orderedlist.tradChineseInformal.tooltip",
        value: "trad-chinese-informal"
      },
      {
        label: "editor.orderedlist.simpChineseFormal.tooltip",
        value: "simp-chinese-formal"
      }
    ], r = P(() => {
      var s;
      return (s = e.editor) != null && s.isActive("orderedList") ? e.editor.getAttributes("orderedList").listType : "decimal";
    });
    function i(s) {
      var a, l;
      e.editor.isActive("orderedList") ? e.editor.getAttributes("orderedList").listType === s.value ? (a = e.editor.chain()) == null || a.toggleOrderedList().run() : (l = e.editor.chain()) == null || l.updateAttributes("orderedList", { listType: s.value }).run() : e.editor.chain().focus().toggleOrderedList().updateAttributes("orderedList", { listType: s.value }).run();
    }
    return (s, a) => (k(), _(C6, {
      action: i,
      disabled: s.disabled,
      tooltip: s.tooltip,
      "is-active": s.isActive,
      shortcutKeys: s.shortcutKeys,
      class: "min-w-4 w-full grid grid-cols-3 gap-1"
    }, {
      default: w(() => [
        E(p(Ps), null, {
          default: w(() => [
            (k(), U(ve, null, Fe(o, (l) => E(p(Is), {
              "delay-duration": 0,
              key: l.value
            }, {
              default: w(() => [
                E(p(Rs), { "as-child": "" }, {
                  default: w(() => [
                    E(p(xn), {
                      class: "p-0",
                      onClick: (c) => i(l)
                    }, {
                      default: w(() => [
                        B("div", {
                          class: Ze([[r.value === l.value ? "bg-accent border border-accent-foreground" : ""], "h-[72px] flex flex-col w-[72px] box-border rounded-sm border"])
                        }, [
                          B("ol", {
                            style: ct({ listStyleType: l.value, lineHeight: 1 }),
                            class: "text-[12px] pl-3 flex-1 list-outside flex flex-col items-center justify-center"
                          }, [
                            (k(), U(ve, null, Fe(3, (c) => B("li", { key: c }, RU)), 64))
                          ], 4)
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["onClick"])
                  ]),
                  _: 2
                }, 1024),
                E(p(Ds), { side: "bottom" }, {
                  default: w(() => [
                    he(q(p(n)(l.label)), 1)
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1024)), 64))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["disabled", "tooltip", "is-active", "shortcutKeys"]));
  }
}), kJ = IU.extend({
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      listType: {
        default: "decimal",
        parseHTML: (e) => {
          e.style.getPropertyValue("list-style-type");
        },
        renderHTML: ({ listType: e }) => ({
          style: `list-style-type: ${e}`
        })
      }
    };
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: PU,
        componentProps: {
          action: () => e.commands.toggleOrderedList(),
          isActive: () => e.isActive("orderedList") || !1,
          disabled: !e.can().toggleOrderedList(),
          icon: "ListOrdered",
          shortcutKeys: ["mod", "shift", "7"],
          tooltip: n("editor.orderedlist.tooltip")
        }
      })
    };
  }
}), LU = /^\s*(\[([( |x])?\])\s$/, NU = ot.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList"
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (t) => {
          const e = t.getAttribute("data-checked");
          return e === "" || e === "true";
        },
        renderHTML: (t) => ({
          "data-checked": t.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "li",
      He(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: t.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const t = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...t,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : t;
  },
  addNodeView() {
    return ({ node: t, HTMLAttributes: e, getPos: n, editor: o }) => {
      const r = document.createElement("li"), i = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div");
      return i.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (c) => c.preventDefault()), a.addEventListener("change", (c) => {
        if (!o.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: d } = c.target;
        o.isEditable && typeof n == "function" && o.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: u }) => {
          const f = n();
          if (typeof f != "number")
            return !1;
          const h = u.doc.nodeAt(f);
          return u.setNodeMarkup(f, void 0, {
            ...h == null ? void 0 : h.attrs,
            checked: d
          }), !0;
        }).run(), !o.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t, d) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([c, d]) => {
        r.setAttribute(c, d);
      }), r.dataset.checked = t.attrs.checked, a.checked = t.attrs.checked, i.append(a, s), r.append(i, l), Object.entries(e).forEach(([c, d]) => {
        r.setAttribute(c, d);
      }), {
        dom: r,
        contentDOM: l,
        update: (c) => c.type !== this.type ? !1 : (r.dataset.checked = c.attrs.checked, a.checked = c.attrs.checked, !0)
      };
    };
  },
  addInputRules() {
    return [
      cs({
        find: LU,
        type: this.type,
        getAttributes: (t) => ({
          checked: t[t.length - 1] === "x"
        })
      })
    ];
  }
}), BU = ot.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", He(this.options.HTMLAttributes, t, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: t }) => t.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
}), CJ = BU.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {
        class: "task-list"
      },
      taskItem: {
        HTMLAttributes: {
          class: "task-list-item"
        }
      },
      button: ({ editor: e, t: n }) => ({
        component: ye,
        componentProps: {
          action: () => e.commands.toggleTaskList(),
          isActive: () => e.isActive("taskList") || !1,
          disabled: !e.can().toggleTaskList(),
          icon: "ListTodo",
          shortcutKeys: ["shift", "mod", "9"],
          tooltip: n("editor.tasklist.tooltip")
        }
      })
    };
  },
  addExtensions() {
    return [NU.configure(this.options.taskItem)];
  }
}), $U = /^\s*>\s$/, zU = ot.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      cs({
        find: $U,
        type: this.type
      })
    ];
  }
}), SJ = zU.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {
        class: "blockquote"
      },
      button: ({ editor: e, t: n }) => ({
        component: ye,
        componentProps: {
          action: () => e.commands.toggleBlockquote(),
          isActive: () => e.isActive("blockquote") || !1,
          disabled: !e.can().toggleBlockquote(),
          icon: "TextQuote",
          shortcutKeys: ["shift", "mod", "B"],
          tooltip: n("editor.blockquote.tooltip")
        }
      })
    };
  }
}), FU = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", HU = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", ks = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, Hh = "numeric", Vh = "ascii", jh = "alpha", ka = "asciinumeric", sa = "alphanumeric", Uh = "domain", S6 = "emoji", VU = "scheme", jU = "slashscheme", cp = "whitespace";
function UU(t, e) {
  return t in e || (e[t] = []), e[t];
}
function oi(t, e, n) {
  e[Hh] && (e[ka] = !0, e[sa] = !0), e[Vh] && (e[ka] = !0, e[jh] = !0), e[ka] && (e[sa] = !0), e[jh] && (e[sa] = !0), e[sa] && (e[Uh] = !0), e[S6] && (e[Uh] = !0);
  for (const o in e) {
    const r = UU(o, n);
    r.indexOf(t) < 0 && r.push(t);
  }
}
function WU(t, e) {
  const n = {};
  for (const o in e)
    e[o].indexOf(t) >= 0 && (n[o] = !0);
  return n;
}
function qt(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
qt.groups = {};
qt.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let o = 0; o < e.jr.length; o++) {
      const r = e.jr[o][0], i = e.jr[o][1];
      if (i && r.test(t))
        return i;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, o) {
    for (let r = 0; r < t.length; r++)
      this.tt(t[r], e, n, o);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, o) {
    o = o || qt.groups;
    let r;
    return e && e.j ? r = e : (r = new qt(e), n && o && oi(e, n, o)), this.jr.push([t, r]), r;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, o) {
    let r = this;
    const i = t.length;
    if (!i)
      return r;
    for (let s = 0; s < i - 1; s++)
      r = r.tt(t[s]);
    return r.tt(t[i - 1], e, n, o);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, o) {
    o = o || qt.groups;
    const r = this;
    if (e && e.j)
      return r.j[t] = e, e;
    const i = e;
    let s, a = r.go(t);
    if (a ? (s = new qt(), ks(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new qt(), i) {
      if (o)
        if (s.t && typeof s.t == "string") {
          const l = ks(WU(s.t, o), n);
          oi(i, l, o);
        } else
          n && oi(i, n, o);
      s.t = i;
    }
    return r.j[t] = s, s;
  }
};
const Ae = (t, e, n, o, r) => t.ta(e, n, o, r), ut = (t, e, n, o, r) => t.tr(e, n, o, r), Qy = (t, e, n, o, r) => t.ts(e, n, o, r), G = (t, e, n, o, r) => t.tt(e, n, o, r), ko = "WORD", Wh = "UWORD", A6 = "ASCIINUMERICAL", E6 = "ALPHANUMERICAL", pl = "LOCALHOST", Kh = "TLD", qh = "UTLD", $c = "SCHEME", qi = "SLASH_SCHEME", t0 = "NUM", Gh = "WS", n0 = "NL", Ca = "OPENBRACE", Sa = "CLOSEBRACE", Cd = "OPENBRACKET", Sd = "CLOSEBRACKET", Ad = "OPENPAREN", Ed = "CLOSEPAREN", _d = "OPENANGLEBRACKET", Md = "CLOSEANGLEBRACKET", Td = "FULLWIDTHLEFTPAREN", Od = "FULLWIDTHRIGHTPAREN", Id = "LEFTCORNERBRACKET", Dd = "RIGHTCORNERBRACKET", Rd = "LEFTWHITECORNERBRACKET", Pd = "RIGHTWHITECORNERBRACKET", Ld = "FULLWIDTHLESSTHAN", Nd = "FULLWIDTHGREATERTHAN", Bd = "AMPERSAND", o0 = "APOSTROPHE", $d = "ASTERISK", lr = "AT", zd = "BACKSLASH", Fd = "BACKTICK", Hd = "CARET", pr = "COLON", r0 = "COMMA", Vd = "DOLLAR", Un = "DOT", jd = "EQUALS", i0 = "EXCLAMATION", wn = "HYPHEN", Aa = "PERCENT", Ud = "PIPE", Wd = "PLUS", Kd = "POUND", Ea = "QUERY", s0 = "QUOTE", _6 = "FULLWIDTHMIDDLEDOT", a0 = "SEMI", Wn = "SLASH", _a = "TILDE", qd = "UNDERSCORE", M6 = "EMOJI", Gd = "SYM";
var T6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: ko,
  UWORD: Wh,
  ASCIINUMERICAL: A6,
  ALPHANUMERICAL: E6,
  LOCALHOST: pl,
  TLD: Kh,
  UTLD: qh,
  SCHEME: $c,
  SLASH_SCHEME: qi,
  NUM: t0,
  WS: Gh,
  NL: n0,
  OPENBRACE: Ca,
  CLOSEBRACE: Sa,
  OPENBRACKET: Cd,
  CLOSEBRACKET: Sd,
  OPENPAREN: Ad,
  CLOSEPAREN: Ed,
  OPENANGLEBRACKET: _d,
  CLOSEANGLEBRACKET: Md,
  FULLWIDTHLEFTPAREN: Td,
  FULLWIDTHRIGHTPAREN: Od,
  LEFTCORNERBRACKET: Id,
  RIGHTCORNERBRACKET: Dd,
  LEFTWHITECORNERBRACKET: Rd,
  RIGHTWHITECORNERBRACKET: Pd,
  FULLWIDTHLESSTHAN: Ld,
  FULLWIDTHGREATERTHAN: Nd,
  AMPERSAND: Bd,
  APOSTROPHE: o0,
  ASTERISK: $d,
  AT: lr,
  BACKSLASH: zd,
  BACKTICK: Fd,
  CARET: Hd,
  COLON: pr,
  COMMA: r0,
  DOLLAR: Vd,
  DOT: Un,
  EQUALS: jd,
  EXCLAMATION: i0,
  HYPHEN: wn,
  PERCENT: Aa,
  PIPE: Ud,
  PLUS: Wd,
  POUND: Kd,
  QUERY: Ea,
  QUOTE: s0,
  FULLWIDTHMIDDLEDOT: _6,
  SEMI: a0,
  SLASH: Wn,
  TILDE: _a,
  UNDERSCORE: qd,
  EMOJI: M6,
  SYM: Gd
});
const wo = /[a-z]/, ea = new RegExp("\\p{L}", "u"), dp = new RegExp("\\p{Emoji}", "u"), xo = /\d/, up = /\s/, eb = "\r", fp = `
`, KU = "️", qU = "‍", pp = "￼";
let vc = null, yc = null;
function GU(t = []) {
  const e = {};
  qt.groups = e;
  const n = new qt();
  vc == null && (vc = tb(FU)), yc == null && (yc = tb(HU)), G(n, "'", o0), G(n, "{", Ca), G(n, "}", Sa), G(n, "[", Cd), G(n, "]", Sd), G(n, "(", Ad), G(n, ")", Ed), G(n, "<", _d), G(n, ">", Md), G(n, "（", Td), G(n, "）", Od), G(n, "「", Id), G(n, "」", Dd), G(n, "『", Rd), G(n, "』", Pd), G(n, "＜", Ld), G(n, "＞", Nd), G(n, "&", Bd), G(n, "*", $d), G(n, "@", lr), G(n, "`", Fd), G(n, "^", Hd), G(n, ":", pr), G(n, ",", r0), G(n, "$", Vd), G(n, ".", Un), G(n, "=", jd), G(n, "!", i0), G(n, "-", wn), G(n, "%", Aa), G(n, "|", Ud), G(n, "+", Wd), G(n, "#", Kd), G(n, "?", Ea), G(n, '"', s0), G(n, "/", Wn), G(n, ";", a0), G(n, "~", _a), G(n, "_", qd), G(n, "\\", zd), G(n, "・", _6);
  const o = ut(n, xo, t0, {
    [Hh]: !0
  });
  ut(o, xo, o);
  const r = ut(o, wo, A6, {
    [ka]: !0
  }), i = ut(o, ea, E6, {
    [sa]: !0
  }), s = ut(n, wo, ko, {
    [Vh]: !0
  });
  ut(s, xo, r), ut(s, wo, s), ut(r, xo, r), ut(r, wo, r);
  const a = ut(n, ea, Wh, {
    [jh]: !0
  });
  ut(a, wo), ut(a, xo, i), ut(a, ea, a), ut(i, xo, i), ut(i, wo), ut(i, ea, i);
  const l = G(n, fp, n0, {
    [cp]: !0
  }), c = G(n, eb, Gh, {
    [cp]: !0
  }), d = ut(n, up, Gh, {
    [cp]: !0
  });
  G(n, pp, d), G(c, fp, l), G(c, pp, d), ut(c, up, d), G(d, eb), G(d, fp), ut(d, up, d), G(d, pp, d);
  const u = ut(n, dp, M6, {
    [S6]: !0
  });
  G(u, "#"), ut(u, dp, u), G(u, KU, u);
  const f = G(u, qU);
  G(f, "#"), ut(f, dp, u);
  const h = [[wo, s], [xo, r]], m = [[wo, null], [ea, a], [xo, i]];
  for (let g = 0; g < vc.length; g++)
    or(n, vc[g], Kh, ko, h);
  for (let g = 0; g < yc.length; g++)
    or(n, yc[g], qh, Wh, m);
  oi(Kh, {
    tld: !0,
    ascii: !0
  }, e), oi(qh, {
    utld: !0,
    alpha: !0
  }, e), or(n, "file", $c, ko, h), or(n, "mailto", $c, ko, h), or(n, "http", qi, ko, h), or(n, "https", qi, ko, h), or(n, "ftp", qi, ko, h), or(n, "ftps", qi, ko, h), oi($c, {
    scheme: !0,
    ascii: !0
  }, e), oi(qi, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((g, v) => g[0] > v[0] ? 1 : -1);
  for (let g = 0; g < t.length; g++) {
    const v = t[g][0], x = t[g][1] ? {
      [VU]: !0
    } : {
      [jU]: !0
    };
    v.indexOf("-") >= 0 ? x[Uh] = !0 : wo.test(v) ? xo.test(v) ? x[ka] = !0 : x[Vh] = !0 : x[Hh] = !0, Qy(n, v, v, x);
  }
  return Qy(n, "localhost", pl, {
    ascii: !0
  }), n.jd = new qt(Gd), {
    start: n,
    tokens: ks({
      groups: e
    }, T6)
  };
}
function O6(t, e) {
  const n = JU(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), o = n.length, r = [];
  let i = 0, s = 0;
  for (; s < o; ) {
    let a = t, l = null, c = 0, d = null, u = -1, f = -1;
    for (; s < o && (l = a.go(n[s])); )
      a = l, a.accepts() ? (u = 0, f = 0, d = a) : u >= 0 && (u += n[s].length, f++), c += n[s].length, i += n[s].length, s++;
    i -= u, s -= f, c -= u, r.push({
      t: d.t,
      // token type/name
      v: e.slice(i - c, i),
      // string value
      s: i - c,
      // start index
      e: i
      // end index (excluding)
    });
  }
  return r;
}
function JU(t) {
  const e = [], n = t.length;
  let o = 0;
  for (; o < n; ) {
    let r = t.charCodeAt(o), i, s = r < 55296 || r > 56319 || o + 1 === n || (i = t.charCodeAt(o + 1)) < 56320 || i > 57343 ? t[o] : t.slice(o, o + 2);
    e.push(s), o += s.length;
  }
  return e;
}
function or(t, e, n, o, r) {
  let i;
  const s = e.length;
  for (let a = 0; a < s - 1; a++) {
    const l = e[a];
    t.j[l] ? i = t.j[l] : (i = new qt(o), i.jr = r.slice(), t.j[l] = i), t = i;
  }
  return i = new qt(n), i.jr = r.slice(), t.j[e[s - 1]] = i, i;
}
function tb(t) {
  const e = [], n = [];
  let o = 0, r = "0123456789";
  for (; o < t.length; ) {
    let i = 0;
    for (; r.indexOf(t[o + i]) >= 0; )
      i++;
    if (i > 0) {
      e.push(n.join(""));
      for (let s = parseInt(t.substring(o, o + i), 10); s > 0; s--)
        n.pop();
      o += i;
    } else
      n.push(t[o]), o++;
  }
  return e;
}
const hl = {
  defaultProtocol: "http",
  events: null,
  format: nb,
  formatHref: nb,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function l0(t, e = null) {
  let n = ks({}, hl);
  t && (n = ks(n, t instanceof l0 ? t.o : t));
  const o = n.ignoreTags, r = [];
  for (let i = 0; i < o.length; i++)
    r.push(o[i].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = r;
}
l0.prototype = {
  o: hl,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const o = e != null;
    let r = this.o[t];
    return r && (typeof r == "object" ? (r = n.t in r ? r[n.t] : hl[t], typeof r == "function" && o && (r = r(e, n))) : typeof r == "function" && o && (r = r(e, n.t, n)), r);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let o = this.o[t];
    return typeof o == "function" && e != null && (o = o(e, n.t, n)), o;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function nb(t) {
  return t;
}
function I6(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
I6.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), o = t.get("format", e, this);
    return n && o.length > n ? o.substring(0, n) + "…" : o;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = hl.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), o = t.get("formatHref", n, this), r = t.get("tagName", n, e), i = this.toFormattedString(t), s = {}, a = t.get("className", n, e), l = t.get("target", n, e), c = t.get("rel", n, e), d = t.getObj("attributes", n, e), u = t.getObj("events", n, e);
    return s.href = o, a && (s.class = a), l && (s.target = l), c && (s.rel = c), d && ks(s, d), {
      tagName: r,
      attributes: s,
      content: i,
      eventListeners: u
    };
  }
};
function ef(t, e) {
  class n extends I6 {
    constructor(r, i) {
      super(r, i), this.t = t;
    }
  }
  for (const o in e)
    n.prototype[o] = e[o];
  return n.t = t, n;
}
const ob = ef("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), rb = ef("text"), YU = ef("nl"), bc = ef("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = hl.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== pl && t[1].t === pr;
  }
}), bn = (t) => new qt(t);
function XU({
  groups: t
}) {
  const e = t.domain.concat([Bd, $d, lr, zd, Fd, Hd, Vd, jd, wn, t0, Aa, Ud, Wd, Kd, Wn, Gd, _a, qd]), n = [pr, r0, Un, i0, Aa, Ea, s0, a0, _d, Md, Ca, Sa, Sd, Cd, Ad, Ed, Td, Od, Id, Dd, Rd, Pd, Ld, Nd], o = [Bd, o0, $d, zd, Fd, Hd, Vd, jd, wn, Ca, Sa, Aa, Ud, Wd, Kd, Ea, Wn, Gd, _a, qd], r = bn(), i = G(r, _a);
  Ae(i, o, i), Ae(i, t.domain, i);
  const s = bn(), a = bn(), l = bn();
  Ae(r, t.domain, s), Ae(r, t.scheme, a), Ae(r, t.slashscheme, l), Ae(s, o, i), Ae(s, t.domain, s);
  const c = G(s, lr);
  G(i, lr, c), G(a, lr, c), G(l, lr, c);
  const d = G(i, Un);
  Ae(d, o, i), Ae(d, t.domain, i);
  const u = bn();
  Ae(c, t.domain, u), Ae(u, t.domain, u);
  const f = G(u, Un);
  Ae(f, t.domain, u);
  const h = bn(ob);
  Ae(f, t.tld, h), Ae(f, t.utld, h), G(c, pl, h);
  const m = G(u, wn);
  G(m, wn, m), Ae(m, t.domain, u), Ae(h, t.domain, u), G(h, Un, f), G(h, wn, m);
  const g = G(h, pr);
  Ae(g, t.numeric, ob);
  const v = G(s, wn), y = G(s, Un);
  G(v, wn, v), Ae(v, t.domain, s), Ae(y, o, i), Ae(y, t.domain, s);
  const x = bn(bc);
  Ae(y, t.tld, x), Ae(y, t.utld, x), Ae(x, t.domain, s), Ae(x, o, i), G(x, Un, y), G(x, wn, v), G(x, lr, c);
  const C = G(x, pr), b = bn(bc);
  Ae(C, t.numeric, b);
  const S = bn(bc), A = bn();
  Ae(S, e, S), Ae(S, n, A), Ae(A, e, S), Ae(A, n, A), G(x, Wn, S), G(b, Wn, S);
  const I = G(a, pr), z = G(l, pr), N = G(z, Wn), M = G(N, Wn);
  Ae(a, t.domain, s), G(a, Un, y), G(a, wn, v), Ae(l, t.domain, s), G(l, Un, y), G(l, wn, v), Ae(I, t.domain, S), G(I, Wn, S), G(I, Ea, S), Ae(M, t.domain, S), Ae(M, e, S), G(M, Wn, S);
  const $ = [
    [Ca, Sa],
    // {}
    [Cd, Sd],
    // []
    [Ad, Ed],
    // ()
    [_d, Md],
    // <>
    [Td, Od],
    // （）
    [Id, Dd],
    // 「」
    [Rd, Pd],
    // 『』
    [Ld, Nd]
    // ＜＞
  ];
  for (let L = 0; L < $.length; L++) {
    const [Y, J] = $[L], ne = G(S, Y);
    G(A, Y, ne), G(ne, J, S);
    const F = bn(bc);
    Ae(ne, e, F);
    const R = bn();
    Ae(ne, n), Ae(F, e, F), Ae(F, n, R), Ae(R, e, F), Ae(R, n, R), G(F, J, S), G(R, J, S);
  }
  return G(r, pl, x), G(r, n0, YU), {
    start: r,
    tokens: T6
  };
}
function ZU(t, e, n) {
  let o = n.length, r = 0, i = [], s = [];
  for (; r < o; ) {
    let a = t, l = null, c = null, d = 0, u = null, f = -1;
    for (; r < o && !(l = a.go(n[r].t)); )
      s.push(n[r++]);
    for (; r < o && (c = l || a.go(n[r].t)); )
      l = null, a = c, a.accepts() ? (f = 0, u = a) : f >= 0 && f++, r++, d++;
    if (f < 0)
      r -= d, r < o && (s.push(n[r]), r++);
    else {
      s.length > 0 && (i.push(hp(rb, e, s)), s = []), r -= f, d -= f;
      const h = u.t, m = n.slice(r - d, r);
      i.push(hp(h, e, m));
    }
  }
  return s.length > 0 && i.push(hp(rb, e, s)), i;
}
function hp(t, e, n) {
  const o = n[0].s, r = n[n.length - 1].e, i = e.slice(o, r);
  return new t(i, n);
}
const QU = typeof console < "u" && console && console.warn || (() => {
}), eW = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", st = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function tW() {
  return qt.groups = {}, st.scanner = null, st.parser = null, st.tokenQueue = [], st.pluginQueue = [], st.customSchemes = [], st.initialized = !1, st;
}
function ib(t, e = !1) {
  if (st.initialized && QU(`linkifyjs: already initialized - will not register custom scheme "${t}" ${eW}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  st.customSchemes.push([t, e]);
}
function nW() {
  st.scanner = GU(st.customSchemes);
  for (let t = 0; t < st.tokenQueue.length; t++)
    st.tokenQueue[t][1]({
      scanner: st.scanner
    });
  st.parser = XU(st.scanner.tokens);
  for (let t = 0; t < st.pluginQueue.length; t++)
    st.pluginQueue[t][1]({
      scanner: st.scanner,
      parser: st.parser
    });
  return st.initialized = !0, st;
}
function c0(t) {
  return st.initialized || nW(), ZU(st.parser.start, t, O6(st.scanner.start, t));
}
c0.scan = O6;
function D6(t, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const o = new l0(n), r = c0(t), i = [];
  for (let s = 0; s < r.length; s++) {
    const a = r[s];
    a.isLink && (!e || a.t === e) && o.check(a) && i.push(a.toFormattedObject(o));
  }
  return i;
}
function oW(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function rW(t) {
  return new Ne({
    key: new Be("autolink"),
    appendTransaction: (e, n, o) => {
      const r = e.some((c) => c.docChanged) && !n.doc.eq(o.doc), i = e.some((c) => c.getMeta("preventAutolink"));
      if (!r || i)
        return;
      const { tr: s } = o, a = bS(n.doc, [...e]);
      if (AS(a).forEach(({ newRange: c }) => {
        const d = xS(o.doc, c, (h) => h.isTextblock);
        let u, f;
        if (d.length > 1 ? (u = d[0], f = o.doc.textBetween(u.pos, u.pos + u.node.nodeSize, void 0, " ")) : d.length && o.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (u = d[0], f = o.doc.textBetween(u.pos, c.to, void 0, " ")), u && f) {
          const h = f.split(" ").filter((y) => y !== "");
          if (h.length <= 0)
            return !1;
          const m = h[h.length - 1], g = u.pos + f.lastIndexOf(m);
          if (!m)
            return !1;
          const v = c0(m).map((y) => y.toObject(t.defaultProtocol));
          if (!oW(v))
            return !1;
          v.filter((y) => y.isLink).map((y) => ({
            ...y,
            from: g + y.start + 1,
            to: g + y.end + 1
          })).filter((y) => o.schema.marks.code ? !o.doc.rangeHasMark(y.from, y.to, o.schema.marks.code) : !0).filter((y) => t.validate(y.value)).filter((y) => t.shouldAutoLink(y.value)).forEach((y) => {
            Im(y.from, y.to, o.doc).some((x) => x.mark.type === t.type) || s.addMark(y.from, y.to, t.type.create({
              href: y.href
            }));
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function iW(t) {
  return new Ne({
    key: new Be("handleClickLink"),
    props: {
      handleClick: (e, n, o) => {
        var r, i;
        if (o.button !== 0 || !e.editable)
          return !1;
        let s = o.target;
        const a = [];
        for (; s.nodeName !== "DIV"; )
          a.push(s), s = s.parentNode;
        if (!a.find((f) => f.nodeName === "A"))
          return !1;
        const l = s2(e.state, t.type.name), c = o.target, d = (r = c == null ? void 0 : c.href) !== null && r !== void 0 ? r : l.href, u = (i = c == null ? void 0 : c.target) !== null && i !== void 0 ? i : l.target;
        return c && d ? (window.open(d, u), !0) : !1;
      }
    }
  });
}
function sW(t) {
  return new Ne({
    key: new Be("handlePasteLink"),
    props: {
      handlePaste: (e, n, o) => {
        const { state: r } = e, { selection: i } = r, { empty: s } = i;
        if (s)
          return !1;
        let a = "";
        o.content.forEach((c) => {
          a += c.textContent;
        });
        const l = D6(a, { defaultProtocol: t.defaultProtocol }).find((c) => c.isLink && c.value === a);
        return !a || !l ? !1 : t.editor.commands.setMark(t.type, {
          href: l.href
        });
      }
    }
  });
}
const aW = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function qr(t, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return e && e.forEach((o) => {
    const r = typeof o == "string" ? o : o.scheme;
    r && n.push(r);
  }), !t || t.replace(aW, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const lW = Qt.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        ib(t);
        return;
      }
      ib(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    tW();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, e) => !!qr(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const e = t.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (n) => !!qr(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!qr(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", He(this.options.HTMLAttributes, t), 0] : [
      "a",
      He(this.options.HTMLAttributes, { ...t, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (o) => !!qr(o, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (o) => !!qr(o, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() : !1;
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Er({
        find: (t) => {
          const e = [];
          if (t) {
            const { protocols: n, defaultProtocol: o } = this.options, r = D6(t).filter((i) => i.isLink && this.options.isAllowedUri(i.value, {
              defaultValidate: (s) => !!qr(s, n),
              protocols: n,
              defaultProtocol: o
            }));
            r.length && r.forEach((i) => e.push({
              text: i.value,
              data: {
                href: i.href
              },
              index: i.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: e, defaultProtocol: n } = this.options;
    return this.options.autolink && t.push(rW({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (o) => this.options.isAllowedUri(o, {
        defaultValidate: (r) => !!qr(r, e),
        protocols: e,
        defaultProtocol: n
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === !0 && t.push(iW({
      type: this.type
    })), this.options.linkOnPaste && t.push(sW({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t;
  }
}), cW = /* @__PURE__ */ T({
  __name: "LinkEditPopover",
  props: {
    editor: {},
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    shortcutKeys: { default: void 0 },
    isActive: { type: Function, default: void 0 },
    action: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    function n(o, r, i) {
      e.action && e.action({ link: o, text: r, openInNewTab: i });
    }
    return (o, r) => (k(), _(p(Ls), null, {
      default: w(() => [
        E(p(Ns), { disabled: o.disabled }, {
          default: w(() => [
            E(ye, {
              icon: o.icon,
              tooltip: o.tooltip,
              "is-active": o.isActive,
              disabled: o.disabled
            }, null, 8, ["icon", "tooltip", "is-active", "disabled"])
          ]),
          _: 1
        }, 8, ["disabled"]),
        E(p(Bs), {
          "hide-when-detached": "",
          "as-child": "",
          class: "w-full",
          align: "start",
          side: "bottom"
        }, {
          default: w(() => [
            E(y3, {
              editor: o.editor,
              onOnSetLink: n
            }, null, 8, ["editor"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), AJ = lW.extend({
  inclusive: !1,
  parseHTML() {
    return [
      {
        tag: 'a[href]:not([data-type="button"]):not([href *= "javascript:" i])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "a",
      He(this.options.HTMLAttributes, t, {
        class: "link"
      }),
      0
    ];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      openOnClick: !0,
      button: ({ editor: e, t: n }) => ({
        component: cW,
        componentProps: {
          action: (o) => {
            const { link: r, text: i, openInNewTab: s } = o;
            e.chain().extendMarkRange("link").insertContent({
              type: "text",
              text: i,
              marks: [
                {
                  type: "link",
                  attrs: {
                    href: r,
                    target: s ? "_blank" : ""
                  }
                }
              ]
            }).setLink({ href: r }).focus().run();
          },
          isActive: () => e.isActive("link") || !1,
          disabled: !e.can().setLink({ href: "" }),
          icon: "Link",
          tooltip: n("editor.link.tooltip")
        }
      })
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ne({
        props: {
          handleClick: (t, e) => {
            const { schema: n, doc: o, tr: r } = t.state, i = du(o.resolve(e), n.marks.link);
            if (!i)
              return !1;
            const s = o.resolve(i.from), a = o.resolve(i.to), l = r.setSelection(new le(s, a));
            t.dispatch(l);
          }
        }
      })
    ];
  }
}), dW = ot.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", He(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        const { selection: n } = e, { $from: o, $to: r } = n, i = t();
        return o.parentOffset === 0 ? i.insertContentAt({
          from: Math.max(o.pos - 1, 0),
          to: r.pos
        }, {
          type: this.name
        }) : a2(n) ? i.insertContentAt(r.pos, {
          type: this.name
        }) : i.insertContent({ type: this.name }), i.command(({ tr: s, dispatch: a }) => {
          var l;
          if (a) {
            const { $to: c } = s.selection, d = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? s.setSelection(le.create(s.doc, c.pos + 1)) : c.nodeAfter.isBlock ? s.setSelection(de.create(s.doc, c.pos)) : s.setSelection(le.create(s.doc, c.pos));
            else {
              const u = (l = c.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              u && (s.insert(d, u), s.setSelection(le.create(s.doc, d + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      d2({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), EJ = dW.extend({
  renderHTML() {
    return [
      "div",
      He(this.options.HTMLAttributes, {
        "data-type": this.name
      }),
      ["hr"]
    ];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: ye,
        componentProps: {
          action: () => e.commands.setHorizontalRule(),
          disabled: !e.can().setHorizontalRule(),
          icon: "Minus",
          shortcutKeys: ["mod", "alt", "S"],
          tooltip: n("editor.horizontalrule.tooltip")
        }
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-s": () => this.editor.commands.setHorizontalRule()
    };
  }
});
var Jd = 200, Ct = function() {
};
Ct.prototype.append = function(e) {
  return e.length ? (e = Ct.from(e), !this.length && e || e.length < Jd && this.leafAppend(e) || this.length < Jd && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Ct.prototype.prepend = function(e) {
  return e.length ? Ct.from(e).append(this) : this;
};
Ct.prototype.appendInner = function(e) {
  return new uW(this, e);
};
Ct.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? Ct.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
Ct.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Ct.prototype.forEach = function(e, n, o) {
  n === void 0 && (n = 0), o === void 0 && (o = this.length), n <= o ? this.forEachInner(e, n, o, 0) : this.forEachInvertedInner(e, n, o, 0);
};
Ct.prototype.map = function(e, n, o) {
  n === void 0 && (n = 0), o === void 0 && (o = this.length);
  var r = [];
  return this.forEach(function(i, s) {
    return r.push(e(i, s));
  }, n, o), r;
};
Ct.from = function(e) {
  return e instanceof Ct ? e : e && e.length ? new R6(e) : Ct.empty;
};
var R6 = /* @__PURE__ */ function(t) {
  function e(o) {
    t.call(this), this.values = o;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(r, i) {
    return r == 0 && i == this.length ? this : new e(this.values.slice(r, i));
  }, e.prototype.getInner = function(r) {
    return this.values[r];
  }, e.prototype.forEachInner = function(r, i, s, a) {
    for (var l = i; l < s; l++)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, a) {
    for (var l = i - 1; l >= s; l--)
      if (r(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(r) {
    if (this.length + r.length <= Jd)
      return new e(this.values.concat(r.flatten()));
  }, e.prototype.leafPrepend = function(r) {
    if (this.length + r.length <= Jd)
      return new e(r.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(Ct);
Ct.empty = new R6([]);
var uW = /* @__PURE__ */ function(t) {
  function e(n, o) {
    t.call(this), this.left = n, this.right = o, this.length = n.length + o.length, this.depth = Math.max(n.depth, o.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(o) {
    return o < this.left.length ? this.left.get(o) : this.right.get(o - this.left.length);
  }, e.prototype.forEachInner = function(o, r, i, s) {
    var a = this.left.length;
    if (r < a && this.left.forEachInner(o, r, Math.min(i, a), s) === !1 || i > a && this.right.forEachInner(o, Math.max(r - a, 0), Math.min(this.length, i) - a, s + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(o, r, i, s) {
    var a = this.left.length;
    if (r > a && this.right.forEachInvertedInner(o, r - a, Math.max(i, a) - a, s + a) === !1 || i < a && this.left.forEachInvertedInner(o, Math.min(r, a), i, s) === !1)
      return !1;
  }, e.prototype.sliceInner = function(o, r) {
    if (o == 0 && r == this.length)
      return this;
    var i = this.left.length;
    return r <= i ? this.left.slice(o, r) : o >= i ? this.right.slice(o - i, r - i) : this.left.slice(o, i).append(this.right.slice(0, r - i));
  }, e.prototype.leafAppend = function(o) {
    var r = this.right.leafAppend(o);
    if (r)
      return new e(this.left, r);
  }, e.prototype.leafPrepend = function(o) {
    var r = this.left.leafPrepend(o);
    if (r)
      return new e(r, this.right);
  }, e.prototype.appendInner = function(o) {
    return this.left.depth >= Math.max(this.right.depth, o.depth) + 1 ? new e(this.left, new e(this.right, o)) : new e(this, o);
  }, e;
}(Ct);
const fW = 500;
class Bn {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let o = this.items.length;
    for (; ; o--)
      if (this.items.get(o - 1).selection) {
        --o;
        break;
      }
    let r, i;
    n && (r = this.remapping(o, this.items.length), i = r.maps.length);
    let s = e.tr, a, l, c = [], d = [];
    return this.items.forEach((u, f) => {
      if (!u.step) {
        r || (r = this.remapping(o, f + 1), i = r.maps.length), i--, d.push(u);
        return;
      }
      if (r) {
        d.push(new Kn(u.map));
        let h = u.step.map(r.slice(i)), m;
        h && s.maybeStep(h).doc && (m = s.mapping.maps[s.mapping.maps.length - 1], c.push(new Kn(m, void 0, void 0, c.length + d.length))), i--, m && r.appendMap(m, i);
      } else
        s.maybeStep(u.step);
      if (u.selection)
        return a = r ? u.selection.map(r.slice(i)) : u.selection, l = new Bn(this.items.slice(0, o).append(d.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: s, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, o, r) {
    let i = [], s = this.eventCount, a = this.items, l = !r && a.length ? a.get(a.length - 1) : null;
    for (let d = 0; d < e.steps.length; d++) {
      let u = e.steps[d].invert(e.docs[d]), f = new Kn(e.mapping.maps[d], u, n), h;
      (h = l && l.merge(f)) && (f = h, d ? i.pop() : a = a.slice(0, a.length - 1)), i.push(f), n && (s++, n = void 0), r || (l = f);
    }
    let c = s - o.depth;
    return c > hW && (a = pW(a, c), s -= c), new Bn(a.append(i), s);
  }
  remapping(e, n) {
    let o = new Xi();
    return this.items.forEach((r, i) => {
      let s = r.mirrorOffset != null && i - r.mirrorOffset >= e ? o.maps.length - r.mirrorOffset : void 0;
      o.appendMap(r.map, s);
    }, e, n), o;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new Bn(this.items.append(e.map((n) => new Kn(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let o = [], r = Math.max(0, this.items.length - n), i = e.mapping, s = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, r);
    let l = n;
    this.items.forEach((f) => {
      let h = i.getMirror(--l);
      if (h == null)
        return;
      s = Math.min(s, h);
      let m = i.maps[h];
      if (f.step) {
        let g = e.steps[h].invert(e.docs[h]), v = f.selection && f.selection.map(i.slice(l + 1, h));
        v && a++, o.push(new Kn(m, g, v));
      } else
        o.push(new Kn(m));
    }, r);
    let c = [];
    for (let f = n; f < s; f++)
      c.push(new Kn(i.maps[f]));
    let d = this.items.slice(0, r).append(c).append(o), u = new Bn(d, a);
    return u.emptyItemCount() > fW && (u = u.compress(this.items.length - o.length)), u;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), o = n.maps.length, r = [], i = 0;
    return this.items.forEach((s, a) => {
      if (a >= e)
        r.push(s), s.selection && i++;
      else if (s.step) {
        let l = s.step.map(n.slice(o)), c = l && l.getMap();
        if (o--, c && n.appendMap(c, o), l) {
          let d = s.selection && s.selection.map(n.slice(o));
          d && i++;
          let u = new Kn(c.invert(), l, d), f, h = r.length - 1;
          (f = r.length && r[h].merge(u)) ? r[h] = f : r.push(u);
        }
      } else
        s.map && o--;
    }, this.items.length, 0), new Bn(Ct.from(r.reverse()), i);
  }
}
Bn.empty = new Bn(Ct.empty, 0);
function pW(t, e) {
  let n;
  return t.forEach((o, r) => {
    if (o.selection && e-- == 0)
      return n = r, !1;
  }), t.slice(n);
}
class Kn {
  constructor(e, n, o, r) {
    this.map = e, this.step = n, this.selection = o, this.mirrorOffset = r;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new Kn(n.getMap().invert(), n, this.selection);
    }
  }
}
class cr {
  constructor(e, n, o, r, i) {
    this.done = e, this.undone = n, this.prevRanges = o, this.prevTime = r, this.prevComposition = i;
  }
}
const hW = 20;
function mW(t, e, n, o) {
  let r = n.getMeta(ui), i;
  if (r)
    return r.historyState;
  n.getMeta(yW) && (t = new cr(t.done, t.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (s && s.getMeta(ui))
    return s.getMeta(ui).redo ? new cr(t.done.addTransform(n, void 0, o, zc(e)), t.undone, sb(n.mapping.maps), t.prevTime, t.prevComposition) : new cr(t.done, t.undone.addTransform(n, void 0, o, zc(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), l = t.prevTime == 0 || !s && t.prevComposition != a && (t.prevTime < (n.time || 0) - o.newGroupDelay || !gW(n, t.prevRanges)), c = s ? mp(t.prevRanges, n.mapping) : sb(n.mapping.maps);
    return new cr(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, o, zc(e)), Bn.empty, c, n.time, a ?? t.prevComposition);
  } else
    return (i = n.getMeta("rebased")) ? new cr(t.done.rebased(n, i), t.undone.rebased(n, i), mp(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new cr(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), mp(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function gW(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((o, r) => {
    for (let i = 0; i < e.length; i += 2)
      o <= e[i + 1] && r >= e[i] && (n = !0);
  }), n;
}
function sb(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((o, r, i, s) => e.push(i, s));
  return e;
}
function mp(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let o = 0; o < t.length; o += 2) {
    let r = e.map(t[o], 1), i = e.map(t[o + 1], -1);
    r <= i && n.push(r, i);
  }
  return n;
}
function vW(t, e, n) {
  let o = zc(e), r = ui.get(e).spec.config, i = (n ? t.undone : t.done).popEvent(e, o);
  if (!i)
    return null;
  let s = i.selection.resolve(i.transform.doc), a = (n ? t.done : t.undone).addTransform(i.transform, e.selection.getBookmark(), r, o), l = new cr(n ? a : i.remaining, n ? i.remaining : a, null, 0, -1);
  return i.transform.setSelection(s).setMeta(ui, { redo: n, historyState: l });
}
let gp = !1, ab = null;
function zc(t) {
  let e = t.plugins;
  if (ab != e) {
    gp = !1, ab = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        gp = !0;
        break;
      }
  }
  return gp;
}
const ui = new Be("history"), yW = new Be("closeHistory");
function bW(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new Ne({
    key: ui,
    state: {
      init() {
        return new cr(Bn.empty, Bn.empty, null, 0, -1);
      },
      apply(e, n, o) {
        return mW(n, o, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let o = n.inputType, r = o == "historyUndo" ? L6 : o == "historyRedo" ? N6 : null;
          return r ? (n.preventDefault(), r(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function P6(t, e) {
  return (n, o) => {
    let r = ui.getState(n);
    if (!r || (t ? r.undone : r.done).eventCount == 0)
      return !1;
    if (o) {
      let i = vW(r, n, t);
      i && o(e ? i.scrollIntoView() : i);
    }
    return !0;
  };
}
const L6 = P6(!1, !0), N6 = P6(!0, !0), wW = Te.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => L6(t, e),
      redo: () => ({ state: t, dispatch: e }) => N6(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      bW(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), _J = wW.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      depth: 10,
      button: ({ editor: e, t: n }) => ["undo", "redo"].map((r) => ({
        component: ye,
        componentProps: {
          action: () => {
            r === "undo" && e.commands.undo(), r === "redo" && e.commands.redo();
          },
          shortcutKeys: r === "undo" ? ["mod", "Z"] : ["shift", "mod", "Z"],
          disabled: !e.can()[r](),
          icon: r === "undo" ? "Undo2" : "Redo2",
          tooltip: n(`editor.${r}.tooltip`)
        }
      }))
    };
  }
}), { isFullscreen: vp, toggleFullscreen: yp } = pn(), MJ = Te.create({
  name: "fullscreen",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ye,
        componentProps: {
          tooltip: vp.value ? o("editor.fullscreen.tooltip.exit") : o("editor.fullscreen.tooltip.fullscreen"),
          action: () => yp(),
          icon: vp.value ? "Minimize" : "Maximize",
          isActive: () => vp.value
        }
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      F11: () => (yp(), !0),
      "Mod-F11": () => (yp(), !0)
    };
  }
}), xW = Te.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (t) => t.length,
      wordCounter: (t) => t.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc;
      if (((t == null ? void 0 : t.mode) || this.options.mode) === "textSize") {
        const o = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(o);
      }
      return e.nodeSize;
    }, this.storage.words = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc, n = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let t = !1;
    return [
      new Ne({
        key: new Be("characterCount"),
        appendTransaction: (e, n, o) => {
          if (t)
            return;
          const r = this.options.limit;
          if (r == null || r === 0) {
            t = !0;
            return;
          }
          const i = this.storage.characters({ node: o.doc });
          if (i > r) {
            const s = i - r, a = 0, l = s;
            console.warn(`[CharacterCount] Initial content exceeded limit of ${r} characters. Content was automatically trimmed.`);
            const c = o.tr.deleteRange(a, l);
            return t = !0, c;
          }
          t = !0;
        },
        filterTransaction: (e, n) => {
          const o = this.options.limit;
          if (!e.docChanged || o === 0 || o === null || o === void 0)
            return !0;
          const r = this.storage.characters({ node: n.doc }), i = this.storage.characters({ node: e.doc });
          if (i <= o || r > o && i > o && i <= r)
            return !0;
          if (r > o && i > o && i > r || !e.getMeta("paste"))
            return !1;
          const a = e.selection.$head.pos, l = i - o, c = a - l, d = a;
          return e.deleteRange(c, d), !(this.storage.characters({ node: e.doc }) > o);
        }
      })
    ];
  }
}), kW = ot.create({
  name: "doc",
  topNode: !0,
  content: "block+"
}), CW = kW.extend({
  content: "(block|columns)+"
  // echo editor is a block editor
});
function SW(t = {}) {
  return new Ne({
    view(e) {
      return new AW(e, t);
    }
  });
}
class AW {
  constructor(e, n) {
    var o;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (o = n.width) !== null && o !== void 0 ? o : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((r) => {
      let i = (s) => {
        this[r](s);
      };
      return e.dom.addEventListener(r, i), { name: r, handler: i };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, o;
    if (n) {
      let a = e.nodeBefore, l = e.nodeAfter;
      if (a || l) {
        let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
        if (c) {
          let d = c.getBoundingClientRect(), u = a ? d.bottom : d.top;
          a && l && (u = (u + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), o = { left: d.left, right: d.right, top: u - this.width / 2, bottom: u + this.width / 2 };
        }
      }
    }
    if (!o) {
      let a = this.editorView.coordsAtPos(this.cursorPos);
      o = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
    }
    let r = this.editorView.dom.offsetParent;
    this.element || (this.element = r.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let i, s;
    if (!r || r == document.body && getComputedStyle(r).position == "static")
      i = -pageXOffset, s = -pageYOffset;
    else {
      let a = r.getBoundingClientRect();
      i = a.left - r.scrollLeft, s = a.top - r.scrollTop;
    }
    this.element.style.left = o.left - i + "px", this.element.style.top = o.top - s + "px", this.element.style.width = o.right - o.left + "px", this.element.style.height = o.bottom - o.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), o = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), r = o && o.type.spec.disableDropCursor, i = typeof r == "function" ? r(this.editorView, n, e) : r;
    if (n && !i) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = rw(this.editorView.state.doc, s, this.editorView.dragging.slice);
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
const EW = Te.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      SW(this.options)
    ];
  }
}), _W = Te.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ne({
        key: new Be("focus"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const { isEditable: n, isFocused: o } = this.editor, { anchor: r } = e, i = [];
            if (!n || !o)
              return ze.create(t, []);
            let s = 0;
            this.options.mode === "deepest" && t.descendants((l, c) => {
              if (l.isText)
                return;
              if (!(r >= c && r <= c + l.nodeSize - 1))
                return !1;
              s += 1;
            });
            let a = 0;
            return t.descendants((l, c) => {
              if (l.isText || !(r >= c && r <= c + l.nodeSize - 1))
                return !1;
              if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                return this.options.mode === "deepest";
              i.push(ht.node(c, c + l.nodeSize, {
                class: this.options.className
              }));
            }), ze.create(t, i);
          }
        }
      })
    ];
  }
});
class ft extends pe {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let o = e.resolve(n.map(this.head));
    return ft.valid(o) ? new ft(o) : pe.near(o);
  }
  content() {
    return ee.empty;
  }
  eq(e) {
    return e instanceof ft && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new ft(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new d0(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !MW(e) || !TW(e))
      return !1;
    let o = n.type.spec.allowGapCursor;
    if (o != null)
      return o;
    let r = n.contentMatchAt(e.index()).defaultType;
    return r && r.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, o = !1) {
    e:
      for (; ; ) {
        if (!o && ft.valid(e))
          return e;
        let r = e.pos, i = null;
        for (let s = e.depth; ; s--) {
          let a = e.node(s);
          if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
            i = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
            break;
          } else if (s == 0)
            return null;
          r += n;
          let l = e.doc.resolve(r);
          if (ft.valid(l))
            return l;
        }
        for (; ; ) {
          let s = n > 0 ? i.firstChild : i.lastChild;
          if (!s) {
            if (i.isAtom && !i.isText && !de.isSelectable(i)) {
              e = e.doc.resolve(r + i.nodeSize * n), o = !1;
              continue e;
            }
            break;
          }
          i = s, r += n;
          let a = e.doc.resolve(r);
          if (ft.valid(a))
            return a;
        }
        return null;
      }
  }
}
ft.prototype.visible = !1;
ft.findFrom = ft.findGapCursorFrom;
pe.jsonID("gapcursor", ft);
class d0 {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new d0(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return ft.valid(n) ? new ft(n) : pe.near(n);
  }
}
function MW(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), o = t.node(e);
    if (n == 0) {
      if (o.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = o.child(n - 1); ; r = r.lastChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function TW(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), o = t.node(e);
    if (n == o.childCount) {
      if (o.type.spec.isolating)
        return !0;
      continue;
    }
    for (let r = o.child(n); ; r = r.firstChild) {
      if (r.childCount == 0 && !r.inlineContent || r.isAtom || r.type.spec.isolating)
        return !0;
      if (r.inlineContent)
        return !1;
    }
  }
  return !0;
}
function OW() {
  return new Ne({
    props: {
      decorations: PW,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && ft.valid(n) ? new ft(n) : null;
      },
      handleClick: DW,
      handleKeyDown: IW,
      handleDOMEvents: { beforeinput: RW }
    }
  });
}
const IW = xm({
  ArrowLeft: wc("horiz", -1),
  ArrowRight: wc("horiz", 1),
  ArrowUp: wc("vert", -1),
  ArrowDown: wc("vert", 1)
});
function wc(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(o, r, i) {
    let s = o.selection, a = e > 0 ? s.$to : s.$from, l = s.empty;
    if (s instanceof le) {
      if (!i.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = o.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let c = ft.findGapCursorFrom(a, e, l);
    return c ? (r && r(o.tr.setSelection(new ft(c))), !0) : !1;
  };
}
function DW(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let o = t.state.doc.resolve(e);
  if (!ft.valid(o))
    return !1;
  let r = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return r && r.inside > -1 && de.isSelectable(t.state.doc.nodeAt(r.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new ft(o))), !0);
}
function RW(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof ft))
    return !1;
  let { $from: n } = t.state.selection, o = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!o)
    return !1;
  let r = W.empty;
  for (let s = o.length - 1; s >= 0; s--)
    r = W.from(o[s].createAndFill(null, r));
  let i = t.state.tr.replace(n.pos, n.pos, new ee(r, 0, 0));
  return i.setSelection(le.near(i.doc.resolve(n.pos + 1))), t.dispatch(i), !1;
}
function PW(t) {
  if (!(t.selection instanceof ft))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", ze.create(t.doc, [ht.widget(t.selection.head, e, { key: "gapcursor" })]);
}
const LW = Te.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      OW()
    ];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = Ee(oe(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
}), NW = ot.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", He(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: o }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: r, storedMarks: i } = n;
          if (r.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: a } = o.extensionManager, l = i || r.$to.parentOffset && r.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: d }) => {
            if (d && l && s) {
              const u = l.filter((f) => a.includes(f.type.name));
              c.ensureMarks(u);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), BW = ot.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", He(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), $W = ot.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), zW = Te.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ne({
        key: new Be("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: o } = e, r = [];
            if (!n)
              return null;
            const i = this.editor.isEmpty;
            return t.descendants((s, a) => {
              const l = o >= a && o <= a + s.nodeSize, c = !s.isLeaf && hu(s);
              if ((l || !this.options.showOnlyCurrent) && c) {
                const d = [this.options.emptyNodeClass];
                i && d.push(this.options.emptyEditorClass);
                const u = ht.node(a, a + s.nodeSize, {
                  class: d.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: s,
                    pos: a,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                r.push(u);
              }
              return this.options.includeChildren;
            }), ze.create(t, r);
          }
        }
      })
    ];
  }
}), FW = ot.create({
  name: "text",
  group: "inline"
});
function lb({ types: t, node: e }) {
  return Array.isArray(t) && t.includes(e.type) || e.type === t;
}
const HW = Te.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: ["paragraph"]
    };
  },
  addProseMirrorPlugins() {
    const t = new Be(this.name), e = Object.entries(this.editor.schema.nodes).map(([, n]) => n).filter((n) => this.options.notAfter.includes(n.name));
    return [
      new Ne({
        key: t,
        appendTransaction: (n, o, r) => {
          const { doc: i, tr: s, schema: a } = r, l = t.getState(r), c = i.content.size, d = a.nodes[this.options.node];
          if (l)
            return s.insert(c, d.create());
        },
        state: {
          init: (n, o) => {
            const r = o.tr.doc.lastChild;
            return !lb({ node: r, types: e });
          },
          apply: (n, o) => {
            if (!n.docChanged)
              return o;
            const r = n.doc.lastChild;
            return !lb({ node: r, types: e });
          }
        }
      })
    ];
  }
}), VW = Te.create({
  name: "selection",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Ne({
        key: new Be("selection"),
        props: {
          decorations(e) {
            return e.selection.empty || t.isFocused === !0 ? null : ze.create(e.doc, [
              ht.inline(e.selection.from, e.selection.to, {
                class: "selection"
              })
            ]);
          }
        }
      })
    ];
  }
}), jW = [
  { label: "优酷", value: "youku", icon: "Youku" },
  {
    label: "哔哩哔哩",
    value: "bilibili",
    icon: "BiliBili"
  },
  {
    label: "腾讯视频",
    value: "qqvideo",
    icon: "QQVideo"
  }
], UW = [
  { label: "高德地图", value: "amap", icon: "Gaode" },
  { label: "百度地图", value: "baidu_map", icon: "Baidu" }
], WW = [
  { label: "墨刀", value: "modao", icon: "Modao" },
  { label: "蓝湖", value: "lanhu", icon: "Lanhu" },
  { label: "Figma", value: "figma", icon: "Figma" },
  { label: "Canva", value: "canva", icon: "Canva" },
  { label: "ProcessOn", value: "processon", icon: "Processon" }
], KW = [{ label: "CodePen", value: "codepen", icon: "Codepen" }], qW = [{ label: "金数据", value: "jinshuju", icon: "Jinshuju" }], GW = [], JW = [
  ...jW,
  ...UW,
  ...WW,
  ...KW,
  ...qW,
  ...GW
], Di = {
  youtube: {
    example: "https://www.youtube.com/watch?v=I4sMhHbHYXM",
    src: "https://www.youtube.com/embed/I4sMhHbHYXM",
    srcPrefix: "https://www.youtube.com/embed",
    linkRule: ["www.youtube.com\\/watch\\?v=\\w+"]
  },
  youku: {
    example: "https://v.youku.com/v_show/id_XNDM0NDM4MTcy.html?spm=a2h0c.8166622.PhoneSokuUgc_4.dtitle",
    src: "https://player.youku.com/embed/XNDM0NDM4MTcy",
    srcPrefix: "https://player.youku.com/embed",
    linkRule: ["v.youku.com\\/v_show\\/id_\\w+\\=*"],
    idRule: "id_\\w+\\=*"
  },
  bilibili: {
    example: "https://www.bilibili.com/video/BV1EJ411u7DN",
    src: "https://player.bilibili.com/player.html?bvid=BV1EJ411u7DN",
    srcPrefix: "https://player.bilibili.com/player.html?bvid",
    linkRule: ["www.bilibili.com\\/video\\/\\w+"]
  },
  qqvideo: {
    example: "https://v.qq.com/x/cover/mzc0020006aw1mn/u0033nvzb5v.html",
    src: "https://v.qq.com/txp/iframe/player.html?vid=u0033nvzb5v",
    srcPrefix: "https://v.qq.com/txp/iframe/player.html?vid",
    linkRule: ["v.qq.com\\/x\\/cover\\/\\w+\\/\\w+"]
  },
  amap: {
    example: "https://ditu.amap.com/",
    src: "https://www.amap.com/place/B000A45467",
    srcPrefix: "",
    linkRule: ["\\.amap\\.com"]
  },
  baidu_map: {
    example: "https://j.map.baidu.com/15/fo",
    src: "https://j.map.baidu.com/15/fo",
    srcPrefix: "",
    linkRule: ["map\\.baidu\\.com"]
  },
  modao: {
    example: "https://free.modao.cc/app/2cd26580a6717a147454df7470e7ec464093cba3/embed/v2#screen=sk71k6d1dfxulzx",
    src: "https://free.modao.cc/app/6UkpAxcGE3nPz52GLqhnOZgC7MATBSy/embed/v2",
    srcPrefix: "",
    linkRule: ["https:\\/\\/\\w+.modao.cc\\/app\\/\\w+\\/embed\\/v2"],
    tips: "Modao > More > Share > Embed > COPY"
  },
  lanhu: {
    example: "https://lanhuapp.com/link/#/invite?sid=evP7L",
    src: "https://lanhuapp.com/url/evP7L",
    srcPrefix: "",
    linkRule: ["https:\\/\\/lanhuapp.com\\/url\\/\\w+"],
    tips: "Lanhu > Project > Share > Copy Link"
  },
  figma: {
    example: "https://www.figma.com/file/aS9uSgPXoNpaPkzbjNcK8v/Demo?node-id=0%3A1",
    src: "https://www.figma.com/file/aS9uSgPXoNpaPkzbjNcK8v/Demo?node-id=0%3A1",
    srcPrefix: "https://www.figma.com/embed?embed_host=share&url",
    linkRule: ["https:\\/\\/www.figma.com\\/file\\/\\w+"]
  },
  canva: {
    example: "https://www.canva.cn/design/DAD61-t29UI/view",
    src: "https://www.canva.cn/design/DAD61-t29UI/view",
    srcPrefix: "",
    linkRule: ["https:\\/\\/www.canva.cn\\/design\\/.+\\/view"]
  },
  processon: {
    example: "https://www.processon.com/embed/5ea99d8607912948b0e6fe78",
    src: "https://www.processon.com/embed/5ea99d8607912948b0e6fe78",
    srcPrefix: "",
    linkRule: ["https:\\/\\/www.processon.com\\/embed\\/\\w+"]
  },
  codepen: {
    example: "https://codepen.io/mekery/embed/YzyrKOJ",
    src: "https://codepen.io/mekery/embed/YzyrKOJ",
    srcPrefix: "",
    linkRule: ["https:\\/\\/codepen.io\\/.+\\/embed\\/\\w+"]
  },
  jinshuju: {
    example: "https://jinshuju.net/f/q9YvVf",
    src: "https://jinshuju.net/f/q9YvVf",
    srcPrefix: "",
    linkRule: ["https:\\/\\/jinshuju.net\\/f\\/\\w+"]
  },
  iframe: {
    example: "https://v.youku.com/v_show/id_XNDM0NDM4MTcy.html",
    src: "https://player.youku.com/embed/XNDM0NDM4MTcy",
    srcPrefix: "",
    linkRule: [".+"]
  }
};
function YW(t, e) {
  let n = Di.youtube, o = e.matchedUrl;
  e.validLink = !0;
  let r = o.split("="), i = r.length;
  if (i > 0) {
    let s = r[i - 1];
    e.src = `${n.srcPrefix}/${s}`, e.validId = !0;
  }
  return e;
}
function XW(t, e) {
  let n = Di.youku, o = e.matchedUrl, r = n.idRule, i = new RegExp(r), s = o.match(i);
  if (s && s.length > 0) {
    let a = s[0].substr(3);
    e.validId = !0, e.src = `${n.srcPrefix}/${a}`;
  } else
    e.validId = !1;
  return e;
}
function ZW(t, e) {
  let n = Di.bilibili, r = e.matchedUrl.split("/"), i = r.length;
  if (i > 0) {
    let s = r[i - 1];
    e.src = `${n.srcPrefix}=${s}`, e.validId = !0;
  }
  return e;
}
function QW(t, e) {
  let n = Di.qqvideo, r = e.matchedUrl.split("/"), i = r.length;
  if (i > 0) {
    let s = r[i - 1];
    e.src = `${n.srcPrefix}=${s}`, e.validId = !0;
  }
  return e;
}
function eK(t, e) {
  return e.src = t, e.validId = !0, e;
}
function tK(t, e) {
  return e.src = t, e.validId = !0, e;
}
function nK(t, e) {
  return e.src = e.matchedUrl, e.validId = !0, e.originalLink = e.src, e;
}
function oK(t, e) {
  return e.src = e.matchedUrl, e.validId = !0, e.originalLink = e.src, e;
}
function rK(t, e) {
  return e.src = e.matchedUrl, e.validId = !0, e.originalLink = e.src, e;
}
function iK(t, e) {
  let n = Di.figma;
  return e.src = `${n.srcPrefix}=${encodeURIComponent(e.matchedUrl)}`, e.validId = !0, e.originalLink = e.matchedUrl, e;
}
function sK(t, e) {
  return e.src = `${e.matchedUrl}?embed`, e.validId = !0, e.originalLink = t, e;
}
function aK(t, e) {
  return e.src = `${e.matchedUrl}`, e.validId = !0, e.originalLink = t, e;
}
function lK(t, e) {
  return e.src = `${e.matchedUrl}`, e.validId = !0, e.originalLink = e.src, e;
}
function cK(t, e) {
  return e.src = `${e.matchedUrl}?background=white&banner=show&embedded=true`, e.validId = !0, e.originalLink = t, e;
}
function dK(t, e) {
  return e.src = `${e.matchedUrl}`, e.validId = !0, e.originalLink = t, e;
}
function uK(t, e, n) {
  let r = Di[t].linkRule;
  for (var i of r) {
    let s = new RegExp(i), a = e.match(s);
    if (a && a.length > 0)
      return n.validLink = !0, n.matchedUrl = a[0], n;
  }
  return n;
}
function fK(t) {
  let e = "", n = Di[t];
  return n && (e = n.example), e;
}
const cb = (t, e) => {
  let n = {
    validLink: !1,
    validId: !1,
    matchedUrl: "",
    originalLink: e,
    src: ""
  };
  if (n = uK(t, e, n), !n.validLink)
    return n;
  switch (t) {
    case "youtube":
      return YW(e, n);
    case "youku":
      return XW(e, n);
    case "bilibili":
      return ZW(e, n);
    case "qqvideo":
      return QW(e, n);
    case "amap":
      return eK(e, n);
    case "baidu_map":
      return tK(e, n);
    case "google_map":
      return nK(e, n);
    case "modao":
      return oK(e, n);
    case "lanhu":
      return rK(e, n);
    case "figma":
      return iK(e, n);
    case "canva":
      return sK(e, n);
    case "processon":
      return aK(e, n);
    case "codepen":
      return lK(e, n);
    case "jinshuju":
      return cK(e, n);
    case "iframe":
      return dK(e, n);
  }
  return n;
}, pK = {
  key: 0,
  class: "flex flex-row relative items-center"
}, hK = { class: "flex gap-2 absolute right-1 w-36" }, mK = ["src"], gK = /* @__PURE__ */ T({
  __name: "IframeNodeView",
  props: {
    ...Cl
  },
  setup(t) {
    const e = t, n = O(""), o = P({
      get: () => e.node.attrs.src,
      set: (s) => {
        n.value = s, e.updateAttributes({ src: s });
      }
    });
    function r() {
      let s = cb(e.node.attrs.service, n.value);
      s.validLink && s.validId ? o.value = s.src : console.log("暂不支持");
    }
    function i() {
      const s = fK(e.node.attrs.service);
      if (s) {
        let a = cb(e.node.attrs.service, s);
        o.value = a.src;
      }
    }
    return _e(() => {
      n.value = e.node.attrs.src;
    }), (s, a) => (k(), _(p(kl), { as: "section" }, {
      default: w(() => [
        o.value ? ae("", !0) : (k(), U("div", pK, [
          E(p(Rr), {
            "model-value": n.value,
            "onUpdate:modelValue": a[0] || (a[0] = (l) => n.value = l),
            type: "url",
            class: "h-12 pr-40",
            autofocus: "",
            placeholder: "输入链接"
          }, null, 8, ["model-value"]),
          B("div", hK, [
            E(p(Pt), {
              onClick: i,
              variant: "outline"
            }, {
              default: w(() => [
                he("示例")
              ]),
              _: 1
            }),
            E(p(Pt), {
              type: "primary",
              onClick: r
            }, {
              default: w(() => [
                he("确认")
              ]),
              _: 1
            })
          ])
        ])),
        o.value ? (k(), U("iframe", {
          key: 1,
          src: o.value,
          frameborder: "0",
          allowfullscreen: "true"
        }, null, 8, mK)) : ae("", !0)
      ]),
      _: 1
    }));
  }
}), vK = ot.create({
  name: "iframes",
  group: "block",
  atom: !0,
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      allowFullscreen: !0,
      HTMLAttributes: {
        class: "iframe-wrapper"
      }
    };
  },
  addAttributes() {
    return {
      src: {
        default: null
      },
      service: {
        default: null
      },
      frameborder: {
        default: 0
      },
      allowfullscreen: {
        default: this.options.allowFullscreen,
        parseHTML: () => this.options.allowFullscreen
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "iframe"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["div", this.options.HTMLAttributes, ["iframe", t]];
  },
  addNodeView() {
    return Sl(gK);
  },
  addCommands() {
    return {
      setIframe: (t) => ({ tr: e, dispatch: n }) => {
        const { selection: o } = e, r = this.type.create(t);
        return n && e.replaceRangeWith(o.from, o.to, r), !0;
      }
    };
  }
}), yK = (t) => {
  const e = ["size-small", "size-medium", "size-large"], n = ["SizeS", "SizeM", "SizeL"];
  return e.map((o, r) => ({
    type: `video-${o}`,
    component: ye,
    componentProps: {
      tooltip: `editor.${o.replace("-", ".")}.tooltip`,
      icon: n[r],
      action: () => t.commands.updateVideo({ width: od[o] }),
      isActive: () => t.isActive("video", { width: od[o] })
    }
  }));
}, bK = (t) => [
  ...yK(t),
  {
    type: "remove",
    component: ye,
    componentProps: {
      tooltip: "editor.remove",
      icon: "Trash2",
      action: () => {
        const { state: e, dispatch: n } = t.view;
        km(e, n);
      }
    }
  }
], wK = (t, e, { editor: n, extension: o, t: r }) => {
  const { extensions: i = [] } = n.extensionManager, s = {};
  for (const a of Object.keys(t)) {
    const l = t[a];
    if (!l)
      continue;
    const c = [];
    for (const f of l) {
      if (f === "divider") {
        const g = c[c.length - 1];
        if ((g == null ? void 0 : g.type) === "divider")
          continue;
        c.push({
          type: "divider",
          component: void 0,
          componentProps: {}
        });
        continue;
      }
      const h = e.find((g) => g.type === f);
      if (h) {
        c.push({
          ...h,
          componentProps: {
            ...h.componentProps,
            tooltip: h.componentProps.tooltip ? r(h.componentProps.tooltip) : void 0
          },
          componentSlots: h.componentSlots
        });
        continue;
      }
      const m = i.find((g) => g.name === f);
      if (m) {
        const { button: g } = m.options, v = g({
          editor: n,
          extension: m,
          t: r
        });
        c.push({
          type: f,
          component: v.component,
          componentProps: v.componentProps,
          componentSlots: v.componentSlots
        });
        continue;
      }
    }
    const d = c[c.length - 1], u = c[0];
    (d == null ? void 0 : d.type) === "divider" && c.pop(), (u == null ? void 0 : u.type) === "divider" && c.shift(), s[a] = c;
  }
  return s;
}, xK = { class: "flex items-center gap-2 px-2" }, kK = /* @__PURE__ */ T({
  __name: "TextDropdown",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    maxHeight: { default: void 0 },
    icon: { default: void 0 },
    tooltip: { default: "" }
  },
  setup(t) {
    const e = t, { t: n } = et(), o = P(() => [
      {
        name: "paragraph",
        label: n.value("editor.paragraph.tooltip"),
        iconName: "Paragraph",
        isActive: () => e.editor.isActive("paragraph") && !e.editor.isActive("orderedList") && !e.editor.isActive("bulletList") && !e.editor.isActive("taskList"),
        action: () => e.editor.chain().focus().clearNodes().run()
      },
      {
        name: "heading1",
        label: n.value("editor.heading.h1.tooltip"),
        isActive: () => e.editor.isActive("heading", { level: 1 }),
        iconName: "Heading1",
        action: () => e.editor.chain().focus().clearNodes().toggleHeading({ level: 1 }).run()
      },
      {
        name: "heading2",
        label: n.value("editor.heading.h2.tooltip"),
        isActive: () => e.editor.isActive("heading", { level: 2 }),
        iconName: "Heading2",
        action: () => e.editor.chain().focus().clearNodes().toggleHeading({ level: 2 }).run()
      },
      {
        name: "heading3",
        label: n.value("editor.heading.h3.tooltip"),
        isActive: () => e.editor.isActive("heading", { level: 3 }),
        iconName: "Heading3",
        action: () => e.editor.chain().focus().clearNodes().toggleHeading({ level: 3 }).run()
      },
      {
        name: "bulletList",
        label: n.value("editor.bulletlist.tooltip"),
        isActive: () => e.editor.isActive("bulletList"),
        iconName: "List",
        action: () => e.editor.chain().focus().clearNodes().toggleBulletList().run()
      },
      {
        name: "numberedList",
        label: n.value("editor.orderedlist.tooltip"),
        isActive: () => e.editor.isActive("orderedList"),
        iconName: "ListOrdered",
        action: () => e.editor.chain().focus().clearNodes().toggleOrderedList().run()
      },
      {
        name: "taskList",
        label: n.value("editor.tasklist.tooltip"),
        isActive: () => e.editor.isActive("taskList"),
        iconName: "ListTodo",
        action: () => e.editor.chain().focus().clearNodes().toggleTaskList().run()
      },
      {
        name: "blockquote",
        label: n.value("editor.blockquote.tooltip"),
        isActive: () => e.editor.isActive("blockquote"),
        iconName: "TextQuote",
        action: () => e.editor.chain().focus().clearNodes().toggleBlockquote().run()
      },
      {
        name: "codeBlock",
        label: n.value("editor.codeblock.tooltip"),
        isActive: () => e.editor.isActive("codeBlock"),
        iconName: "Code2",
        action: () => e.editor.chain().focus().clearNodes().toggleCodeBlock().run()
      }
    ]), r = P(() => o.value.filter((i) => i.isActive()).pop() ?? {
      label: n.value("editor.modify")
    });
    return (i, s) => {
      var a;
      return k(), _(Ii, {
        title: (a = r.value) == null ? void 0 : a.label,
        sideOffset: 5
      }, {
        default: w(() => [
          (k(!0), U(ve, null, Fe(o.value, (l, c) => {
            var d;
            return k(), _(p(Vs), {
              key: c,
              onClick: l.action,
              class: "cursor-pointer",
              checked: ((d = l.isActive) == null ? void 0 : d.call(l)) || !1
            }, {
              default: w(() => [
                B("div", xK, [
                  E(p(xe), {
                    name: l.iconName,
                    class: "h3 w-3"
                  }, null, 8, ["name"]),
                  B("span", null, q(l.label), 1)
                ])
              ]),
              _: 2
            }, 1032, ["onClick", "checked"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["title"]);
    };
  }
}), CK = Te.create({
  name: "text-bubble",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      toolbar: !1,
      button: () => ({
        component: kK,
        componentProps: {}
      })
    };
  }
}), TJ = Te.create({
  name: "base-kit",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      bubble: {
        list: W7,
        defaultBubbleList: bK,
        button: ({ editor: e, extension: n, t: o }) => {
          var a;
          const { list: r = {}, defaultBubbleList: i } = ((a = n.options) == null ? void 0 : a.bubble) ?? {}, s = (i == null ? void 0 : i(e)) ?? [];
          return wK(r, s, {
            editor: e,
            extension: n,
            t: o
          });
        }
      }
    };
  },
  addExtensions() {
    const { t } = et(), e = [];
    return this.options.placeholder !== !1 && e.push(
      zW.configure({
        placeholder: ({ node: n, pos: o }) => {
          var i;
          const r = (i = n == null ? void 0 : n.type) == null ? void 0 : i.name;
          return r === "heading" ? `${t.value(`editor.heading.h${n.attrs.level}.tooltip`)}` : r === "table" || r === "codeBlock" ? "" : o === 0 ? t.value("editor.content") : t.value("editor.slash");
        },
        ...this.options.placeholder
      })
    ), this.options.focus !== !1 && e.push(
      _W.configure({
        className: "focus",
        ...this.options.focus
      })
    ), this.options.document !== !1 && e.push(CW.configure()), this.options.text !== !1 && e.push(FW.configure()), this.options.textBubble !== !1 && e.push(CK.configure()), this.options.gapcursor !== !1 && e.push(LW.configure()), this.options.dropcursor !== !1 && e.push(
      EW.configure({
        ...this.options.dropcursor,
        width: 2,
        class: "ProseMirror-dropcursor border-black"
      })
    ), this.options.characterCount !== !1 && e.push(xW.configure(this.options.characterCount)), this.options.paragraph !== !1 && e.push($W.configure(this.options.paragraph)), this.options.hardBreak !== !1 && e.push(NW.configure(this.options.hardBreak)), this.options.listItem !== !1 && e.push(BW.configure(this.options.listItem)), this.options.textStyle !== !1 && e.push(dU.configure(this.options.textStyle)), this.options.iframe !== !1 && e.push(vK.configure(this.options.iframe)), this.options.trailingNode !== !1 && e.push(HW.configure(this.options.trailingNode)), this.options.selection !== !1 && e.push(VW), e;
  }
}), B6 = Qt.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sub", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSubscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSubscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
}), $6 = Qt.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sup", He(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSuperscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
}), OJ = Te.create({
  name: "subAndSuperScript",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, extension: n, t: o }) => {
        const r = n.options.subscript, i = n.options.superscript, s = {
          component: ye,
          componentProps: {
            action: () => e.commands.toggleSubscript(),
            isActive: () => e.isActive("subscript") || !1,
            disabled: !e.can().toggleSubscript(),
            icon: "Subscript",
            tooltip: o("editor.subscript.tooltip")
          }
        }, a = {
          component: ye,
          componentProps: {
            action: () => e.commands.toggleSuperscript(),
            isActive: () => e.isActive("superscript") || !1,
            disabled: !e.can().toggleSuperscript(),
            icon: "Superscript",
            tooltip: o("editor.superscript.tooltip")
          }
        }, l = [];
        return r !== !1 && l.push(s), i !== !1 && l.push(a), l;
      }
    };
  },
  addExtensions() {
    const t = [];
    return this.options.subscript !== !1 && t.push(B6.configure(this.options.subscript)), this.options.superscript !== !1 && t.push($6.configure(this.options.superscript)), t;
  }
}), SK = { class: "ml-1" }, AK = /* @__PURE__ */ T({
  __name: "ActionMoreButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    maxHeight: { default: void 0 },
    icon: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, n = P(() => {
      const o = e.items.find((i) => i.isActive());
      return o && !o.default ? {
        ...o,
        icon: o.icon ? o.icon : e.icon
      } : {
        title: e.tooltip,
        icon: e.icon,
        isActive: () => !1
      };
    });
    return (o, r) => (k(), _(Ii, {
      icon: o.icon,
      tooltip: o.tooltip,
      disabled: o.disabled
    }, {
      default: w(() => [
        (k(!0), U(ve, null, Fe(e.items, (i, s) => (k(), _(p(Vs), {
          checked: n.value.title === i.title,
          onClick: i.action,
          key: s,
          disabled: i.disabled,
          class: "flex gap-3 items-center"
        }, {
          default: w(() => [
            i.icon ? (k(), _(p(xe), {
              key: 0,
              name: i.icon
            }, null, 8, ["name"])) : ae("", !0),
            B("span", SK, q(i.title), 1),
            i.shortcutKeys ? (k(), _(p(a6), {
              key: 1,
              class: "ml-auto"
            }, {
              default: w(() => [
                he(q(p(To)(i.shortcutKeys)), 1)
              ]),
              _: 2
            }, 1024)) : ae("", !0)
          ]),
          _: 2
        }, 1032, ["checked", "onClick", "disabled"]))), 128))
      ]),
      _: 1
    }, 8, ["icon", "tooltip", "disabled"]));
  }
}), IJ = Te.create({
  name: "moreMark",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, extension: n, t: o }) {
        const r = n.options.subscript, i = n.options.superscript, s = {
          action: () => e.commands.toggleSubscript(),
          isActive: () => e.isActive("subscript") || !1,
          disabled: !e.can().toggleSubscript(),
          icon: "Subscript",
          title: o("editor.subscript.tooltip"),
          shortcutKeys: ["mod", "."]
        }, a = {
          action: () => e.commands.toggleSuperscript(),
          isActive: () => e.isActive("superscript") || !1,
          disabled: !e.can().toggleSuperscript(),
          icon: "Superscript",
          title: o("editor.superscript.tooltip"),
          shortcutKeys: ["mod", ","]
        }, l = xu(e, "code"), c = [];
        if (r !== !1 && c.push(s), i !== !1 && c.push(a), l) {
          const d = {
            action: () => e.commands.toggleCode(),
            isActive: () => e.isActive("code") || !1,
            disabled: !e.can().toggleCode(),
            icon: "Code",
            title: o("editor.code.tooltip"),
            shortcutKeys: ["mod", "E"]
          };
          l && c.push(d);
        }
        return {
          component: AK,
          componentProps: {
            icon: "Type",
            tooltip: o("editor.moremark"),
            disabled: !e.isEditable || c.every((d) => d.disabled),
            items: c
          }
        };
      }
    };
  },
  addExtensions() {
    const t = [];
    return this.options.subscript !== !1 && t.push(B6.configure(this.options.subscript)), this.options.superscript !== !1 && t.push($6.configure(this.options.superscript)), t;
  }
}), DJ = Te.create({
  name: "indent",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["paragraph", "heading", "blockquote"],
      minIndent: Mo.min,
      maxIndent: Mo.max,
      button({ editor: e, t: n }) {
        var i, s;
        const { selection: o } = e.state, r = o.$anchor.parent;
        return [
          {
            component: ye,
            componentProps: {
              action: () => {
                e.commands.indent();
              },
              disabled: ((i = r == null ? void 0 : r.attrs) == null ? void 0 : i.indent) >= Mo.max || !e.can().indent(),
              shortcutKeys: ["Tab"],
              icon: "IndentIncrease",
              tooltip: n("editor.indent.tooltip")
            }
          },
          {
            component: ye,
            componentProps: {
              action: () => {
                e.commands.outdent();
              },
              shortcutKeys: ["Shift", "Tab"],
              disabled: ((s = r == null ? void 0 : r.attrs) == null ? void 0 : s.indent) <= Mo.min || !e.can().outdent(),
              icon: "IndentDecrease",
              tooltip: n("editor.outdent.tooltip")
            }
          }
        ];
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          indent: {
            default: 0,
            parseHTML: (t) => {
              const e = t.getAttribute("data-indent");
              return (e ? parseInt(e, 10) : 0) || 0;
            },
            renderHTML: (t) => t.indent ? { "data-indent": t.indent } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      indent: () => Ly({
        delta: Mo.more,
        types: this.options.types
      }),
      outdent: () => Ly({
        delta: Mo.less,
        types: this.options.types
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.indent(),
      "Shift-Tab": () => this.editor.commands.outdent()
    };
  }
}), EK = ["paragraph", "heading", "list_item", "todo_item"];
function _K(t, e) {
  const { selection: n, doc: o } = t;
  if (!n || !o || !(n instanceof le || n instanceof Jt))
    return t;
  const { from: r, to: i } = n, s = [], a = e && e !== B2 ? e : null;
  return o.nodesBetween(r, i, (l, c) => {
    const d = l.type;
    return EK.includes(d.name) ? ((l.attrs.lineHeight || null) !== a && s.push({
      node: l,
      pos: c,
      nodeType: d
    }), d.name !== "list_item" && d.name !== "todo_item") : !0;
  }), s.length && s.forEach((l) => {
    const { node: c, pos: d, nodeType: u } = l;
    let { attrs: f } = c;
    f = {
      ...f,
      lineHeight: a
    }, t = t.setNodeMarkup(d, u, f, c.marks);
  }), t;
}
function MK(t) {
  return ({ state: e, dispatch: n }) => {
    const { selection: o } = e;
    let { tr: r } = e;
    return r = r.setSelection(o), r = _K(r, t), r.docChanged ? (n && n(r), !0) : !1;
  };
}
const TK = /* @__PURE__ */ T({
  __name: "LineHeightDropdown",
  props: {
    editor: {},
    icon: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const { t: e } = et();
    function n(a) {
      return parseFloat(a.replace("%", "")) / 100;
    }
    const o = P(() => {
      const c = i.editor.extensionManager.extensions.find((d) => d.name === "lineHeight").options.lineHeights.map((d) => ({
        label: n(d),
        value: d
      }));
      return c.unshift({
        label: p(e)("editor.default"),
        value: "default"
      }), c;
    }), r = O("default"), i = t;
    function s(a) {
      a === "default" ? i.editor.commands.unsetLineHeight() : i.editor.commands.setLineHeight(a), r.value = a;
    }
    return (a, l) => (k(), _(Ii, {
      icon: a.icon,
      tooltip: a.tooltip,
      disabled: a.disabled
    }, {
      default: w(() => [
        (k(!0), U(ve, null, Fe(o.value, (c, d) => (k(), _(p(Vs), {
          key: d,
          checked: c.value === r.value,
          onClick: (u) => s(c.value)
        }, {
          default: w(() => [
            he(q(c.label), 1)
          ]),
          _: 2
        }, 1032, ["checked", "onClick"]))), 128))
      ]),
      _: 1
    }, 8, ["icon", "tooltip", "disabled"]));
  }
}), RJ = Te.create({
  name: "lineHeight",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["paragraph", "heading", "list_item", "todo_item"],
      lineHeights: ["100%", "115%", "150%", "200%", "250%", "300%"],
      defaultHeight: B2,
      button({ editor: e, t: n }) {
        return {
          component: TK,
          componentProps: {
            editor: e,
            icon: "LineHeight",
            tooltip: n("editor.lineheight.tooltip")
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          lineHeight: {
            default: null,
            parseHTML: (t) => t.style.lineHeight || this.options.defaultHeight,
            renderHTML: (t) => t.lineHeight === this.options.defaultHeight || !t.lineHeight ? {} : { style: `line-height: ${t.lineHeight}` }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setLineHeight: (t) => MK(t),
      unsetLineHeight: () => ({ commands: t }) => this.options.types.every((e) => t.resetAttributes(e, "lineHeight"))
    };
  }
});
function OK(t) {
  var e;
  const { char: n, allowSpaces: o, allowToIncludeChar: r, allowedPrefixes: i, startOfLine: s, $position: a } = t, l = o && !r, c = nA(n), d = new RegExp(`\\s${c}$`), u = s ? "^" : "", f = r ? "" : c, h = l ? new RegExp(`${u}${c}.*?(?=\\s${f}|$)`, "gm") : new RegExp(`${u}(?:^)?${c}[^\\s${f}]*`, "gm"), m = ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && a.nodeBefore.text;
  if (!m)
    return null;
  const g = a.pos - m.length, v = Array.from(m.matchAll(h)).pop();
  if (!v || v.input === void 0 || v.index === void 0)
    return null;
  const y = v.input.slice(Math.max(0, v.index - 1), v.index), x = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(y);
  if (i !== null && !x)
    return null;
  const C = g + v.index;
  let b = C + v[0].length;
  return l && d.test(m.slice(b - 1, b + 1)) && (v[0] += " ", b += 1), C < a.pos && b >= a.pos ? {
    range: {
      from: C,
      to: b
    },
    query: v[0].slice(n.length),
    text: v[0]
  } : null;
}
const IK = new Be("suggestion");
function DK({ pluginKey: t = IK, editor: e, char: n = "@", allowSpaces: o = !1, allowToIncludeChar: r = !1, allowedPrefixes: i = [" "], startOfLine: s = !1, decorationTag: a = "span", decorationClass: l = "suggestion", command: c = () => null, items: d = () => [], render: u = () => ({}), allow: f = () => !0, findSuggestionMatch: h = OK }) {
  let m;
  const g = u == null ? void 0 : u(), v = new Ne({
    key: t,
    view() {
      return {
        update: async (y, x) => {
          var C, b, S, A, I, z, N;
          const M = (C = this.key) === null || C === void 0 ? void 0 : C.getState(x), $ = (b = this.key) === null || b === void 0 ? void 0 : b.getState(y.state), L = M.active && $.active && M.range.from !== $.range.from, Y = !M.active && $.active, J = M.active && !$.active, ne = !Y && !J && M.query !== $.query, F = Y || L && ne, R = ne || L, H = J || L && ne;
          if (!F && !R && !H)
            return;
          const K = H && !F ? M : $, Q = y.dom.querySelector(`[data-decoration-id="${K.decorationId}"]`);
          m = {
            editor: e,
            range: K.range,
            query: K.query,
            text: K.text,
            items: [],
            command: (Z) => c({
              editor: e,
              range: K.range,
              props: Z
            }),
            decorationNode: Q,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: Q ? () => {
              var Z;
              const { decorationId: ue } = (Z = this.key) === null || Z === void 0 ? void 0 : Z.getState(e.state), Se = y.dom.querySelector(`[data-decoration-id="${ue}"]`);
              return (Se == null ? void 0 : Se.getBoundingClientRect()) || null;
            } : null
          }, F && ((S = g == null ? void 0 : g.onBeforeStart) === null || S === void 0 || S.call(g, m)), R && ((A = g == null ? void 0 : g.onBeforeUpdate) === null || A === void 0 || A.call(g, m)), (R || F) && (m.items = await d({
            editor: e,
            query: K.query
          })), H && ((I = g == null ? void 0 : g.onExit) === null || I === void 0 || I.call(g, m)), R && ((z = g == null ? void 0 : g.onUpdate) === null || z === void 0 || z.call(g, m)), F && ((N = g == null ? void 0 : g.onStart) === null || N === void 0 || N.call(g, m));
        },
        destroy: () => {
          var y;
          m && ((y = g == null ? void 0 : g.onExit) === null || y === void 0 || y.call(g, m));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(y, x, C, b) {
        const { isEditable: S } = e, { composing: A } = e.view, { selection: I } = y, { empty: z, from: N } = I, M = { ...x };
        if (M.composing = A, S && (z || e.view.composing)) {
          (N < x.range.from || N > x.range.to) && !A && !x.composing && (M.active = !1);
          const $ = h({
            char: n,
            allowSpaces: o,
            allowToIncludeChar: r,
            allowedPrefixes: i,
            startOfLine: s,
            $position: I.$from
          }), L = `id_${Math.floor(Math.random() * 4294967295)}`;
          $ && f({
            editor: e,
            state: b,
            range: $.range,
            isActive: x.active
          }) ? (M.active = !0, M.decorationId = x.decorationId ? x.decorationId : L, M.range = $.range, M.query = $.query, M.text = $.text) : M.active = !1;
        } else
          M.active = !1;
        return M.active || (M.decorationId = null, M.range = { from: 0, to: 0 }, M.query = null, M.text = null), M;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(y, x) {
        var C;
        const { active: b, range: S } = v.getState(y.state);
        return b && ((C = g == null ? void 0 : g.onKeyDown) === null || C === void 0 ? void 0 : C.call(g, { view: y, event: x, range: S })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(y) {
        const { active: x, range: C, decorationId: b } = v.getState(y);
        return x ? ze.create(y.doc, [
          ht.inline(C.from, C.to, {
            nodeName: a,
            class: l,
            "data-decoration-id": b
          })
        ]) : null;
      }
    }
  });
  return v;
}
function RK(t) {
  const { t: e } = et(), n = [
    {
      name: "format",
      title: e.value("editor.slash.format"),
      commands: [
        {
          name: "paragraph",
          label: e.value("editor.paragraph.tooltip"),
          aliases: ["paragraph", "zw"],
          iconName: "Paragraph",
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setHeading({ level: 1 }).run();
          }
        },
        {
          name: "heading1",
          label: e.value("editor.heading.h1.tooltip"),
          aliases: ["h1", "bt", "bt1"],
          iconName: "Heading1",
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setHeading({ level: 1 }).run();
          }
        },
        {
          name: "heading2",
          label: e.value("editor.heading.h2.tooltip"),
          aliases: ["h2", "bt", "bt2"],
          iconName: "Heading2",
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setNode("heading", { level: 2 }).run();
          }
        },
        {
          name: "heading3",
          label: e.value("editor.heading.h3.tooltip"),
          aliases: ["h3", "bt", "bt3", "heading3"],
          iconName: "Heading3",
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setNode("heading", { level: 3 }).run();
          }
        },
        {
          name: "bulletList",
          label: e.value("editor.bulletlist.tooltip"),
          aliases: ["ul", "yxlb", "bulletList"],
          iconName: "List",
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).toggleBulletList().run();
          }
        },
        {
          name: "numberedList",
          label: e.value("editor.orderedlist.tooltip"),
          aliases: ["ol", "yxlb"],
          iconName: "ListOrdered",
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).toggleOrderedList().run();
          }
        },
        {
          name: "codeBlock",
          label: e.value("editor.codeblock.tooltip"),
          iconName: "Code2",
          aliases: ["codeBlock"],
          description: "Code block with syntax highlighting",
          shouldBeHidden: (r) => r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setCodeBlock().run();
          }
        },
        {
          name: "blockquote",
          label: e.value("editor.blockquote.tooltip"),
          description: "插入引入格式",
          aliases: ["yr"],
          iconName: "TextQuote",
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setBlockquote().run();
          }
        },
        {
          name: "horizontalrule",
          label: e.value("editor.horizontalrule.tooltip"),
          aliases: ["fgx", "horizontalRule"],
          iconName: "Minus",
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setHorizontalRule().run();
          }
        },
        {
          name: "link",
          label: e.value("editor.link.tooltip"),
          aliases: ["link", "lianjie", "lj"],
          iconName: "Link",
          action: ({ editor: r, range: i }) => {
            r.chain().deleteRange(i).extendMarkRange("link").insertContent({
              type: "text",
              text: "link",
              marks: [
                {
                  type: "link",
                  attrs: {
                    href: "",
                    target: "_blank"
                  }
                }
              ]
            }).setLink({ href: "" }).focus().run();
          }
        }
      ]
    },
    {
      name: "insert",
      title: e.value("editor.slash.insert"),
      commands: [
        {
          name: "image",
          label: e.value("editor.image.tooltip"),
          iconName: "ImageUp",
          description: "Insert a image",
          aliases: ["image", "tp", "tupian"],
          shouldBeHidden: (r) => r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setImageUpload().run();
          }
        },
        {
          name: "table",
          label: e.value("editor.table.tooltip"),
          iconName: "Table",
          description: "Insert a table",
          aliases: ["table", "bg", "biaoge", "biao"],
          shouldBeHidden: (r) => r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).insertTable({ rows: 3, cols: 3, withHeaderRow: !1 }).run();
          }
        },
        {
          name: "video",
          label: e.value("editor.video.tooltip"),
          iconName: "Video",
          description: "Insert a video",
          aliases: ["video", "sp", "shipin"],
          shouldBeHidden: (r) => r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).setVideoUpload().run();
          }
        },
        {
          name: "taskList",
          label: e.value("editor.tasklist.tooltip"),
          iconName: "ListTodo",
          description: "Task list with todo items",
          aliases: ["todo"],
          action: ({ editor: r, range: i }) => {
            r.chain().focus().deleteRange(i).toggleTaskList().run();
          }
        },
        {
          name: "columns",
          label: e.value("editor.columns.tooltip"),
          iconName: "Columns2",
          description: "Add two column content",
          aliases: ["columns", "cols", "2cols"],
          shouldBeHidden: (r) => r.isActive("columns"),
          action: ({ editor: r, range: i }) => {
            r.chain().deleteRange(i).setColumns().focus(r.state.selection.head - 1).run();
          }
        }
      ]
    }
  ];
  if (xu(t, "iframes")) {
    const r = JW;
    n.push({
      name: "others",
      title: e.value("editor.slash.embed"),
      commands: r.map((i) => ({
        name: i.value,
        label: i.label,
        iconName: i.icon,
        aliases: [i.value, i.label],
        shouldBeHidden: (s) => s.isActive("columns"),
        action: ({ editor: s, range: a }) => {
          s.chain().deleteRange(a).focus().setIframe({
            src: "",
            service: i.value
          }).run();
        }
      }))
    });
  }
  return n;
}
const PK = {
  key: 0,
  class: "grid grid-cols-1 gap-0.5 min-w-48"
}, LK = { className: "text-neutral-500 text-[0.65rem] col-[1/-1] mx-2 mt-2 font-semibold tracking-wider select-none uppercase first:mt-0.5" }, NK = ["onClick"], BK = ["src"], $K = {
  key: 1,
  class: "p-3"
}, zK = { class: "text-xs text-gray-800 dark:text-gray-100" }, FK = /* @__PURE__ */ T({
  __name: "CommandsList",
  props: {
    editor: {},
    items: { default: void 0 },
    command: { type: Function, default: void 0 }
  },
  setup(t, { expose: e }) {
    const n = O(0), o = O(0), r = O(null), { t: i } = et(), s = O([]), a = t;
    e({ onKeyDown: l }), ce([() => n.value, () => o.value], async () => {
      if (!r.value)
        return;
      await qe();
      const g = o.value * 1e3 + n.value, v = s.value[g];
      v && v.scrollIntoView({
        behavior: "smooth",
        block: "nearest"
      });
    });
    function l({ event: g }) {
      return g.key === "ArrowUp" ? (c(), !0) : g.key === "ArrowDown" ? (d(), !0) : g.key === "Enter" ? (u(), !0) : !1;
    }
    function c() {
      var y;
      if (!a.items.length)
        return !1;
      let g = n.value - 1, v = o.value;
      g < 0 && (v = o.value - 1, g = ((y = a.items[v]) == null ? void 0 : y.commands.length) - 1 || 0), v < 0 && (v = a.items.length - 1, g = a.items[v].commands.length - 1), n.value = g, o.value = v;
    }
    function d() {
      if (!a.items.length)
        return !1;
      const g = a.items[o.value].commands;
      let v = n.value + 1, y = o.value;
      g.length - 1 < v && (v = 0, y = o.value + 1), a.items.length - 1 < y && (y = 0), n.value = v, o.value = y;
    }
    function u() {
      if (!a.items.length || o.value === -1 || n.value === -1)
        return !1;
      f(o.value, n.value);
    }
    function f(g, v) {
      const y = a.items[g].commands[v];
      a.command(y);
    }
    function h(g, v) {
      f(g, v);
    }
    function m(g, v, y) {
      s.value[g * 1e3 + v] = y;
    }
    return (g, v) => {
      var y;
      return k(), U("div", {
        class: "bg-white rounded-lg dark:bg-black shadow-sm border border-neutral-200 dark:border-neutral-800 text-black max-h-[min(80vh,24rem)] overflow-auto flex-wrap mb-8 p-1",
        ref_key: "scrollContainer",
        ref: r
      }, [
        (y = g.items) != null && y.length ? (k(), U("div", PK, [
          (k(!0), U(ve, null, Fe(g.items, (x, C) => (k(), U(ve, {
            key: x.title
          }, [
            B("div", LK, q(x.title), 1),
            (k(!0), U(ve, null, Fe(x.commands, (b, S) => (k(), U("button", {
              class: Ze(["flex items-center gap-3 px-2 py-1.5 text-sm text-neutral-800 dark:text-neutral-200 text-left w-full rounded-sm outline-none transition-colors", [
                o.value === C && n.value === S ? "bg-accent text-neutral-800 dark:bg-neutral-900 dark:text-neutral-200" : "hover:bg-accent hover:text-neutral-800 dark:hover:bg-neutral-900 dark:hover:text-neutral-200"
              ]]),
              ref_for: !0,
              ref: (A) => m(C, S, A),
              key: S,
              onClick: (A) => h(C, S)
            }, [
              b.iconUrl ? (k(), U("img", {
                key: 0,
                class: "w-6 h-6",
                src: b.iconUrl
              }, null, 8, BK)) : ae("", !0),
              b.iconName ? (k(), _(p(xe), {
                key: 1,
                name: b.iconName,
                class: "mr-1 text-lg"
              }, null, 8, ["name"])) : ae("", !0),
              he(" " + q(b.label), 1)
            ], 10, NK))), 128))
          ], 64))), 128))
        ])) : (k(), U("div", $K, [
          B("span", zK, q(p(i)("editor.slash.empty")), 1)
        ]))
      ], 512);
    };
  }
}), Gr = "slashCommand";
let Je;
const PJ = Te.create({
  name: Gr,
  priority: 200,
  onCreate() {
    Je = Hr("body", {
      interactive: !0,
      trigger: "manual",
      placement: "bottom-start",
      theme: "slash-command",
      maxWidth: "16rem",
      offset: [16, 8],
      popperOptions: {
        strategy: "fixed",
        modifiers: [
          {
            name: "flip",
            enabled: !1
          }
        ]
      }
    });
  },
  addProseMirrorPlugins() {
    return [
      DK({
        editor: this.editor,
        char: "/",
        allowSpaces: !0,
        startOfLine: !0,
        pluginKey: new Be(Gr),
        allow: ({ state: t, range: e }) => {
          var c, d, u;
          const n = t.doc.resolve(e.from), o = n.depth === 1, r = n.parent.type.name === "paragraph", i = ((c = n.parent.textContent) == null ? void 0 : c.charAt(0)) === "/", s = this.editor.isActive("column"), a = (u = n.parent.textContent) == null ? void 0 : u.substring((d = n.parent.textContent) == null ? void 0 : d.indexOf("/")), l = !(a != null && a.endsWith("  "));
          return (o && r && i || s && r && i) && l;
        },
        command: ({ editor: t, range: e, props: n }) => {
          const { view: o } = t;
          n.action({ editor: t, range: e }), o.focus();
        },
        items: ({ query: t, editor: e }) => RK(this.editor).map((s) => ({
          ...s,
          commands: s.commands.filter((a) => {
            const l = a.label.toLowerCase().trim(), c = t.toLowerCase().trim();
            if (a.aliases) {
              const d = a.aliases.map((h) => h.toLowerCase().trim()), u = l.match(c), f = d.some((h) => h.match(c));
              return u || f;
            }
            return l.match(c);
          }).filter((a) => a.shouldBeHidden ? !a.shouldBeHidden(this.editor) : !0)
        })).filter((s) => s.commands.length > 0).map((s) => ({
          ...s,
          commands: s.commands.map((a) => ({
            ...a,
            isEnabled: !0
          }))
        })),
        render: () => {
          let t, e = null;
          return {
            onStart: (n) => {
              var s;
              t = new L2(FK, {
                props: n,
                editor: n.editor
              });
              const { view: o } = n.editor, r = o.dom, i = () => {
                if (!n.clientRect)
                  return n.editor.storage[Gr].rect;
                const a = n.clientRect();
                if (!a)
                  return n.editor.storage[Gr].rect;
                let l = a.y;
                if (a.top + t.element.offsetHeight + 40 > window.innerHeight) {
                  const c = a.top + t.element.offsetHeight - window.innerHeight + 40;
                  l = a.y - c;
                }
                return r.getBoundingClientRect().x, new DOMRect(a.x, l, a.width, a.height);
              };
              e = () => {
                Je == null || Je[0].setProps({
                  getReferenceClientRect: i
                });
              }, (s = o.dom.parentElement) == null || s.addEventListener("scroll", e), Je == null || Je[0].setProps({
                getReferenceClientRect: i,
                appendTo: () => document.body,
                content: t.element
              }), Je == null || Je[0].show();
            },
            onUpdate(n) {
              var s;
              t.updateProps(n);
              const { view: o } = n.editor;
              o.dom;
              const r = () => {
                if (!n.clientRect)
                  return n.editor.storage[Gr].rect;
                const a = n.clientRect();
                return a ? new DOMRect(a.x, a.y, a.width, a.height) : n.editor.storage[Gr].rect;
              };
              let i = () => {
                Je == null || Je[0].setProps({
                  getReferenceClientRect: r
                });
              };
              (s = o.dom.parentElement) == null || s.addEventListener("scroll", i), n.editor.storage[Gr].rect = n.clientRect ? r() : {
                width: 0,
                height: 0,
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
              }, Je == null || Je[0].setProps({
                getReferenceClientRect: r
              });
            },
            onKeyDown(n) {
              var o;
              return n.event.key === "Escape" ? (Je == null || Je[0].hide(), !0) : (Je != null && Je[0].state.isShown || Je == null || Je[0].show(), (o = t.ref) == null ? void 0 : o.onKeyDown(n));
            },
            onExit(n) {
              var o;
              if (Je == null || Je[0].hide(), e) {
                const { view: r } = n.editor;
                (o = r.dom.parentElement) == null || o.removeEventListener("scroll", e);
              }
              t.destroy();
            }
          };
        }
      })
    ];
  },
  addStorage() {
    return {
      rect: {
        width: 0,
        height: 0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }
    };
  }
}), HK = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, VK = ot.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["img", He(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setImage: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      d2({
        find: HK,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, n, o] = t;
          return { src: n, alt: e, title: o };
        }
      })
    ];
  }
}), jK = ["src", "alt"], UK = {
  key: 0,
  class: "image-resizer"
}, WK = ["onMousedown"], KK = /* @__PURE__ */ T({
  __name: "ImageView",
  props: {
    ...Cl,
    selected: {
      type: Boolean,
      required: !0
    }
  },
  setup(t) {
    const e = t, n = {
      TOP_LEFT: "tl",
      TOP_RIGHT: "tr",
      BOTTOM_LEFT: "bl",
      BOTTOM_RIGHT: "br"
    }, o = O({ width: H1, height: H1 }), r = O({ width: 0, height: 0 }), i = O(!1), s = O({
      x: 0,
      y: 0,
      w: 0,
      h: 0,
      dir: ""
    }), a = P(() => {
      const { src: b, alt: S, width: A, height: I, flipX: z, flipY: N } = e.node.attrs, M = [];
      z && M.push("rotateX(180deg)"), N && M.push("rotateY(180deg)");
      const $ = M.join(" ");
      return {
        src: b || void 0,
        alt: S || void 0,
        style: {
          width: ah(A) ? `${A}px` : A,
          height: ah(I) ? `${I}px` : I,
          transform: $ || "none"
        }
      };
    }), l = P(() => ({
      width: p(a).style.width === "100%" ? "100%" : void 0
    })), c = O(null), d = new ResizeObserver((b) => {
      for (const S of b) {
        const { width: A, height: I } = S.contentRect;
        r.value = { width: A, height: I }, e.updateAttributes({ originWidth: A, originHeight: I });
      }
    });
    function u() {
      const { editor: b, getPos: S } = e;
      b.commands.setNodeSelection(S());
    }
    const f = sd(() => {
      const { editor: b } = e;
      o.value.width = parseInt(getComputedStyle(b.view.dom).width, 10);
    }, V1);
    function h(b, S) {
      b.preventDefault(), b.stopPropagation();
      const { width: A, height: I } = p(r), z = A / I;
      let N = Number(e.node.attrs.width) || A, M = Number(e.node.attrs.height) || Math.round(N / z);
      const $ = p(o).width;
      N = Math.min(N > $ ? $ : N, $), M = Math.round(N / z), Object.assign(s.value, { x: b.clientX, y: b.clientY, w: N, h: M, dir: S }), i.value = !0, v();
    }
    const m = sd((b) => {
      if (!p(i))
        return;
      const { x: S, y: A, w: I, dir: z } = p(s), N = (b.clientX - S) * (/l/.test(z) ? -1 : 1), M = O9(I + N, H7, p(o).width);
      e.updateAttributes({ width: M });
    }, V1);
    function g(b) {
      b.preventDefault(), b.stopPropagation(), p(i) && (i.value = !1, Object.assign(s.value, { x: 0, y: 0, w: 0, h: 0, dir: "" }), y(), u());
    }
    function v() {
      document.addEventListener("mousemove", m, !0), document.addEventListener("mouseup", g, !0);
    }
    function y() {
      document.removeEventListener("mousemove", m, !0), document.removeEventListener("mouseup", g, !0);
    }
    const x = new ResizeObserver(f), C = P(() => {
      const { textAlign: b } = e.node.attrs;
      return {
        left: "margin-right: auto;",
        right: "margin-left: auto;",
        center: "margin-left: auto; margin-right: auto;"
      }[b] || "";
    });
    return _e(() => {
      c.value && d.observe(c.value), x.observe(e.editor.view.dom);
    }), jo(() => {
      y(), d.disconnect(), x.disconnect();
    }), (b, S) => (k(), _(p(kl), { class: "node-image" }, {
      default: w(() => [
        B("div", {
          class: "image-view",
          style: ct([a.value.style, C.value])
        }, [
          B("div", {
            draggable: "true",
            "data-drag-handle": "",
            class: Ze([{
              "image-view__body--focused": t.selected,
              "image-view__body--resizing": i.value
            }, "image-view__body"]),
            style: ct(l.value)
          }, [
            B("img", {
              src: a.value.src,
              alt: a.value.alt,
              ref_key: "imageRef",
              ref: c,
              class: "image-view__body__image block",
              onClick: u
            }, null, 8, jK),
            b.editor.view.editable ? Sn((k(), U("div", UK, [
              (k(!0), U(ve, null, Fe(Object.values(n), (A) => (k(), U("span", {
                key: A,
                class: Ze([`image-resizer__handler--${A}`, "image-resizer__handler"]),
                onMousedown: (I) => h(I, A)
              }, null, 42, WK))), 128))
            ], 512)), [
              [Jn, t.selected || i.value]
            ]) : ae("", !0)
          ], 6)
        ], 4)
      ]),
      _: 1
    }));
  }
}), qK = /* @__PURE__ */ Yg(KK, [["__scopeId", "data-v-6b19b371"]]), LJ = VK.extend({
  group: "block",
  defining: !0,
  isolating: !0,
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      flipX: {
        default: !1
      },
      flipY: {
        default: !1
      },
      originWidth: {
        default: null
      },
      originHeight: {
        default: null
      },
      width: {
        default: "100%",
        parseHTML: (e) => {
          const n = e.style.width || e.getAttribute("width") || null;
          return n && n.endsWith("%") ? n : n == null ? null : parseInt(n, 10);
        },
        renderHTML: (e) => ({
          width: e.width
        })
      }
    };
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this)
    };
  },
  addNodeView() {
    return Sl(qK);
  },
  addCommands() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      updateImage: (e) => ({ commands: n, editor: o }) => n.updateAttributes(this.name, e)
    };
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { textAlign: n, flipX: o, flipY: r } = t.attrs, a = `${{
      left: "margin-right: auto;",
      right: "margin-left: auto;",
      center: "margin-left: auto; margin-right: auto;"
    }[n] || ""} ${o || r ? `transform: rotateX(${o ? "180" : "0"}deg) rotateY(${r ? "180" : "0"}deg);` : ""}`;
    return [
      "img",
      He(
        {
          height: "auto",
          style: a
        },
        this.options.HTMLAttributes,
        e
      )
    ];
  },
  parseHTML() {
    return [
      {
        tag: "img[src]"
      }
    ];
  }
});
function GK(t) {
  return t = t.replace("https://youtu.be/", "https://www.youtube.com/watch?v=").replace("watch?v=", "embed/"), t = t.replace("https://vimeo.com/", "https://player.vimeo.com/video/"), /^https?:\/\/www.bilibili.com\/video\/.*/i.test(t) && (t = t.replace(/\?.*$/i, "").replace("https://www.bilibili.com/video/", "https://player.bilibili.com/player.html?bvid=")), t.includes("drive.google.com") && (t = t.replace("/view", "/preview")), t;
}
const NJ = ot.create({
  name: "video",
  group: "block",
  atom: !0,
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null,
        renderHTML: ({ src: t }) => ({
          src: t ? GK(t) : null
        })
      },
      width: {
        default: this.options.width,
        renderHTML: ({ width: t }) => ({
          width: Tc(t)
        })
      },
      frameborder: {
        default: this.options.frameborder ? 1 : 0,
        parseHTML: () => this.options.frameborder ? 1 : 0
      },
      allowfullscreen: {
        default: this.options.allowFullscreen,
        parseHTML: () => this.options.allowFullscreen
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[data-video] iframe"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { width: e = "100%" } = t ?? {}, n = {
      ...t,
      width: "100%",
      height: "100%"
    }, o = `position: relative;overflow: hidden;display: flex;flex: 1;max-width: ${e};`, r = `flex: 1;padding-bottom: ${9 / 16 * 100}%;`, a = ["div", { style: o }, ["div", { style: r }], ["iframe", n]];
    return ["div", {
      ...this.options.HTMLAttributes,
      "data-video": ""
    }, a];
  },
  addCommands() {
    return {
      setVideo: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      }),
      updateVideo: (t) => ({ commands: e }) => e.updateAttributes(this.name, t)
    };
  },
  addOptions() {
    return {
      divider: !1,
      spacer: !1,
      allowFullscreen: !0,
      upload: void 0,
      frameborder: !1,
      width: od["size-medium"],
      HTMLAttributes: {
        class: "iframe-wrapper",
        style: "display: flex;justify-content: center;"
      }
    };
  }
});
var Jh, Yh;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  Jh = (e) => t.get(e), Yh = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  Jh = (o) => {
    for (let r = 0; r < t.length; r += 2)
      if (t[r] == o)
        return t[r + 1];
  }, Yh = (o, r) => (n == 10 && (n = 0), t[n++] = o, t[n++] = r);
}
var pt = class {
  constructor(t, e, n, o) {
    this.width = t, this.height = e, this.map = n, this.problems = o;
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t)
        continue;
      const o = e % this.width, r = e / this.width | 0;
      let i = o + 1, s = r + 1;
      for (let a = 1; i < this.width && this.map[e + a] == n; a++)
        i++;
      for (let a = 1; s < this.height && this.map[e + this.width * a] == n; a++)
        s++;
      return { left: o, top: r, right: i, bottom: s };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t)
        return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: o, right: r, top: i, bottom: s } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? o == 0 : r == this.width) ? null : this.map[i * this.width + (n < 0 ? o - 1 : r)] : (n < 0 ? i == 0 : s == this.height) ? null : this.map[o + this.width * (n < 0 ? i - 1 : s)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const {
      left: n,
      right: o,
      top: r,
      bottom: i
    } = this.findCell(t), {
      left: s,
      right: a,
      top: l,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(n, s),
      top: Math.min(r, l),
      right: Math.max(o, a),
      bottom: Math.max(i, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [], n = {};
    for (let o = t.top; o < t.bottom; o++)
      for (let r = t.left; r < t.right; r++) {
        const i = o * this.width + r, s = this.map[i];
        n[s] || (n[s] = !0, !(r == t.left && r && this.map[i - 1] == s || o == t.top && o && this.map[i - this.width] == s) && e.push(s));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let o = 0, r = 0; ; o++) {
      const i = r + n.child(o).nodeSize;
      if (o == t) {
        let s = e + t * this.width;
        const a = (t + 1) * this.width;
        for (; s < a && this.map[s] < r; )
          s++;
        return s == a ? i - 1 : this.map[s];
      }
      r = i;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return Jh(t) || Yh(t, JK(t));
  }
};
function JK(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = YK(t), n = t.childCount, o = [];
  let r = 0, i = null;
  const s = [];
  for (let c = 0, d = e * n; c < d; c++)
    o[c] = 0;
  for (let c = 0, d = 0; c < n; c++) {
    const u = t.child(c);
    d++;
    for (let m = 0; ; m++) {
      for (; r < o.length && o[r] != 0; )
        r++;
      if (m == u.childCount)
        break;
      const g = u.child(m), { colspan: v, rowspan: y, colwidth: x } = g.attrs;
      for (let C = 0; C < y; C++) {
        if (C + c >= n) {
          (i || (i = [])).push({
            type: "overlong_rowspan",
            pos: d,
            n: y - C
          });
          break;
        }
        const b = r + C * e;
        for (let S = 0; S < v; S++) {
          o[b + S] == 0 ? o[b + S] = d : (i || (i = [])).push({
            type: "collision",
            row: c,
            pos: d,
            n: v - S
          });
          const A = x && x[S];
          if (A) {
            const I = (b + S) % e * 2, z = s[I];
            z == null || z != A && s[I + 1] == 1 ? (s[I] = A, s[I + 1] = 1) : z == A && s[I + 1]++;
          }
        }
      }
      r += v, d += g.nodeSize;
    }
    const f = (c + 1) * e;
    let h = 0;
    for (; r < f; )
      o[r++] == 0 && h++;
    h && (i || (i = [])).push({ type: "missing", row: c, n: h }), d++;
  }
  (e === 0 || n === 0) && (i || (i = [])).push({ type: "zero_sized" });
  const a = new pt(e, n, o, i);
  let l = !1;
  for (let c = 0; !l && c < s.length; c += 2)
    s[c] != null && s[c + 1] < n && (l = !0);
  return l && XK(a, s, t), a;
}
function YK(t) {
  let e = -1, n = !1;
  for (let o = 0; o < t.childCount; o++) {
    const r = t.child(o);
    let i = 0;
    if (n)
      for (let s = 0; s < o; s++) {
        const a = t.child(s);
        for (let l = 0; l < a.childCount; l++) {
          const c = a.child(l);
          s + c.attrs.rowspan > o && (i += c.attrs.colspan);
        }
      }
    for (let s = 0; s < r.childCount; s++) {
      const a = r.child(s);
      i += a.attrs.colspan, a.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = i : e != i && (e = Math.max(e, i));
  }
  return e;
}
function XK(t, e, n) {
  t.problems || (t.problems = []);
  const o = {};
  for (let r = 0; r < t.map.length; r++) {
    const i = t.map[r];
    if (o[i])
      continue;
    o[i] = !0;
    const s = n.nodeAt(i);
    if (!s)
      throw new RangeError(`No cell with offset ${i} found`);
    let a = null;
    const l = s.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const d = (r + c) % t.width, u = e[d * 2];
      u != null && (!l.colwidth || l.colwidth[c] != u) && ((a || (a = ZK(l)))[c] = u);
    }
    a && t.problems.unshift({
      type: "colwidth mismatch",
      pos: i,
      colwidth: a
    });
  }
}
function ZK(t) {
  if (t.colwidth)
    return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++)
    e.push(0);
  return e;
}
function $t(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const o = t.nodes[n], r = o.spec.tableRole;
      r && (e[r] = o);
    }
  }
  return e;
}
var hr = new Be("selectingCells");
function Us(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function QK(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell")
      return t.node(e);
  }
  return null;
}
function Vn(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row")
      return !0;
  return !1;
}
function tf(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = Us(e.$head) || eq(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function eq(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const o = e.type.spec.tableRole;
    if (o == "cell" || o == "header_cell")
      return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const o = e.type.spec.tableRole;
    if (o == "cell" || o == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function Xh(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function tq(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function u0(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function z6(t, e, n) {
  const o = t.node(-1), r = pt.get(o), i = t.start(-1), s = r.nextCell(t.pos - i, e, n);
  return s == null ? null : t.node(0).resolve(i + s);
}
function xi(t, e, n = 1) {
  const o = { ...t, colspan: t.colspan - n };
  return o.colwidth && (o.colwidth = o.colwidth.slice(), o.colwidth.splice(e, n), o.colwidth.some((r) => r > 0) || (o.colwidth = null)), o;
}
function F6(t, e, n = 1) {
  const o = { ...t, colspan: t.colspan + n };
  if (o.colwidth) {
    o.colwidth = o.colwidth.slice();
    for (let r = 0; r < n; r++)
      o.colwidth.splice(e, 0, 0);
  }
  return o;
}
function nq(t, e, n) {
  const o = $t(e.type.schema).header_cell;
  for (let r = 0; r < t.height; r++)
    if (e.nodeAt(t.map[n + r * t.width]).type != o)
      return !1;
  return !0;
}
var Qe = class Co extends pe {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const o = e.node(-1), r = pt.get(o), i = e.start(-1), s = r.rectBetween(
      e.pos - i,
      n.pos - i
    ), a = e.node(0), l = r.cellsInRect(s).filter((d) => d != n.pos - i);
    l.unshift(n.pos - i);
    const c = l.map((d) => {
      const u = o.nodeAt(d);
      if (!u)
        throw RangeError(`No cell with offset ${d} found`);
      const f = i + d + 1;
      return new dm(
        a.resolve(f),
        a.resolve(f + u.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const o = e.resolve(n.map(this.$anchorCell.pos)), r = e.resolve(n.map(this.$headCell.pos));
    if (Xh(o) && Xh(r) && u0(o, r)) {
      const i = this.$anchorCell.node(-1) != o.node(-1);
      return i && this.isRowSelection() ? Co.rowSelection(o, r) : i && this.isColSelection() ? Co.colSelection(o, r) : new Co(o, r);
    }
    return le.between(o, r);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = pt.get(e), o = this.$anchorCell.start(-1), r = n.rectBetween(
      this.$anchorCell.pos - o,
      this.$headCell.pos - o
    ), i = {}, s = [];
    for (let l = r.top; l < r.bottom; l++) {
      const c = [];
      for (let d = l * n.width + r.left, u = r.left; u < r.right; u++, d++) {
        const f = n.map[d];
        if (i[f])
          continue;
        i[f] = !0;
        const h = n.findCell(f);
        let m = e.nodeAt(f);
        if (!m)
          throw RangeError(`No cell with offset ${f} found`);
        const g = r.left - h.left, v = h.right - r.right;
        if (g > 0 || v > 0) {
          let y = m.attrs;
          if (g > 0 && (y = xi(y, 0, g)), v > 0 && (y = xi(
            y,
            y.colspan - v,
            v
          )), h.left < r.left) {
            if (m = m.type.createAndFill(y), !m)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(y)}`
              );
          } else
            m = m.type.create(y, m.content);
        }
        if (h.top < r.top || h.bottom > r.bottom) {
          const y = {
            ...m.attrs,
            rowspan: Math.min(h.bottom, r.bottom) - Math.max(h.top, r.top)
          };
          h.top < r.top ? m = m.type.createAndFill(y) : m = m.type.create(y, m.content);
        }
        c.push(m);
      }
      s.push(e.child(l).copy(W.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : s;
    return new ee(W.from(a), 1, 1);
  }
  replace(e, n = ee.empty) {
    const o = e.steps.length, r = this.ranges;
    for (let s = 0; s < r.length; s++) {
      const { $from: a, $to: l } = r[s], c = e.mapping.slice(o);
      e.replace(
        c.map(a.pos),
        c.map(l.pos),
        s ? ee.empty : n
      );
    }
    const i = pe.findFrom(
      e.doc.resolve(e.mapping.slice(o).map(this.to)),
      -1
    );
    i && e.setSelection(i);
  }
  replaceWith(e, n) {
    this.replace(e, new ee(W.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), o = pt.get(n), r = this.$anchorCell.start(-1), i = o.cellsInRect(
      o.rectBetween(
        this.$anchorCell.pos - r,
        this.$headCell.pos - r
      )
    );
    for (let s = 0; s < i.length; s++)
      e(n.nodeAt(i[s]), r + i[s]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0)
      return !1;
    const o = e + this.$anchorCell.nodeAfter.attrs.rowspan, r = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(o, r) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const o = e.node(-1), r = pt.get(o), i = e.start(-1), s = r.findCell(e.pos - i), a = r.findCell(n.pos - i), l = e.node(0);
    return s.top <= a.top ? (s.top > 0 && (e = l.resolve(i + r.map[s.left])), a.bottom < r.height && (n = l.resolve(
      i + r.map[r.width * (r.height - 1) + a.right - 1]
    ))) : (a.top > 0 && (n = l.resolve(i + r.map[a.left])), s.bottom < r.height && (e = l.resolve(
      i + r.map[r.width * (r.height - 1) + s.right - 1]
    ))), new Co(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = pt.get(e), o = this.$anchorCell.start(-1), r = n.colCount(this.$anchorCell.pos - o), i = n.colCount(this.$headCell.pos - o);
    if (Math.min(r, i) > 0)
      return !1;
    const s = r + this.$anchorCell.nodeAfter.attrs.colspan, a = i + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(s, a) == n.width;
  }
  eq(e) {
    return e instanceof Co && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const o = e.node(-1), r = pt.get(o), i = e.start(-1), s = r.findCell(e.pos - i), a = r.findCell(n.pos - i), l = e.node(0);
    return s.left <= a.left ? (s.left > 0 && (e = l.resolve(
      i + r.map[s.top * r.width]
    )), a.right < r.width && (n = l.resolve(
      i + r.map[r.width * (a.top + 1) - 1]
    ))) : (a.left > 0 && (n = l.resolve(i + r.map[a.top * r.width])), s.right < r.width && (e = l.resolve(
      i + r.map[r.width * (s.top + 1) - 1]
    ))), new Co(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new Co(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, o = n) {
    return new Co(e.resolve(n), e.resolve(o));
  }
  getBookmark() {
    return new oq(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Qe.prototype.visible = !1;
pe.jsonID("cell", Qe);
var oq = class H6 {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new H6(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), o = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && o.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && o.index() < o.parent.childCount && u0(n, o) ? new Qe(n, o) : pe.near(o, 1);
  }
};
function rq(t) {
  if (!(t.selection instanceof Qe))
    return null;
  const e = [];
  return t.selection.forEachCell((n, o) => {
    e.push(
      ht.node(o, o + n.nodeSize, { class: "selectedCell" })
    );
  }), ze.create(t.doc, e);
}
function iq({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6)
    return !1;
  let n = t.pos, o = e.pos, r = t.depth;
  for (; r >= 0 && !(t.after(r + 1) < t.end(r)); r--, n++)
    ;
  for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, o--)
    ;
  return n == o && /row|table/.test(t.node(r).type.spec.tableRole);
}
function sq({ $from: t, $to: e }) {
  let n, o;
  for (let r = t.depth; r > 0; r--) {
    const i = t.node(r);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      n = i;
      break;
    }
  }
  for (let r = e.depth; r > 0; r--) {
    const i = e.node(r);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      o = i;
      break;
    }
  }
  return n !== o && e.parentOffset === 0;
}
function aq(t, e, n) {
  const o = (e || t).selection, r = (e || t).doc;
  let i, s;
  if (o instanceof de && (s = o.node.type.spec.tableRole)) {
    if (s == "cell" || s == "header_cell")
      i = Qe.create(r, o.from);
    else if (s == "row") {
      const a = r.resolve(o.from + 1);
      i = Qe.rowSelection(a, a);
    } else if (!n) {
      const a = pt.get(o.node), l = o.from + 1, c = l + a.map[a.width * a.height - 1];
      i = Qe.create(r, l + 1, c);
    }
  } else
    o instanceof le && iq(o) ? i = le.create(r, o.from) : o instanceof le && sq(o) && (i = le.create(r, o.$from.start(), o.$from.end()));
  return i && (e || (e = t.tr)).setSelection(i), e;
}
var lq = new Be("fix-tables");
function V6(t, e, n, o) {
  const r = t.childCount, i = e.childCount;
  e:
    for (let s = 0, a = 0; s < i; s++) {
      const l = e.child(s);
      for (let c = a, d = Math.min(r, s + 3); c < d; c++)
        if (t.child(c) == l) {
          a = c + 1, n += l.nodeSize;
          continue e;
        }
      o(l, n), a < r && t.child(a).sameMarkup(l) ? V6(t.child(a), l, n + 1, o) : l.nodesBetween(0, l.content.size, o, n + 1), n += l.nodeSize;
    }
}
function j6(t, e) {
  let n;
  const o = (r, i) => {
    r.type.spec.tableRole == "table" && (n = cq(t, r, i, n));
  };
  return e ? e.doc != t.doc && V6(e.doc, t.doc, 0, o) : t.doc.descendants(o), n;
}
function cq(t, e, n, o) {
  const r = pt.get(e);
  if (!r.problems)
    return o;
  o || (o = t.tr);
  const i = [];
  for (let l = 0; l < r.height; l++)
    i.push(0);
  for (let l = 0; l < r.problems.length; l++) {
    const c = r.problems[l];
    if (c.type == "collision") {
      const d = e.nodeAt(c.pos);
      if (!d)
        continue;
      const u = d.attrs;
      for (let f = 0; f < u.rowspan; f++)
        i[c.row + f] += c.n;
      o.setNodeMarkup(
        o.mapping.map(n + 1 + c.pos),
        null,
        xi(u, u.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      i[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const d = e.nodeAt(c.pos);
      if (!d)
        continue;
      o.setNodeMarkup(o.mapping.map(n + 1 + c.pos), null, {
        ...d.attrs,
        rowspan: d.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const d = e.nodeAt(c.pos);
      if (!d)
        continue;
      o.setNodeMarkup(o.mapping.map(n + 1 + c.pos), null, {
        ...d.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const d = o.mapping.map(n);
      o.delete(d, d + e.nodeSize);
    }
  }
  let s, a;
  for (let l = 0; l < i.length; l++)
    i[l] && (s == null && (s = l), a = l);
  for (let l = 0, c = n + 1; l < r.height; l++) {
    const d = e.child(l), u = c + d.nodeSize, f = i[l];
    if (f > 0) {
      let h = "cell";
      d.firstChild && (h = d.firstChild.type.spec.tableRole);
      const m = [];
      for (let v = 0; v < f; v++) {
        const y = $t(t.schema)[h].createAndFill();
        y && m.push(y);
      }
      const g = (l == 0 || s == l - 1) && a == l ? c + 1 : u - 1;
      o.insert(o.mapping.map(g), m);
    }
    c = u;
  }
  return o.setMeta(lq, { fixTables: !0 });
}
function mo(t) {
  const e = t.selection, n = tf(t), o = n.node(-1), r = n.start(-1), i = pt.get(o);
  return { ...e instanceof Qe ? i.rectBetween(
    e.$anchorCell.pos - r,
    e.$headCell.pos - r
  ) : i.findCell(n.pos - r), tableStart: r, map: i, table: o };
}
function U6(t, { map: e, tableStart: n, table: o }, r) {
  let i = r > 0 ? -1 : 0;
  nq(e, o, r + i) && (i = r == 0 || r == e.width ? null : 0);
  for (let s = 0; s < e.height; s++) {
    const a = s * e.width + r;
    if (r > 0 && r < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], c = o.nodeAt(l);
      t.setNodeMarkup(
        t.mapping.map(n + l),
        null,
        F6(c.attrs, r - e.colCount(l))
      ), s += c.attrs.rowspan - 1;
    } else {
      const l = i == null ? $t(o.type.schema).cell : o.nodeAt(e.map[a + i]).type, c = e.positionAt(s, r, o);
      t.insert(t.mapping.map(n + c), l.createAndFill());
    }
  }
  return t;
}
function dq(t, e) {
  if (!Vn(t))
    return !1;
  if (e) {
    const n = mo(t);
    e(U6(t.tr, n, n.left));
  }
  return !0;
}
function uq(t, e) {
  if (!Vn(t))
    return !1;
  if (e) {
    const n = mo(t);
    e(U6(t.tr, n, n.right));
  }
  return !0;
}
function fq(t, { map: e, table: n, tableStart: o }, r) {
  const i = t.mapping.maps.length;
  for (let s = 0; s < e.height; ) {
    const a = s * e.width + r, l = e.map[a], c = n.nodeAt(l), d = c.attrs;
    if (r > 0 && e.map[a - 1] == l || r < e.width - 1 && e.map[a + 1] == l)
      t.setNodeMarkup(
        t.mapping.slice(i).map(o + l),
        null,
        xi(d, r - e.colCount(l))
      );
    else {
      const u = t.mapping.slice(i).map(o + l);
      t.delete(u, u + c.nodeSize);
    }
    s += d.rowspan;
  }
}
function pq(t, e) {
  if (!Vn(t))
    return !1;
  if (e) {
    const n = mo(t), o = t.tr;
    if (n.left == 0 && n.right == n.map.width)
      return !1;
    for (let r = n.right - 1; fq(o, n, r), r != n.left; r--) {
      const i = n.tableStart ? o.doc.nodeAt(n.tableStart - 1) : o.doc;
      if (!i)
        throw RangeError("No table found");
      n.table = i, n.map = pt.get(i);
    }
    e(o);
  }
  return !0;
}
function hq(t, e, n) {
  var o;
  const r = $t(e.type.schema).header_cell;
  for (let i = 0; i < t.width; i++)
    if (((o = e.nodeAt(t.map[i + n * t.width])) == null ? void 0 : o.type) != r)
      return !1;
  return !0;
}
function W6(t, { map: e, tableStart: n, table: o }, r) {
  var i;
  let s = n;
  for (let c = 0; c < r; c++)
    s += o.child(c).nodeSize;
  const a = [];
  let l = r > 0 ? -1 : 0;
  hq(e, o, r + l) && (l = r == 0 || r == e.height ? null : 0);
  for (let c = 0, d = e.width * r; c < e.width; c++, d++)
    if (r > 0 && r < e.height && e.map[d] == e.map[d - e.width]) {
      const u = e.map[d], f = o.nodeAt(u).attrs;
      t.setNodeMarkup(n + u, null, {
        ...f,
        rowspan: f.rowspan + 1
      }), c += f.colspan - 1;
    } else {
      const u = l == null ? $t(o.type.schema).cell : (i = o.nodeAt(e.map[d + l * e.width])) == null ? void 0 : i.type, f = u == null ? void 0 : u.createAndFill();
      f && a.push(f);
    }
  return t.insert(s, $t(o.type.schema).row.create(null, a)), t;
}
function mq(t, e) {
  if (!Vn(t))
    return !1;
  if (e) {
    const n = mo(t);
    e(W6(t.tr, n, n.top));
  }
  return !0;
}
function gq(t, e) {
  if (!Vn(t))
    return !1;
  if (e) {
    const n = mo(t);
    e(W6(t.tr, n, n.bottom));
  }
  return !0;
}
function vq(t, { map: e, table: n, tableStart: o }, r) {
  let i = 0;
  for (let c = 0; c < r; c++)
    i += n.child(c).nodeSize;
  const s = i + n.child(r).nodeSize, a = t.mapping.maps.length;
  t.delete(i + o, s + o);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, d = r * e.width; c < e.width; c++, d++) {
    const u = e.map[d];
    if (!l.has(u)) {
      if (l.add(u), r > 0 && u == e.map[d - e.width]) {
        const f = n.nodeAt(u).attrs;
        t.setNodeMarkup(t.mapping.slice(a).map(u + o), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (r < e.height && u == e.map[d + e.width]) {
        const f = n.nodeAt(u), h = f.attrs, m = f.type.create(
          { ...h, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), g = e.positionAt(r + 1, c, n);
        t.insert(t.mapping.slice(a).map(o + g), m), c += h.colspan - 1;
      }
    }
  }
}
function yq(t, e) {
  if (!Vn(t))
    return !1;
  if (e) {
    const n = mo(t), o = t.tr;
    if (n.top == 0 && n.bottom == n.map.height)
      return !1;
    for (let r = n.bottom - 1; vq(o, n, r), r != n.top; r--) {
      const i = n.tableStart ? o.doc.nodeAt(n.tableStart - 1) : o.doc;
      if (!i)
        throw RangeError("No table found");
      n.table = i, n.map = pt.get(n.table);
    }
    e(o);
  }
  return !0;
}
function db(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function bq({ width: t, height: e, map: n }, o) {
  let r = o.top * t + o.left, i = r, s = (o.bottom - 1) * t + o.left, a = r + (o.right - o.left - 1);
  for (let l = o.top; l < o.bottom; l++) {
    if (o.left > 0 && n[i] == n[i - 1] || o.right < t && n[a] == n[a + 1])
      return !0;
    i += t, a += t;
  }
  for (let l = o.left; l < o.right; l++) {
    if (o.top > 0 && n[r] == n[r - t] || o.bottom < e && n[s] == n[s + t])
      return !0;
    r++, s++;
  }
  return !1;
}
function ub(t, e) {
  const n = t.selection;
  if (!(n instanceof Qe) || n.$anchorCell.pos == n.$headCell.pos)
    return !1;
  const o = mo(t), { map: r } = o;
  if (bq(r, o))
    return !1;
  if (e) {
    const i = t.tr, s = {};
    let a = W.empty, l, c;
    for (let d = o.top; d < o.bottom; d++)
      for (let u = o.left; u < o.right; u++) {
        const f = r.map[d * r.width + u], h = o.table.nodeAt(f);
        if (!(s[f] || !h))
          if (s[f] = !0, l == null)
            l = f, c = h;
          else {
            db(h) || (a = a.append(h.content));
            const m = i.mapping.map(f + o.tableStart);
            i.delete(m, m + h.nodeSize);
          }
      }
    if (l == null || c == null)
      return !0;
    if (i.setNodeMarkup(l + o.tableStart, null, {
      ...F6(
        c.attrs,
        c.attrs.colspan,
        o.right - o.left - c.attrs.colspan
      ),
      rowspan: o.bottom - o.top
    }), a.size) {
      const d = l + 1 + c.content.size, u = db(c) ? l + 1 : d;
      i.replaceWith(u + o.tableStart, d + o.tableStart, a);
    }
    i.setSelection(
      new Qe(i.doc.resolve(l + o.tableStart))
    ), e(i);
  }
  return !0;
}
function fb(t, e) {
  const n = $t(t.schema);
  return wq(({ node: o }) => n[o.type.spec.tableRole])(t, e);
}
function wq(t) {
  return (e, n) => {
    var o;
    const r = e.selection;
    let i, s;
    if (r instanceof Qe) {
      if (r.$anchorCell.pos != r.$headCell.pos)
        return !1;
      i = r.$anchorCell.nodeAfter, s = r.$anchorCell.pos;
    } else {
      if (i = QK(r.$from), !i)
        return !1;
      s = (o = Us(r.$from)) == null ? void 0 : o.pos;
    }
    if (i == null || s == null || i.attrs.colspan == 1 && i.attrs.rowspan == 1)
      return !1;
    if (n) {
      let a = i.attrs;
      const l = [], c = a.colwidth;
      a.rowspan > 1 && (a = { ...a, rowspan: 1 }), a.colspan > 1 && (a = { ...a, colspan: 1 });
      const d = mo(e), u = e.tr;
      for (let h = 0; h < d.right - d.left; h++)
        l.push(
          c ? {
            ...a,
            colwidth: c && c[h] ? [c[h]] : null
          } : a
        );
      let f;
      for (let h = d.top; h < d.bottom; h++) {
        let m = d.map.positionAt(h, d.left, d.table);
        h == d.top && (m += i.nodeSize);
        for (let g = d.left, v = 0; g < d.right; g++, v++)
          g == d.left && h == d.top || u.insert(
            f = u.mapping.map(m + d.tableStart, 1),
            t({ node: i, row: h, col: g }).createAndFill(l[v])
          );
      }
      u.setNodeMarkup(
        s,
        t({ node: i, row: d.top, col: d.left }),
        l[0]
      ), r instanceof Qe && u.setSelection(
        new Qe(
          u.doc.resolve(r.$anchorCell.pos),
          f ? u.doc.resolve(f) : void 0
        )
      ), n(u);
    }
    return !0;
  };
}
function xq(t, e) {
  return function(n, o) {
    if (!Vn(n))
      return !1;
    const r = tf(n);
    if (r.nodeAfter.attrs[t] === e)
      return !1;
    if (o) {
      const i = n.tr;
      n.selection instanceof Qe ? n.selection.forEachCell((s, a) => {
        s.attrs[t] !== e && i.setNodeMarkup(a, null, {
          ...s.attrs,
          [t]: e
        });
      }) : i.setNodeMarkup(r.pos, null, {
        ...r.nodeAfter.attrs,
        [t]: e
      }), o(i);
    }
    return !0;
  };
}
function kq(t) {
  return function(e, n) {
    if (!Vn(e))
      return !1;
    if (n) {
      const o = $t(e.schema), r = mo(e), i = e.tr, s = r.map.cellsInRect(
        t == "column" ? {
          left: r.left,
          top: 0,
          right: r.right,
          bottom: r.map.height
        } : t == "row" ? {
          left: 0,
          top: r.top,
          right: r.map.width,
          bottom: r.bottom
        } : r
      ), a = s.map((l) => r.table.nodeAt(l));
      for (let l = 0; l < s.length; l++)
        a[l].type == o.header_cell && i.setNodeMarkup(
          r.tableStart + s[l],
          o.cell,
          a[l].attrs
        );
      if (i.steps.length == 0)
        for (let l = 0; l < s.length; l++)
          i.setNodeMarkup(
            r.tableStart + s[l],
            o.header_cell,
            a[l].attrs
          );
      n(i);
    }
    return !0;
  };
}
function pb(t, e, n) {
  const o = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let r = 0; r < o.length; r++) {
    const i = e.table.nodeAt(o[r]);
    if (i && i.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function ml(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? kq(t) : function(n, o) {
    if (!Vn(n))
      return !1;
    if (o) {
      const r = $t(n.schema), i = mo(n), s = n.tr, a = pb("row", i, r), l = pb(
        "column",
        i,
        r
      ), d = (t === "column" ? a : t === "row" ? l : !1) ? 1 : 0, u = t == "column" ? {
        left: 0,
        top: d,
        right: 1,
        bottom: i.map.height
      } : t == "row" ? {
        left: d,
        top: 0,
        right: i.map.width,
        bottom: 1
      } : i, f = t == "column" ? l ? r.cell : r.header_cell : t == "row" ? a ? r.cell : r.header_cell : r.cell;
      i.map.cellsInRect(u).forEach((h) => {
        const m = h + i.tableStart, g = s.doc.nodeAt(m);
        g && s.setNodeMarkup(m, f, g.attrs);
      }), o(s);
    }
    return !0;
  };
}
ml("row", {
  useDeprecatedLogic: !0
});
ml("column", {
  useDeprecatedLogic: !0
});
var Cq = ml("cell", {
  useDeprecatedLogic: !0
});
function Sq(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n)
      return t.pos - n.nodeSize;
    for (let o = t.index(-1) - 1, r = t.before(); o >= 0; o--) {
      const i = t.node(-1).child(o), s = i.lastChild;
      if (s)
        return r - 1 - s.nodeSize;
      r -= i.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let o = t.indexAfter(-1), r = t.after(); o < n.childCount; o++) {
      const i = n.child(o);
      if (i.childCount)
        return r + 1;
      r += i.nodeSize;
    }
  }
  return null;
}
function hb(t) {
  return function(e, n) {
    if (!Vn(e))
      return !1;
    const o = Sq(tf(e), t);
    if (o == null)
      return !1;
    if (n) {
      const r = e.doc.resolve(o);
      n(
        e.tr.setSelection(le.between(r, tq(r))).scrollIntoView()
      );
    }
    return !0;
  };
}
function Aq(t, e) {
  const n = t.selection.$anchor;
  for (let o = n.depth; o > 0; o--)
    if (n.node(o).type.spec.tableRole == "table")
      return e && e(
        t.tr.delete(n.before(o), n.after(o)).scrollIntoView()
      ), !0;
  return !1;
}
function xc(t, e) {
  const n = t.selection;
  if (!(n instanceof Qe))
    return !1;
  if (e) {
    const o = t.tr, r = $t(t.schema).cell.createAndFill().content;
    n.forEachCell((i, s) => {
      i.content.eq(r) || o.replace(
        o.mapping.map(s + 1),
        o.mapping.map(s + i.nodeSize - 1),
        new ee(r, 0, 0)
      );
    }), o.docChanged && e(o);
  }
  return !0;
}
function Eq(t) {
  if (!t.size)
    return null;
  let { content: e, openStart: n, openEnd: o } = t;
  for (; e.childCount == 1 && (n > 0 && o > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, o--, e = e.child(0).content;
  const r = e.child(0), i = r.type.spec.tableRole, s = r.type.schema, a = [];
  if (i == "row")
    for (let l = 0; l < e.childCount; l++) {
      let c = e.child(l).content;
      const d = l ? 0 : Math.max(0, n - 1), u = l < e.childCount - 1 ? 0 : Math.max(0, o - 1);
      (d || u) && (c = Zh(
        $t(s).row,
        new ee(c, d, u)
      ).content), a.push(c);
    }
  else if (i == "cell" || i == "header_cell")
    a.push(
      n || o ? Zh(
        $t(s).row,
        new ee(e, n, o)
      ).content : e
    );
  else
    return null;
  return _q(s, a);
}
function _q(t, e) {
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (let s = i.childCount - 1; s >= 0; s--) {
      const { rowspan: a, colspan: l } = i.child(s).attrs;
      for (let c = r; c < r + a; c++)
        n[c] = (n[c] || 0) + l;
    }
  }
  let o = 0;
  for (let r = 0; r < n.length; r++)
    o = Math.max(o, n[r]);
  for (let r = 0; r < n.length; r++)
    if (r >= e.length && e.push(W.empty), n[r] < o) {
      const i = $t(t).cell.createAndFill(), s = [];
      for (let a = n[r]; a < o; a++)
        s.push(i);
      e[r] = e[r].append(W.from(s));
    }
  return { height: e.length, width: o, rows: e };
}
function Zh(t, e) {
  const n = t.createAndFill();
  return new cm(n).replace(0, n.content.size, e).doc;
}
function Mq({ width: t, height: e, rows: n }, o, r) {
  if (t != o) {
    const i = [], s = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = [];
      for (let d = i[a] || 0, u = 0; d < o; u++) {
        let f = l.child(u % l.childCount);
        d + f.attrs.colspan > o && (f = f.type.createChecked(
          xi(
            f.attrs,
            f.attrs.colspan,
            d + f.attrs.colspan - o
          ),
          f.content
        )), c.push(f), d += f.attrs.colspan;
        for (let h = 1; h < f.attrs.rowspan; h++)
          i[a + h] = (i[a + h] || 0) + f.attrs.colspan;
      }
      s.push(W.from(c));
    }
    n = s, t = o;
  }
  if (e != r) {
    const i = [];
    for (let s = 0, a = 0; s < r; s++, a++) {
      const l = [], c = n[a % e];
      for (let d = 0; d < c.childCount; d++) {
        let u = c.child(d);
        s + u.attrs.rowspan > r && (u = u.type.create(
          {
            ...u.attrs,
            rowspan: Math.max(1, r - u.attrs.rowspan)
          },
          u.content
        )), l.push(u);
      }
      i.push(W.from(l));
    }
    n = i, e = r;
  }
  return { width: t, height: e, rows: n };
}
function Tq(t, e, n, o, r, i, s) {
  const a = t.doc.type.schema, l = $t(a);
  let c, d;
  if (r > e.width)
    for (let u = 0, f = 0; u < e.height; u++) {
      const h = n.child(u);
      f += h.nodeSize;
      const m = [];
      let g;
      h.lastChild == null || h.lastChild.type == l.cell ? g = c || (c = l.cell.createAndFill()) : g = d || (d = l.header_cell.createAndFill());
      for (let v = e.width; v < r; v++)
        m.push(g);
      t.insert(t.mapping.slice(s).map(f - 1 + o), m);
    }
  if (i > e.height) {
    const u = [];
    for (let m = 0, g = (e.height - 1) * e.width; m < Math.max(e.width, r); m++) {
      const v = m >= e.width ? !1 : n.nodeAt(e.map[g + m]).type == l.header_cell;
      u.push(
        v ? d || (d = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill())
      );
    }
    const f = l.row.create(null, W.from(u)), h = [];
    for (let m = e.height; m < i; m++)
      h.push(f);
    t.insert(t.mapping.slice(s).map(o + n.nodeSize - 2), h);
  }
  return !!(c || d);
}
function mb(t, e, n, o, r, i, s, a) {
  if (s == 0 || s == e.height)
    return !1;
  let l = !1;
  for (let c = r; c < i; c++) {
    const d = s * e.width + c, u = e.map[d];
    if (e.map[d - e.width] == u) {
      l = !0;
      const f = n.nodeAt(u), { top: h, left: m } = e.findCell(u);
      t.setNodeMarkup(t.mapping.slice(a).map(u + o), null, {
        ...f.attrs,
        rowspan: s - h
      }), t.insert(
        t.mapping.slice(a).map(e.positionAt(s, m, n)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: h + f.attrs.rowspan - s
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return l;
}
function gb(t, e, n, o, r, i, s, a) {
  if (s == 0 || s == e.width)
    return !1;
  let l = !1;
  for (let c = r; c < i; c++) {
    const d = c * e.width + s, u = e.map[d];
    if (e.map[d - 1] == u) {
      l = !0;
      const f = n.nodeAt(u), h = e.colCount(u), m = t.mapping.slice(a).map(u + o);
      t.setNodeMarkup(
        m,
        null,
        xi(
          f.attrs,
          s - h,
          f.attrs.colspan - (s - h)
        )
      ), t.insert(
        m + f.nodeSize,
        f.type.createAndFill(
          xi(f.attrs, 0, s - h)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function vb(t, e, n, o, r) {
  let i = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!i)
    throw new Error("No table found");
  let s = pt.get(i);
  const { top: a, left: l } = o, c = l + r.width, d = a + r.height, u = t.tr;
  let f = 0;
  function h() {
    if (i = n ? u.doc.nodeAt(n - 1) : u.doc, !i)
      throw new Error("No table found");
    s = pt.get(i), f = u.mapping.maps.length;
  }
  Tq(u, s, i, n, c, d, f) && h(), mb(u, s, i, n, l, c, a, f) && h(), mb(u, s, i, n, l, c, d, f) && h(), gb(u, s, i, n, a, d, l, f) && h(), gb(u, s, i, n, a, d, c, f) && h();
  for (let m = a; m < d; m++) {
    const g = s.positionAt(m, l, i), v = s.positionAt(m, c, i);
    u.replace(
      u.mapping.slice(f).map(g + n),
      u.mapping.slice(f).map(v + n),
      new ee(r.rows[m - a], 0, 0)
    );
  }
  h(), u.setSelection(
    new Qe(
      u.doc.resolve(n + s.positionAt(a, l, i)),
      u.doc.resolve(n + s.positionAt(d - 1, c - 1, i))
    )
  ), e(u);
}
var Oq = xm({
  ArrowLeft: kc("horiz", -1),
  ArrowRight: kc("horiz", 1),
  ArrowUp: kc("vert", -1),
  ArrowDown: kc("vert", 1),
  "Shift-ArrowLeft": Cc("horiz", -1),
  "Shift-ArrowRight": Cc("horiz", 1),
  "Shift-ArrowUp": Cc("vert", -1),
  "Shift-ArrowDown": Cc("vert", 1),
  Backspace: xc,
  "Mod-Backspace": xc,
  Delete: xc,
  "Mod-Delete": xc
});
function Fc(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function kc(t, e) {
  return (n, o, r) => {
    if (!r)
      return !1;
    const i = n.selection;
    if (i instanceof Qe)
      return Fc(
        n,
        o,
        pe.near(i.$headCell, e)
      );
    if (t != "horiz" && !i.empty)
      return !1;
    const s = K6(r, t, e);
    if (s == null)
      return !1;
    if (t == "horiz")
      return Fc(
        n,
        o,
        pe.near(n.doc.resolve(i.head + e), e)
      );
    {
      const a = n.doc.resolve(s), l = z6(a, t, e);
      let c;
      return l ? c = pe.near(l, 1) : e < 0 ? c = pe.near(n.doc.resolve(a.before(-1)), -1) : c = pe.near(n.doc.resolve(a.after(-1)), 1), Fc(n, o, c);
    }
  };
}
function Cc(t, e) {
  return (n, o, r) => {
    if (!r)
      return !1;
    const i = n.selection;
    let s;
    if (i instanceof Qe)
      s = i;
    else {
      const l = K6(r, t, e);
      if (l == null)
        return !1;
      s = new Qe(n.doc.resolve(l));
    }
    const a = z6(s.$headCell, t, e);
    return a ? Fc(
      n,
      o,
      new Qe(s.$anchorCell, a)
    ) : !1;
  };
}
function Iq(t, e) {
  const n = t.state.doc, o = Us(n.resolve(e));
  return o ? (t.dispatch(t.state.tr.setSelection(new Qe(o))), !0) : !1;
}
function Dq(t, e, n) {
  if (!Vn(t.state))
    return !1;
  let o = Eq(n);
  const r = t.state.selection;
  if (r instanceof Qe) {
    o || (o = {
      width: 1,
      height: 1,
      rows: [
        W.from(
          Zh($t(t.state.schema).cell, n)
        )
      ]
    });
    const i = r.$anchorCell.node(-1), s = r.$anchorCell.start(-1), a = pt.get(i).rectBetween(
      r.$anchorCell.pos - s,
      r.$headCell.pos - s
    );
    return o = Mq(o, a.right - a.left, a.bottom - a.top), vb(t.state, t.dispatch, s, a, o), !0;
  } else if (o) {
    const i = tf(t.state), s = i.start(-1);
    return vb(
      t.state,
      t.dispatch,
      s,
      pt.get(i.node(-1)).findCell(i.pos - s),
      o
    ), !0;
  } else
    return !1;
}
function Rq(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey)
    return;
  const o = yb(t, e.target);
  let r;
  if (e.shiftKey && t.state.selection instanceof Qe)
    i(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && o && (r = Us(t.state.selection.$anchor)) != null && ((n = bp(t, e)) == null ? void 0 : n.pos) != r.pos)
    i(r, e), e.preventDefault();
  else if (!o)
    return;
  function i(l, c) {
    let d = bp(t, c);
    const u = hr.getState(t.state) == null;
    if (!d || !u0(l, d))
      if (u)
        d = l;
      else
        return;
    const f = new Qe(l, d);
    if (u || !t.state.selection.eq(f)) {
      const h = t.state.tr.setSelection(f);
      u && h.setMeta(hr, l.pos), t.dispatch(h);
    }
  }
  function s() {
    t.root.removeEventListener("mouseup", s), t.root.removeEventListener("dragstart", s), t.root.removeEventListener("mousemove", a), hr.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(hr, -1));
  }
  function a(l) {
    const c = l, d = hr.getState(t.state);
    let u;
    if (d != null)
      u = t.state.doc.resolve(d);
    else if (yb(t, c.target) != o && (u = bp(t, e), !u))
      return s();
    u && i(u, c);
  }
  t.root.addEventListener("mouseup", s), t.root.addEventListener("dragstart", s), t.root.addEventListener("mousemove", a);
}
function K6(t, e, n) {
  if (!(t.state.selection instanceof le))
    return null;
  const { $head: o } = t.state.selection;
  for (let r = o.depth - 1; r >= 0; r--) {
    const i = o.node(r);
    if ((n < 0 ? o.index(r) : o.indexAfter(r)) != (n < 0 ? 0 : i.childCount))
      return null;
    if (i.type.spec.tableRole == "cell" || i.type.spec.tableRole == "header_cell") {
      const a = o.before(r), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
function yb(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function bp(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return n && n ? Us(t.state.doc.resolve(n.pos)) : null;
}
var Pq = class {
  constructor(e, n) {
    this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${n}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Qh(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, Qh(
      e,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function Qh(t, e, n, o, r, i) {
  var s;
  let a = 0, l = !0, c = e.firstChild;
  const d = t.firstChild;
  if (d) {
    for (let u = 0, f = 0; u < d.childCount; u++) {
      const { colspan: h, colwidth: m } = d.child(u).attrs;
      for (let g = 0; g < h; g++, f++) {
        const v = r == f ? i : m && m[g], y = v ? v + "px" : "";
        if (a += v || o, v || (l = !1), c)
          c.style.width != y && (c.style.width = y), c = c.nextSibling;
        else {
          const x = document.createElement("col");
          x.style.width = y, e.appendChild(x);
        }
      }
    }
    for (; c; ) {
      const u = c.nextSibling;
      (s = c.parentNode) == null || s.removeChild(c), c = u;
    }
    l ? (n.style.width = a + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = a + "px");
  }
}
var ln = new Be(
  "tableColumnResizing"
);
function Lq({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: o = Pq,
  lastColumnResizable: r = !0
} = {}) {
  const i = new Ne({
    key: ln,
    state: {
      init(s, a) {
        var l, c;
        const d = (c = (l = i.spec) == null ? void 0 : l.props) == null ? void 0 : c.nodeViews, u = $t(a.schema).table.name;
        return o && d && (d[u] = (f, h) => new o(f, n, h)), new Nq(-1, !1);
      },
      apply(s, a) {
        return a.apply(s);
      }
    },
    props: {
      attributes: (s) => {
        const a = ln.getState(s);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, a) => {
          Bq(s, a, t, r);
        },
        mouseleave: (s) => {
          $q(s);
        },
        mousedown: (s, a) => {
          zq(s, a, e, n);
        }
      },
      decorations: (s) => {
        const a = ln.getState(s);
        if (a && a.activeHandle > -1)
          return Uq(s, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return i;
}
var Nq = class Hc {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, o = e.getMeta(ln);
    if (o && o.setHandle != null)
      return new Hc(o.setHandle, !1);
    if (o && o.setDragging !== void 0)
      return new Hc(n.activeHandle, o.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let r = e.mapping.map(n.activeHandle, -1);
      return Xh(e.doc.resolve(r)) || (r = -1), new Hc(r, n.dragging);
    }
    return n;
  }
};
function Bq(t, e, n, o) {
  if (!t.editable)
    return;
  const r = ln.getState(t.state);
  if (r && !r.dragging) {
    const i = Hq(e.target);
    let s = -1;
    if (i) {
      const { left: a, right: l } = i.getBoundingClientRect();
      e.clientX - a <= n ? s = bb(t, e, "left", n) : l - e.clientX <= n && (s = bb(t, e, "right", n));
    }
    if (s != r.activeHandle) {
      if (!o && s !== -1) {
        const a = t.state.doc.resolve(s), l = a.node(-1), c = pt.get(l), d = a.start(-1);
        if (c.colCount(a.pos - d) + a.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      q6(t, s);
    }
  }
}
function $q(t) {
  if (!t.editable)
    return;
  const e = ln.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && q6(t, -1);
}
function zq(t, e, n, o) {
  var r;
  if (!t.editable)
    return !1;
  const i = (r = t.dom.ownerDocument.defaultView) != null ? r : window, s = ln.getState(t.state);
  if (!s || s.activeHandle == -1 || s.dragging)
    return !1;
  const a = t.state.doc.nodeAt(s.activeHandle), l = Fq(t, s.activeHandle, a.attrs);
  t.dispatch(
    t.state.tr.setMeta(ln, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function c(u) {
    i.removeEventListener("mouseup", c), i.removeEventListener("mousemove", d);
    const f = ln.getState(t.state);
    f != null && f.dragging && (Vq(
      t,
      f.activeHandle,
      wb(f.dragging, u, n)
    ), t.dispatch(
      t.state.tr.setMeta(ln, { setDragging: null })
    ));
  }
  function d(u) {
    if (!u.which)
      return c(u);
    const f = ln.getState(t.state);
    if (f && f.dragging) {
      const h = wb(f.dragging, u, n);
      xb(
        t,
        f.activeHandle,
        h,
        o
      );
    }
  }
  return xb(
    t,
    s.activeHandle,
    l,
    o
  ), i.addEventListener("mouseup", c), i.addEventListener("mousemove", d), e.preventDefault(), !0;
}
function Fq(t, e, { colspan: n, colwidth: o }) {
  const r = o && o[o.length - 1];
  if (r)
    return r;
  const i = t.domAtPos(e);
  let a = i.node.childNodes[i.offset].offsetWidth, l = n;
  if (o)
    for (let c = 0; c < n; c++)
      o[c] && (a -= o[c], l--);
  return a / l;
}
function Hq(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function bb(t, e, n, o) {
  const r = n == "right" ? -o : o, i = t.posAtCoords({
    left: e.clientX + r,
    top: e.clientY
  });
  if (!i)
    return -1;
  const { pos: s } = i, a = Us(t.state.doc.resolve(s));
  if (!a)
    return -1;
  if (n == "right")
    return a.pos;
  const l = pt.get(a.node(-1)), c = a.start(-1), d = l.map.indexOf(a.pos - c);
  return d % l.width == 0 ? -1 : c + l.map[d - 1];
}
function wb(t, e, n) {
  const o = e.clientX - t.startX;
  return Math.max(n, t.startWidth + o);
}
function q6(t, e) {
  t.dispatch(
    t.state.tr.setMeta(ln, { setHandle: e })
  );
}
function Vq(t, e, n) {
  const o = t.state.doc.resolve(e), r = o.node(-1), i = pt.get(r), s = o.start(-1), a = i.colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let c = 0; c < i.height; c++) {
    const d = c * i.width + a;
    if (c && i.map[d] == i.map[d - i.width])
      continue;
    const u = i.map[d], f = r.nodeAt(u).attrs, h = f.colspan == 1 ? 0 : a - i.colCount(u);
    if (f.colwidth && f.colwidth[h] == n)
      continue;
    const m = f.colwidth ? f.colwidth.slice() : jq(f.colspan);
    m[h] = n, l.setNodeMarkup(s + u, null, { ...f, colwidth: m });
  }
  l.docChanged && t.dispatch(l);
}
function xb(t, e, n, o) {
  const r = t.state.doc.resolve(e), i = r.node(-1), s = r.start(-1), a = pt.get(i).colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(r.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && Qh(
    i,
    l.firstChild,
    l,
    o,
    a,
    n
  );
}
function jq(t) {
  return Array(t).fill(0);
}
function Uq(t, e) {
  var n;
  const o = [], r = t.doc.resolve(e), i = r.node(-1);
  if (!i)
    return ze.empty;
  const s = pt.get(i), a = r.start(-1), l = s.colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < s.height; c++) {
    const d = l + c * s.width;
    if ((l == s.width - 1 || s.map[d] != s.map[d + 1]) && (c == 0 || s.map[d] != s.map[d - s.width])) {
      const u = s.map[d], f = a + u + i.nodeAt(u).nodeSize - 1, h = document.createElement("div");
      h.className = "column-resize-handle", (n = ln.getState(t)) != null && n.dragging && o.push(
        ht.node(
          a + u,
          a + u + i.nodeAt(u).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), o.push(ht.widget(f, h));
    }
  }
  return ze.create(t.doc, o);
}
function Wq({
  allowTableNodeSelection: t = !1
} = {}) {
  return new Ne({
    key: hr,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const o = e.getMeta(hr);
        if (o != null)
          return o == -1 ? null : o;
        if (n == null || !e.docChanged)
          return n;
        const { deleted: r, pos: i } = e.mapping.mapResult(n);
        return r ? null : i;
      }
    },
    props: {
      decorations: rq,
      handleDOMEvents: {
        mousedown: Rq
      },
      createSelectionBetween(e) {
        return hr.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: Iq,
      handleKeyDown: Oq,
      handlePaste: Dq
    },
    appendTransaction(e, n, o) {
      return aq(
        o,
        j6(o, n),
        t
      );
    }
  });
}
const Kq = (t, e, n) => {
  if (!t.doc)
    return t;
  const o = t.doc.nodeAt(e);
  if (!o || n === o.attrs.backgroundColor)
    return t;
  const r = {
    ...o.attrs,
    backgroundColor: n
  };
  return t.setNodeMarkup(e, o.type, r, o.marks);
}, qq = (t, e, n) => {
  const { doc: o, selection: r } = t;
  return !o || !r || !(r instanceof Qe) || r.forEachCell((i, s) => {
    t = Kq(t, s, n);
  }), t;
}, kb = (t, e) => ({ tr: n, state: o, dispatch: r }) => {
  const { selection: i } = o;
  return n = n.setSelection(i), n = qq(n, e, t), n.docChanged ? (r == null || r(n), !0) : !1;
}, Gq = Te.create({
  name: "tableCellBackground",
  addOptions() {
    return {
      types: ["tableCell"],
      HTMLAttributes: {}
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          backgroundColor: {
            parseHTML: (t) => t.style.backgroundColor || "",
            renderHTML: (t) => !t.backgroundColor || t.backgroundColor === "" ? {} : {
              style: `background-color: ${t.backgroundColor}`
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTableCellBackground: (t) => kb(t, this.options),
      unsetTableCellBackground: () => kb("", this.options)
    };
  }
}), Jq = ot.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((o) => parseInt(o, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "th" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["th", He(this.options.HTMLAttributes, t), 0];
  }
}), Yq = ot.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", He(this.options.HTMLAttributes, t), 0];
  }
}), Xq = ot.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((o) => parseInt(o, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "td" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["td", He(this.options.HTMLAttributes, t), 0];
  }
});
function em(t, e) {
  return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
}
function Cb(t, e, n, o, r, i) {
  var s;
  let a = 0, l = !0, c = e.firstChild;
  const d = t.firstChild;
  if (d !== null)
    for (let u = 0, f = 0; u < d.childCount; u += 1) {
      const { colspan: h, colwidth: m } = d.child(u).attrs;
      for (let g = 0; g < h; g += 1, f += 1) {
        const v = r === f ? i : m && m[g], y = v ? `${v}px` : "";
        if (a += v || o, v || (l = !1), c) {
          if (c.style.width !== y) {
            const [x, C] = em(o, v);
            c.style.setProperty(x, C);
          }
          c = c.nextSibling;
        } else {
          const x = document.createElement("col"), [C, b] = em(o, v);
          x.style.setProperty(C, b), e.appendChild(x);
        }
      }
    }
  for (; c; ) {
    const u = c.nextSibling;
    (s = c.parentNode) === null || s === void 0 || s.removeChild(c), c = u;
  }
  l ? (n.style.width = `${a}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${a}px`);
}
class Zq {
  constructor(e, n) {
    this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Cb(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type !== this.node.type ? !1 : (this.node = e, Cb(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
  }
}
function Qq(t, e, n, o) {
  let r = 0, i = !0;
  const s = [], a = t.firstChild;
  if (!a)
    return {};
  for (let u = 0, f = 0; u < a.childCount; u += 1) {
    const { colspan: h, colwidth: m } = a.child(u).attrs;
    for (let g = 0; g < h; g += 1, f += 1) {
      const v = n === f ? o : m && m[g];
      r += v || e, v || (i = !1);
      const [y, x] = em(e, v);
      s.push([
        "col",
        { style: `${y}: ${x}` }
      ]);
    }
  }
  const l = i ? `${r}px` : "", c = i ? "" : `${r}px`;
  return { colgroup: ["colgroup", {}, ...s], tableWidth: l, tableMinWidth: c };
}
function Sb(t, e) {
  return t.createAndFill();
}
function eG(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((n) => {
    const o = t.nodes[n];
    o.spec.tableRole && (e[o.spec.tableRole] = o);
  }), t.cached.tableNodeTypes = e, e;
}
function tG(t, e, n, o, r) {
  const i = eG(t), s = [], a = [];
  for (let c = 0; c < n; c += 1) {
    const d = Sb(i.cell);
    if (d && a.push(d), o) {
      const u = Sb(i.header_cell);
      u && s.push(u);
    }
  }
  const l = [];
  for (let c = 0; c < e; c += 1)
    l.push(i.row.createChecked(null, o && c === 0 ? s : a));
  return i.table.createChecked(null, l);
}
function nG(t) {
  return t instanceof Qe;
}
const Sc = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!nG(e))
    return !1;
  let n = 0;
  const o = r2(e.ranges[0].$from, (i) => i.type.name === "table");
  return o == null || o.node.descendants((i) => {
    if (i.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(i.type.name) && (n += 1);
  }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, oG = ot.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: Zq,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: o, tableMinWidth: r } = Qq(t, this.options.cellMinWidth);
    return [
      "table",
      He(this.options.HTMLAttributes, e, {
        style: o ? `width: ${o}` : `min-width: ${r}`
      }),
      n,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: o, dispatch: r, editor: i }) => {
        const s = tG(i.schema, t, e, n);
        if (r) {
          const a = o.selection.from + 1;
          o.replaceSelectionWith(s).scrollIntoView().setSelection(le.near(o.doc.resolve(a)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => dq(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => uq(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => pq(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => mq(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => gq(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => yq(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => Aq(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => ub(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => fb(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => ml("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => ml("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => Cq(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => ub(t, e) ? !0 : fb(t, e),
      setCellAttribute: (t, e) => ({ state: n, dispatch: o }) => xq(t, e)(n, o),
      goToNextCell: () => ({ state: t, dispatch: e }) => hb(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => hb(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && j6(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: n }) => {
        if (n) {
          const o = Qe.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(o);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: Sc,
      "Mod-Backspace": Sc,
      Delete: Sc,
      "Mod-Delete": Sc
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        Lq({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      Wq({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: Ee(oe(t, "tableRole", e))
    };
  }
}), rG = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i, iG = /CrOS/, sG = /android|ipad|playbook|silk/i;
function Ab(t = {}) {
  let e = t.ua || typeof navigator < "u" && navigator.userAgent;
  return e && typeof e == "object" && e.headers && typeof e.headers["user-agent"] == "string" && (e = e.headers["user-agent"]), typeof e != "string" ? !1 : !!(rG.test(e) && !iG.test(e) || t.tablet && sG.test(e) || t.tablet && t.featureDetect && navigator && navigator.maxTouchPoints > 1 && e.includes("Macintosh") && e.includes("Safari"));
}
const aG = ["disabled"], lG = {
  "content-class": "table-grid-size-editor",
  "content-style": "padding:0"
}, cG = { class: "flex flex-col flex-wrap gap-1 justify-between" }, dG = ["onMouseover", "onMousedown"], uG = /* @__PURE__ */ B("div", { class: "w-4 h-4 p-1 border box-border" }, null, -1), fG = [
  uG
], pG = { class: "text-center text-sm text-zinc-600 mt-2" }, hG = /* @__PURE__ */ T({
  __name: "CreateTablePopover",
  props: {
    disabled: {
      default: !1
    }
  },
  emits: ["create-table"],
  setup(t, { emit: e }) {
    const n = e, o = O(!1), r = O(!0), i = zn({
      rows: Ab() ? ql : Kl,
      cols: Ab() ? ql : Kl
    }), s = zn({
      rows: Gl,
      cols: Gl
    });
    function a(d, u) {
      d === i.rows && (i.rows = Math.min(d + 1, ql)), u === i.cols && (i.cols = Math.min(u + 1, ql)), s.rows = d, s.cols = u;
    }
    function l(d, u) {
      n("create-table", { rows: d, cols: u, withHeaderRow: p(r) }), c();
    }
    function c() {
      o.value = !1, r.value = !1, i.rows = Kl, i.cols = Kl, s.rows = Gl, s.cols = Gl;
    }
    return (d, u) => (k(), _(p(Ls), null, {
      default: w(() => [
        E(p(Ns), { "as-child": "" }, {
          default: w(() => [
            B("button", {
              disabled: t.disabled,
              class: "m-0 p-0"
            }, [
              D(d.$slots, "trigger")
            ], 8, aG)
          ]),
          _: 3
        }),
        E(p(Bs), {
          class: "w-full",
          align: "start",
          side: "bottom"
        }, {
          default: w(() => [
            B("div", lG, [
              B("div", cG, [
                (k(!0), U(ve, null, Fe(i.rows, (f) => (k(), U("div", {
                  key: "r" + f,
                  class: "flex gap-1"
                }, [
                  (k(!0), U(ve, null, Fe(i.cols, (h) => (k(), U("div", {
                    key: "c" + h,
                    class: Ze([[
                      h <= s.cols && f <= s.rows && "bg-foreground border-border",
                      "cursor-pointer"
                    ], "pa-1"]),
                    onMouseover: (m) => a(f, h),
                    onMousedown: (m) => l(f, h)
                  }, fG, 42, dG))), 128))
                ]))), 128))
              ]),
              B("div", pG, q(s.rows) + " x " + q(s.cols), 1)
            ])
          ]),
          _: 1
        })
      ]),
      _: 3
    }));
  }
}), mG = { style: { display: "flex" } }, gG = /* @__PURE__ */ T({
  __name: "TableActionButton",
  props: {
    editor: {},
    icon: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t;
    function n(o) {
      e.disabled || e.editor.chain().focus().insertTable({ ...o, withHeaderRow: !1 }).run();
    }
    return (o, r) => (k(), _(hG, {
      onCreateTable: n,
      disabled: o.disabled
    }, {
      trigger: w(() => [
        B("div", mG, [
          E(ye, {
            icon: o.icon,
            tooltip: o.tooltip,
            disabled: o.disabled,
            color: o.color,
            action: o.action,
            "is-active": o.isActive
          }, null, 8, ["icon", "tooltip", "disabled", "color", "action", "is-active"])
        ])
      ]),
      _: 1
    }, 8, ["disabled"]));
  }
}), $J = oG.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      resizable: !0,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1,
      button: ({ editor: e, t: n }) => ({
        component: gG,
        componentProps: {
          disabled: e.isActive("table") || !1,
          icon: "Table",
          tooltip: n("editor.table.tooltip")
        }
      })
    };
  },
  addExtensions() {
    return [
      Yq.configure(this.options.tableRow),
      Jq.configure(this.options.tableHeader),
      Xq.configure(this.options.tableCell),
      Gq.configure(this.options.tableCellBackground)
    ];
  }
}), vG = /* @__PURE__ */ T({
  __name: "AIButton",
  props: {
    editor: {},
    icon: { default: void 0 },
    title: { default: void 0 },
    tooltip: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    shortcutKeys: { default: void 0 },
    customClass: { default: "" },
    loading: { type: Boolean, default: !1 },
    tooltipOptions: { default: void 0 },
    color: { default: void 0 },
    action: { type: Function, default: void 0 },
    isActive: { type: Function, default: void 0 }
  },
  setup(t) {
    const e = t, n = pn(), { toast: o } = js();
    function r() {
      var s, a, l;
      const i = (a = (s = e.editor.extensionManager.extensions.find((c) => c.name === "AI")) == null ? void 0 : s.options) == null ? void 0 : a.completions;
      if (typeof i != "function") {
        o({
          title: "AI completions method is not set or is not a valid function",
          variant: "destructive"
        });
        return;
      }
      if (i.constructor.name !== "AsyncFunction") {
        o({
          title: "AI completions method must be an asynchronous function",
          variant: "destructive"
        });
        return;
      }
      n.state.AIMenu = !0, (l = e.editor) == null || l.commands.focus();
    }
    return (i, s) => (k(), _(ye, {
      action: r,
      title: "AI",
      disabled: i.disabled,
      icon: i.icon,
      tooltip: i.tooltip
    }, null, 8, ["disabled", "icon", "tooltip"]));
  }
}), zJ = ot.create({
  name: "AI",
  group: "block",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      toolbar: !1,
      button: ({ editor: e, t: n }) => ({
        component: vG,
        componentProps: {
          icon: "Sparkles",
          tooltip: n("editor.AI.ask")
        }
      })
    };
  }
}), FJ = Te.create({
  name: "painter",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ye,
        componentProps: {
          action: () => {
            e.commands.setPainter(e == null ? void 0 : e.state.selection.$head.marks());
          },
          icon: "PaintRoller",
          tooltip: o("editor.format")
        }
      })
    };
  },
  addCommands() {
    return {
      setPainter: (t) => ({
        view: {
          dispatch: e,
          state: { tr: n },
          dom: o
        }
      }) => {
        const s = `url("data:image/svg+xml;utf8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="#000" d="M9 22v-6H4V7q0-1.65 1.175-2.825T8 3h12v13h-5v6zM6 10h12V5h-1v4h-2V5h-1v2h-2V5H8q-.825 0-1.412.588T6 7zm0 4h12v-2H6zm0 0v-2z"/></svg>')}"), auto`;
        return o.style.cursor = s, e(n.setMeta("painterAction", { type: "start", marks: t })), !0;
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ne({
        key: new Be("format-painter"),
        state: {
          init: () => [],
          apply: (t, e) => {
            const n = t.getMeta("painterAction");
            return n && n.type === "start" ? e = n.marks : n && n.type === "end" && (e = []), e;
          }
        },
        props: {
          handleDOMEvents: {
            mousedown(t, e) {
              const n = this.getState(t.state);
              if (!n || n.length == 0)
                return t.dom.style.cursor = "", !1;
              const o = () => {
                document.removeEventListener("mouseup", o);
                let {
                  dispatch: r,
                  state: { tr: i, selection: s },
                  dom: a
                } = t;
                a.style.cursor = "", i = i.removeMark(s.from, s.to);
                for (let l of n)
                  l.type.name != "link" && (i = i.addMark(s.from, s.to, l));
                r(i.setMeta("painterAction", { type: "end" }));
              };
              return document.addEventListener("mouseup", o), !0;
            }
          }
        }
      })
    ];
  }
});
function yG(t, e) {
  const n = atob(t.split(",")[1]), o = new Array(n.length);
  for (let i = 0; i < n.length; i++)
    o[i] = n.charCodeAt(i);
  const r = new Uint8Array(o);
  return new Blob([r], { type: e });
}
function bG(t, e) {
  return new File([t], e, { type: t.type });
}
const HJ = Te.create({
  name: "importWord",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      upload: void 0,
      convert: void 0,
      limit: 1024 * 1024 * 10,
      //10MB
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ye,
        componentProps: {
          action: () => {
            var r;
            return (r = e.commands) == null ? void 0 : r.toggleImportWord();
          },
          disabled: !e.can().setHorizontalRule(),
          icon: "Word",
          tooltip: o("editor.importWord.tooltip")
        }
      })
    };
  },
  addCommands() {
    return {
      toggleImportWord: () => ({ chain: t, editor: e }) => {
        const { toast: n } = js(), { t: o } = et();
        async function r(l) {
          var h;
          const d = new DOMParser().parseFromString(l, "text/html"), u = d.querySelectorAll("img");
          if (!u.length)
            return d.body.innerHTML;
          if (xu(e, "image")) {
            const m = (h = e.extensionManager.extensions.find(
              (g) => g.name === "importWord"
            )) == null ? void 0 : h.options;
            if (m && typeof m.upload == "function") {
              const g = [];
              for (let y of u) {
                const x = y.getAttribute("src"), C = yG(x, "image/jpeg"), b = bG(C, "image.jpeg");
                g.push(b);
              }
              const v = await m.upload(g);
              for (let y = 0; y < u.length; y++) {
                const x = u[y];
                x.setAttribute("src", v[y].src);
                const C = x.parentElement;
                (C == null ? void 0 : C.tagName) === "P" && (C.insertAdjacentElement("beforebegin", x), !C.hasChildNodes() && C.textContent === "" && C.remove());
              }
              return d.body.innerHTML;
            } else
              return console.warn("Image Upload method found, skip image conversion"), d.body.innerHTML;
          } else
            return console.error("Image extension not found, unable to convert image"), d.body.innerHTML;
        }
        async function i(l) {
          const c = await r(l);
          e.chain().setContent(c.toString(), !0).run(), n({
            title: o.value("editor.importWord.success")
          });
        }
        const { open: s, onChange: a } = yO({
          accept: ".docx",
          reset: !0,
          multiple: !1
        });
        return s(), a(async (l) => {
          const [c] = Array.from(l ?? []);
          if (c) {
            if (c.size > this.options.limit) {
              n({
                title: o.value("editor.importWord.fileTooLarge"),
                variant: "destructive"
              });
              return;
            }
            if (this.options.convert) {
              const d = await this.options.convert(c);
              i(d);
            } else {
              const d = new FormData(), u = JSON.stringify({
                collaboration_features: {
                  comments: !0,
                  user_id: "e3",
                  track_changes: !0
                },
                formatting: {
                  resets: "none",
                  defaults: "inline",
                  styles: "inline",
                  comments: "basic"
                }
              });
              d.append("config", u), d.append("file", c), fetch("https://docx-converter.cke-cs.com/v2/convert/docx-html", {
                method: "POST",
                body: d
              }).then((f) => f.json()).then(async (f) => {
                i(f.html);
              }).catch((f) => {
                n({
                  title: o.value("editor.importWord.error"),
                  variant: "destructive"
                }), console.error("Error:", f);
              });
            }
          }
        }), !1;
      }
    };
  }
}), Yd = /* @__PURE__ */ T({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(t) {
    const e = t, n = P(() => {
      const { class: o, ...r } = e;
      return r;
    });
    return (o, r) => (k(), _(p(mL), j({
      class: p(fe)("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", e.class)
    }, n.value), {
      default: w(() => [
        D(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rs = new Be("upload-image"), wG = () => new Ne({
  key: rs,
  state: {
    init() {
      return ze.empty;
    },
    apply(t, e) {
      e = e.map(t.mapping, t.doc);
      const n = t.getMeta(rs);
      return n != null && n.add ? n.add.forEach(({ id: o, pos: r, src: i }) => {
        const s = xG(i), a = ht.widget(r, s, { id: o });
        e = e.add(t.doc, [a]);
      }) : n != null && n.remove && n.remove.forEach((o) => {
        e = e.remove(e.find(void 0, void 0, (r) => r.id === o));
      }), e;
    }
  },
  props: {
    decorations(t) {
      return this.getState(t);
    }
  }
});
function xG(t) {
  const e = document.createElement("div"), n = document.createElement("img");
  return n.setAttribute("class", "opacity-50"), n.src = t, n.onload = () => {
    e.setAttribute("class", "img-placeholder");
  }, e.appendChild(n), e;
}
function kG(t, e) {
  var r;
  const o = rs.getState(t).find(void 0, void 0, (i) => i.id === e);
  return o.length ? (r = o[0]) == null ? void 0 : r.from : null;
}
const G6 = ({ validateFn: t, onUpload: e }) => (n, o, r) => {
  n.forEach((i) => {
    if (t && !t(i))
      return;
    const s = Date.now().toString(), a = o.state.tr;
    a.selection.empty || a.deleteSelection();
    const l = URL.createObjectURL(i);
    a.setMeta(rs, {
      add: [{ id: s, pos: r, src: l }]
    }), o.dispatch(a), e(i).then(
      (c) => {
        var g;
        const { schema: d } = o.state, u = kG(o.state, s);
        if (u === null)
          return;
        const f = typeof c == "object" ? l : c, h = (g = d.nodes.image) == null ? void 0 : g.create({ src: f });
        if (!h)
          return;
        const m = o.state.tr.replaceWith(u, u, h).setMeta(rs, { remove: [s] });
        o.dispatch(m);
      },
      () => {
        const c = o.state.tr.delete(r, r).setMeta(rs, { remove: [s] });
        o.dispatch(c);
      }
    );
  });
}, CG = (t, e, n) => {
  var r;
  const o = Array.from(((r = e.clipboardData) == null ? void 0 : r.files) || []);
  if (o.length) {
    e.preventDefault();
    const i = t.state.selection.from;
    return n(o, t, i + 1), !0;
  }
  return !1;
}, SG = (t, e, n, o) => {
  var i;
  const r = Array.from(((i = e.dataTransfer) == null ? void 0 : i.files) || []);
  if (!n && r.length) {
    e.preventDefault();
    const s = t.posAtCoords({
      left: e.clientX,
      top: e.clientY
    });
    if (s)
      return o(r, t, s.pos + 1), !0;
  }
  return !1;
}, AG = { class: "flex items-center w-full p-3 my-3 hover:bg-accent border border-border text-muted-foreground cursor-pointer rounded-sm transition-all" }, EG = { class: "flex justify-between items-center w-full" }, _G = { class: "flex justify-center items-center gap-3" }, MG = { class: "text-sm" }, TG = { class: "flex items-center gap-2" }, OG = /* @__PURE__ */ T({
  __name: "ImageUploader",
  props: {
    ...Cl
  },
  setup(t) {
    const e = t, n = O(""), o = O(), { t: r } = et();
    function i(c) {
      var m, g;
      const d = (m = c == null ? void 0 : c.target) == null ? void 0 : m.files;
      if (!e.editor || e.editor.isDestroyed || d.length === 0)
        return;
      const u = d[0], f = (g = e.editor.extensionManager.extensions.find(
        (v) => v.name === "imageUpload"
      )) == null ? void 0 : g.options;
      G6({
        validateFn: (v) => !0,
        onUpload: f.upload
      })([u], e.editor.view, e.getPos());
    }
    function s() {
      e.editor.chain().setImage({ src: n.value }).deleteRange({ from: e.getPos(), to: e.getPos() }).focus().run();
    }
    function a() {
      e.deleteNode();
    }
    function l() {
      var c;
      (c = o.value) == null || c.click();
    }
    return (c, d) => (k(), _(p(kl), {
      class: "p-0 m-0",
      "data-drag-handle": ""
    }, {
      default: w(() => [
        E(p(Ls), {
          defaultOpen: "",
          modal: ""
        }, {
          default: w(() => [
            E(p(Ns), { "as-child": "" }, {
              default: w(() => [
                B("div", AG, [
                  B("div", EG, [
                    B("div", _G, [
                      E(p(xe), {
                        name: "ImageUp",
                        class: "w-6 h-6"
                      }),
                      B("span", MG, q(p(r)("editor.image.dialog.title")), 1)
                    ]),
                    E(p(xe), {
                      name: "Trash2",
                      class: "hover:text-foreground",
                      onClick: yt(a, ["stop"])
                    })
                  ])
                ])
              ]),
              _: 1
            }),
            E(p(Bs), {
              trapFocus: "",
              class: "w-full",
              onOpenAutoFocus: (u) => u.preventDefault()
            }, {
              default: w(() => [
                E(p(Gg), {
                  "default-value": "upload",
                  class: "w-[400px]",
                  activationMode: "manual"
                }, {
                  default: w(() => [
                    E(p(Jg), { class: "grid w-full grid-cols-2" }, {
                      default: w(() => [
                        E(p(dl), { value: "upload" }, {
                          default: w(() => [
                            he(q(p(r)("editor.image.dialog.tab.upload")), 1)
                          ]),
                          _: 1
                        }),
                        E(p(dl), { value: "link" }, {
                          default: w(() => [
                            he(q(p(r)("editor.image.dialog.tab.url")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    E(p(Yd), { value: "upload" }, {
                      default: w(() => [
                        E(p(Pt), {
                          class: "w-full mt-1",
                          size: "sm",
                          onClick: l
                        }, {
                          default: w(() => [
                            he(q(p(r)("editor.image.dialog.tab.upload")), 1)
                          ]),
                          _: 1
                        }),
                        B("input", {
                          type: "file",
                          accept: "image/*",
                          ref_key: "fileInput",
                          ref: o,
                          multiple: "",
                          style: { display: "none" },
                          onChange: i
                        }, null, 544)
                      ]),
                      _: 1
                    }),
                    E(p(Yd), { value: "link" }, {
                      default: w(() => [
                        B("form", {
                          onSubmit: yt(s, ["prevent"])
                        }, [
                          B("div", TG, [
                            E(p(Rr), {
                              type: "url",
                              autofocus: "",
                              required: "",
                              modelValue: n.value,
                              "onUpdate:modelValue": d[0] || (d[0] = (u) => n.value = u),
                              placeholder: p(r)("editor.image.dialog.placeholder")
                            }, null, 8, ["modelValue", "placeholder"]),
                            E(p(Pt), { type: "submit" }, {
                              default: w(() => [
                                he(q(p(r)("editor.image.dialog.button.apply")), 1)
                              ]),
                              _: 1
                            })
                          ])
                        ], 32)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["onOpenAutoFocus"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), IG = {
  acceptMimes: ["image/jpeg", "image/gif", "image/png", "image/jpg"],
  maxSize: 1024 * 1024 * 5
  // 5MB
}, DG = (t) => `${(t / 1024 / 1024).toFixed(2)}MB`, VJ = ot.create({
  name: "imageUpload",
  isolating: !0,
  defining: !0,
  group: "block",
  draggable: !1,
  selectable: !0,
  inline: !1,
  onCreate() {
    if (typeof this.options.upload != "function")
      throw new Error("Image upload function should be a function");
  },
  parseHTML() {
    return [{ tag: `div[data-type="${this.name}"]` }];
  },
  renderHTML() {
    return ["div", { "data-type": this.name }];
  },
  addCommands() {
    return {
      setImageUpload: () => ({ commands: t }) => t.insertContent(`<div data-type="${this.name}"></div>`)
    };
  },
  addNodeView() {
    return Sl(OG);
  },
  addOptions() {
    var t;
    return {
      ...IG,
      ...(t = this.parent) == null ? void 0 : t.call(this),
      upload: () => Promise.reject("Image Upload Function"),
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ye,
        componentProps: {
          action: () => e.commands.setImageUpload(),
          disabled: !e.can().setImage({}),
          icon: "ImageUp",
          tooltip: o("editor.image.tooltip")
        }
      })
    };
  },
  addProseMirrorPlugins() {
    const { toast: t } = js(), { t: e } = et(), o = G6({
      validateFn: (r) => this.options.acceptMimes.includes(r.type) ? r.size > this.options.maxSize ? (t({
        description: `${e.value("editor.imageUpload.fileSizeTooBig")} ${DG(this.options.maxSize)}.`,
        duration: 2e3
      }), !1) : !0 : (t({ description: e.value("editor.imageUpload.fileTypeNotSupported"), duration: 2e3 }), !1),
      onUpload: this.options.upload
    });
    return [
      new Ne({
        props: {
          handlePaste: (r, i) => !i.clipboardData || Array.from(i.clipboardData.items || []).some((a) => a.type === "text/html") ? !1 : CG(r, i, o),
          handleDrop: (r, i, s, a) => (!(i instanceof DragEvent) || !i.dataTransfer || SG(r, i, a, o), !1)
        }
      }),
      wG()
    ];
  }
}), RG = { class: "flex items-center w-full p-3 my-3 hover:bg-accent border border-border text-muted-foreground cursor-pointer rounded-sm transition-all" }, PG = {
  key: 0,
  class: "flex justify-center items-center gap-3 text-s"
}, LG = {
  key: 1,
  class: "flex justify-between items-center w-full"
}, NG = { class: "flex justify-center items-center gap-3" }, BG = { class: "text-sm" }, $G = { class: "flex items-center gap-2" }, zG = /* @__PURE__ */ T({
  __name: "VideoUploader",
  props: {
    ...Cl
  },
  setup(t) {
    const e = t, n = O(""), o = O(!1), r = O(), { t: i } = et();
    function s(d) {
      var m, g;
      o.value = !0;
      const u = (m = d == null ? void 0 : d.target) == null ? void 0 : m.files;
      if (!e.editor || e.editor.isDestroyed || u.length === 0)
        return;
      const f = u[0], h = (g = e.editor.extensionManager.extensions.find(
        (v) => v.name === "videoUpload"
      )) == null ? void 0 : g.options;
      h == null || h.upload([f]).then((v) => {
        e.editor.chain().setVideo({ src: v[0].src, width: "100%" }).deleteRange({ from: e.getPos(), to: e.getPos() }).focus().run(), o.value = !1;
      });
    }
    function a() {
      e.editor.chain().setVideo({
        src: n.value,
        width: "100%"
      }).deleteRange({ from: e.getPos(), to: e.getPos() }).focus().run();
    }
    function l() {
      e.deleteNode();
    }
    function c() {
      var d;
      (d = r.value) == null || d.click();
    }
    return (d, u) => (k(), _(p(kl), {
      as: "div",
      "data-drag-handle": ""
    }, {
      default: w(() => [
        E(p(Ls), {
          defaultOpen: "",
          modal: ""
        }, {
          default: w(() => [
            E(p(Ns), { "as-child": "" }, {
              default: w(() => [
                B("div", RG, [
                  o.value ? (k(), U("div", PG, [
                    E(p(xe), {
                      class: "animate-spin w-6 h-6",
                      name: "LoaderCircle"
                    }),
                    B("span", null, q(p(i)("editor.video.dialog.uploading")) + "...", 1)
                  ])) : (k(), U("div", LG, [
                    B("div", NG, [
                      E(p(xe), {
                        name: "Video",
                        class: "w-6 h-6"
                      }),
                      B("span", BG, q(p(i)("editor.video.dialog.title")), 1)
                    ]),
                    E(p(xe), {
                      name: "Trash2",
                      class: "hover:text-foreground",
                      onClick: yt(l, ["stop"])
                    })
                  ]))
                ])
              ]),
              _: 1
            }),
            E(p(Bs), {
              trapFocus: "",
              class: "w-full",
              onOpenAutoFocus: (f) => f.preventDefault()
            }, {
              default: w(() => [
                E(p(Gg), {
                  "default-value": "upload",
                  class: "w-[400px]",
                  activationMode: "manual"
                }, {
                  default: w(() => [
                    E(p(Jg), { class: "grid w-full grid-cols-2" }, {
                      default: w(() => [
                        E(p(dl), { value: "upload" }, {
                          default: w(() => [
                            he(q(p(i)("editor.video.dialog.tab.upload")), 1)
                          ]),
                          _: 1
                        }),
                        E(p(dl), { value: "link" }, {
                          default: w(() => [
                            he(q(p(i)("editor.video.dialog.link")), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    E(p(Yd), { value: "upload" }, {
                      default: w(() => [
                        E(p(Pt), {
                          class: "w-full mt-1",
                          size: "sm",
                          onClick: c
                        }, {
                          default: w(() => [
                            he(q(p(i)("editor.video.dialog.tab.upload")), 1)
                          ]),
                          _: 1
                        }),
                        B("input", {
                          type: "file",
                          accept: "video/*",
                          ref_key: "fileInput",
                          ref: r,
                          multiple: "",
                          style: { display: "none" },
                          onChange: s
                        }, null, 544)
                      ]),
                      _: 1
                    }),
                    E(p(Yd), { value: "link" }, {
                      default: w(() => [
                        B("form", {
                          onSubmit: yt(a, ["prevent"])
                        }, [
                          B("div", $G, [
                            E(p(Rr), {
                              type: "url",
                              autofocus: "",
                              required: "",
                              modelValue: n.value,
                              "onUpdate:modelValue": u[0] || (u[0] = (f) => n.value = f),
                              placeholder: p(i)("editor.video.dialog.placeholder")
                            }, null, 8, ["modelValue", "placeholder"]),
                            E(p(Pt), { type: "submit" }, {
                              default: w(() => [
                                he(q(p(i)("editor.video.dialog.button.apply")), 1)
                              ]),
                              _: 1
                            })
                          ])
                        ], 32)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["onOpenAutoFocus"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), jJ = ot.create({
  name: "videoUpload",
  isolating: !0,
  defining: !0,
  group: "block",
  draggable: !0,
  selectable: !0,
  inline: !1,
  parseHTML() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderHTML() {
    return ["div", { "data-type": this.name }];
  },
  addCommands() {
    return {
      setVideoUpload: () => ({ commands: t }) => t.insertContent(`<div data-type="${this.name}"></div>`)
    };
  },
  addNodeView() {
    return Sl(zG);
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      upload: void 0,
      button: ({ editor: e, t: n }) => ({
        component: ye,
        componentProps: {
          action: () => e.commands.setVideoUpload(),
          isActive: () => e.isActive("video") || !1,
          disabled: !e.can().setVideo({}),
          icon: "Video",
          tooltip: n("editor.video.tooltip")
        }
      })
    };
  }
}), FG = Te.create({
  name: "fontFamily",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (t) => t.style.fontFamily,
            renderHTML: (t) => t.fontFamily ? {
              style: `font-family: ${t.fontFamily}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (t) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t }).run(),
      unsetFontFamily: () => ({ chain: t }) => t().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
    };
  }
}), HG = ["data-font"], VG = /* @__PURE__ */ T({
  __name: "FontFamilyMenuButton",
  props: {
    editor: {},
    disabled: { type: Boolean, default: !1 },
    color: { default: void 0 },
    shortcutKeys: { default: void 0 },
    maxHeight: { default: void 0 },
    tooltip: { default: "" },
    items: { default: () => [] }
  },
  setup(t) {
    const e = t, { t: n } = et(), o = P(() => {
      const s = e.editor.extensionManager.extensions.find((l) => l.name === "fontFamily").options;
      return {
        [n.value("editor.fontFamily.default")]: n.value("editor.fontFamily.default"),
        ...s.fontFamilyMap
      };
    }), r = P(() => Tm(e.editor.state, "textStyle").fontFamily || n.value("editor.fontFamily.default"));
    function i(s) {
      s === r.value ? e.editor.commands.unsetFontFamily() : e.editor.commands.setFontFamily(s);
    }
    return (s, a) => (k(), _(Ii, {
      disabled: s.disabled,
      tooltip: s.tooltip,
      title: r.value,
      btn_class: "min-w-24 max-w-32"
    }, {
      default: w(() => [
        (k(!0), U(ve, null, Fe(o.value, (l, c) => (k(), U(ve, { key: c }, [
          E(p(Vs), {
            checked: r.value === l,
            onClick: (d) => i(l)
          }, {
            default: w(() => [
              B("span", {
                class: "ml-1 h-full",
                "data-font": l,
                style: ct({ fontFamily: l ?? void 0 })
              }, q(l), 13, HG)
            ]),
            _: 2
          }, 1032, ["checked", "onClick"]),
          l === p(n)("editor.fontFamily.default") ? (k(), _(p(Zu), { key: 0 })) : ae("", !0)
        ], 64))), 128))
      ]),
      _: 1
    }, 8, ["disabled", "tooltip", "title"]));
  }
}), UJ = FG.extend({
  name: "fontFamily",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["textStyle"],
      fontFamilyMap: q7,
      button({ editor: e, extension: n, t: o }) {
        return {
          component: VG,
          componentProps: {
            editor: e,
            disabled: !e.can().setFontFamily(""),
            tooltip: o("editor.fontFamily.tooltip")
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (t) => t.style.fontFamily.replace(/['"]/g, ""),
            renderHTML: (t) => t.fontFamily ? {
              style: `font-family: ${t.fontFamily}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (t) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t }).run(),
      unsetFontFamily: () => ({ chain: t }) => t().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
    };
  }
}), wp = pn(), WJ = Te.create({
  name: "preview",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ t: e }) => ({
        component: ye,
        componentProps: {
          icon: "Eye",
          action: () => {
            wp.togglePreview();
          },
          tooltip: e("editor.preview.tooltip"),
          isActive: () => wp.state.showPreview
        }
      })
    };
  },
  addCommands() {
    return {
      togglePreview: () => ({ editor: t }) => (wp.togglePreview(), !0)
    };
  }
}), Eb = pn(), jG = (t, e, n) => RegExp(e ? t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") : t, n ? "gu" : "gui");
function UG(t, e, n, o) {
  const r = [], i = [];
  let s = [], a = 0;
  if (!e)
    return {
      decorationsToReturn: ze.empty,
      results: []
    };
  t == null || t.descendants((l, c) => {
    l.isText ? s[a] ? s[a] = {
      text: s[a].text + l.text,
      pos: s[a].pos
    } : s[a] = {
      text: `${l.text}`,
      pos: c
    } : a += 1;
  }), s = s.filter(Boolean);
  for (const l of s) {
    const { text: c, pos: d } = l, u = Array.from(c.matchAll(e)).filter(([f]) => f.trim());
    for (const f of u) {
      if (f[0] === "")
        break;
      f.index !== void 0 && i.push({
        from: d + f.index,
        to: d + f.index + f[0].length
      });
    }
  }
  for (let l = 0; l < i.length; l += 1) {
    const c = i[l], d = l === o ? `${n} ${n}-current` : n, u = ht.inline(c.from, c.to, {
      class: d
    });
    r.push(u);
  }
  return {
    decorationsToReturn: ze.create(t, r),
    results: i
  };
}
const WG = (t, e, { state: n, dispatch: o }) => {
  if (!e[0])
    return;
  const { from: i, to: s } = e[0];
  o && o(n.tr.insertText(t, i, s));
}, KG = (t, e, n, o) => {
  const r = e + 1;
  if (!o[r])
    return null;
  const { from: i, to: s } = o[e], a = s - i - t.length + n, { from: l, to: c } = o[r];
  return o[r] = {
    to: c - a,
    from: l - a
  }, [a, o];
}, qG = (t, e, { tr: n, dispatch: o }) => {
  let r = 0, i = e.slice();
  if (i.length) {
    for (let s = 0; s < i.length; s += 1) {
      const { from: a, to: l } = i[s];
      n.insertText(t, a, l);
      const c = KG(t, s, r, i);
      c && (r = c[0], i = c[1]);
    }
    o && o(n);
  }
}, GG = new Be("findAndReplacePlugin"), KJ = Te.create({
  name: "findAndReplace",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      searchResultClass: "echo-editor-search-result",
      disableRegex: !0,
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ye,
        componentProps: {
          icon: "DocSearch",
          tooltip: o("editor.findAndReplace.tooltip"),
          shortcutKeys: ["mod", "F"],
          action: () => {
            Eb.toggleFindAndReplace();
          },
          isActive: () => Eb.state.findAndReplace
        }
      })
    };
  },
  addStorage() {
    return {
      searchTerm: "",
      replaceTerm: "",
      results: [],
      lastSearchTerm: "",
      caseSensitive: !1,
      lastCaseSensitive: !1,
      resultIndex: 0,
      lastResultIndex: 0
    };
  },
  addCommands() {
    return {
      setSearchTerm: (t) => ({ editor: e }) => (e.storage.findAndReplace.searchTerm = t, !1),
      setReplaceTerm: (t) => ({ editor: e }) => (e.storage.findAndReplace.replaceTerm = t, !1),
      setCaseSensitive: (t) => ({ editor: e }) => (e.storage.findAndReplace.caseSensitive = t, !1),
      resetIndex: () => ({ editor: t }) => (t.storage.findAndReplace.resultIndex = 0, !1),
      nextSearchResult: () => ({ editor: t }) => {
        const { results: e, resultIndex: n } = t.storage.findAndReplace, o = n + 1;
        return e[o] ? t.storage.findAndReplace.resultIndex = o : t.storage.findAndReplace.resultIndex = 0, !1;
      },
      previousSearchResult: () => ({ editor: t }) => {
        const { results: e, resultIndex: n } = t.storage.findAndReplace, o = n - 1;
        return e[o] ? t.storage.findAndReplace.resultIndex = o : t.storage.findAndReplace.resultIndex = e.length - 1, !1;
      },
      replace: () => ({ editor: t, state: e, dispatch: n }) => {
        const { replaceTerm: o, results: r } = t.storage.findAndReplace;
        return WG(o, r, { state: e, dispatch: n }), !1;
      },
      replaceAll: () => ({ editor: t, tr: e, dispatch: n }) => {
        const { replaceTerm: o, results: r } = t.storage.findAndReplace;
        return qG(o, r, { tr: e, dispatch: n }), !1;
      }
    };
  },
  addProseMirrorPlugins() {
    const t = this.editor, { searchResultClass: e, disableRegex: n } = this.options, o = (s) => t.storage.findAndReplace.lastSearchTerm = s, r = (s) => t.storage.findAndReplace.lastCaseSensitive = s, i = (s) => t.storage.findAndReplace.lastResultIndex = s;
    return [
      new Ne({
        key: GG,
        state: {
          init: () => ze.empty,
          apply({ doc: s, docChanged: a }, l) {
            const { searchTerm: c, lastSearchTerm: d, caseSensitive: u, lastCaseSensitive: f, resultIndex: h, lastResultIndex: m } = t.storage.findAndReplace;
            if (!a && d === c && f === u && m === h)
              return l;
            if (o(c), r(u), i(h), !c)
              return t.storage.findAndReplace.results = [], ze.empty;
            const { decorationsToReturn: g, results: v } = UG(
              s,
              jG(c, n, u),
              e,
              h
            );
            return t.storage.findAndReplace.results = v, g;
          }
        },
        props: {
          decorations(s) {
            return this.getState(s);
          }
        }
      })
    ];
  }
}), { togglePrinter: JG, state: YG } = pn(), qJ = Te.create({
  name: "printer",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, extension: n, t: o }) => ({
        component: ye,
        componentProps: {
          tooltip: o("editor.printer.tooltip"),
          action: () => JG(),
          icon: "Printer",
          shortcutKeys: ["mod", "P"],
          isActive: () => YG.printer
        }
      })
    };
  }
});
kV();
const GJ = {
  install(t) {
    t.component("echo-editor", xV);
  }
};
export {
  zJ as AI,
  ye as ActionButton,
  TJ as BaseKit,
  SJ as Blockquote,
  cJ as Bold,
  wJ as BulletList,
  xJ as Clear,
  pJ as Code,
  hJ as CodeBlock,
  yJ as Color,
  lJ as Columns,
  xV as EchoEditor,
  GJ as EchoEditorPlugin,
  KJ as FindAndReplace,
  UJ as FontFamily,
  vJ as FontSize,
  FJ as FormatPainter,
  MJ as Fullscreen,
  mJ as Heading,
  bJ as Highlight,
  _J as History,
  EJ as HorizontalRule,
  LJ as Image,
  VJ as ImageUpload,
  HJ as ImportWord,
  DJ as Indent,
  dJ as Italic,
  RJ as LineHeight,
  AJ as Link,
  IJ as MoreMark,
  kJ as OrderedList,
  WJ as Preview,
  qJ as Printer,
  PJ as SlashCommand,
  fJ as Strike,
  OJ as SubAndSuperScript,
  $J as Table,
  CJ as TaskList,
  gJ as TextAlign,
  uJ as Underline,
  NJ as Video,
  jJ as VideoUpload,
  GJ as default,
  L9 as en,
  oJ as locale,
  nJ as useEditor,
  R9 as zhHans
};
